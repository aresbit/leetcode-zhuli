# LeetCode 一句话题解 - 0001-0500

[返回目录](./algorithms-review-overview.md)

- [LeetCode 一句话题解 - 0001-0500](#leetcode-一句话题解---0001-0500)
  - [0001 - 0100](#0001---0100)
  - [0101 - 0200](#0101---0200)

代码库地址：  
[https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/0001-0500](https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/0001-0500)

## 0001 - 0100

1 Two Sum

题意：给定一个无序数组和一个值target，返回下标[i, j]使得a[i] + a[j]等于target。

难度：easy

解法：使用哈希表，记录已访问到的值x和下标i，比较当前值是否等于剩余部分target - x。

<hr>

2 Add Two Numbers

题意：使用链表表示两个十进制大数，做加法。

难度：medium

解法：第一道链表题，注意边界case，比如进位问题即可。

<hr>

3 Longest Substring Without Repeating Characters

题意：给定一个字符串，求出最长的不带重复字符的子串长度。

难度：medium

解法：第一道滑动窗口题，后面会有无穷多的类似<b>滑动窗口、子串、子数组类型</b>的问题。使用前后两个指针向前走，中间夹住部分即为滑动窗口。同时使用一个计数器（哈希表）来统计个数，确保条件成立（或者刚好不成立）。

<hr>

4 Median of Two Sorted Arrays

题意：给定两个升序数组，求出两者归并后的中位数。

难度：hard

解法：第一道经典的费脑子题，你就很难理解有的人为什么可以瞬间想到。线性解法是显然的，难点在于如何在<b>不归并</b>的情况下，使用二分方法求出中位数。第一次做我想了一个多钟头也没想清楚。

<hr>

5 Longest Palindromic Substring

题意：给定字符串，返回最长回文子串，需要返回子串。

难度：medium

解法：O(n^2)解法显然，难点在于巧妙且经典的<b>Manacher算法</b>。对于没接触过的人，凭自己琢磨出同样算法几乎不可能，实在太精妙了。

<hr>

6 Zigzag Conversion

题意：把字符串按奇怪的方式排列一下，按部就班的模拟题。

难度：medium

解法：照做即可。

<hr>

7 Reverse Integer

题意：给定一个整数，把除了符号位以外的数位倒过来。

难度：medium

解法：不用字符串，直接用除10模10的办法即可。

<hr>

8 String to Integer (atoi)

题意：实现atoi，字符串转整数的功能。

难度：medium

解法：非常非常经典的，适合用来面试的题目。不难，但考察你耐心、仔细的程度，是很好的工程师考题。

<hr>

9 Palindrome Number

题意：判断一个数是否是回文数。

难度：easy

解法：水题，负数都不是回文数。

<hr>

10 Regular Expression Matching

题意：实现正则表达式中的单字符以及.和*匹配。

难度：hard

解法：第一道parser题，编译原理是计算机科学里极其优雅且复杂，但也非常有用的一门课。写各种解析器就是一种打地基式的劳动，值得练习。正则表达式既简短又博大精深，这个是非常简化的版本。

<hr>

11 Container With Most Water

题意：给定一些高高低低的挡板从左到右排列，相邻宽度都是1。允许你选其中两个挡板，连同地板组成一个容器。请问最多能存多少水？

难度：medium

解法：这个不是著名的接雨水，是一道比较简单的题。<b>双指针</b>逐渐往中间靠拢，一边靠拢一边不断更新能存水的最大值即可。

<hr>

12 Integer to Roman

题意：古老的罗马数字，IVXLCDM。做一下数字转换，把阿拉伯翻译成罗马。

难度：medium

解法：按部就班。

<hr>

13 Roman to Integer

题意：罗马数字转阿拉伯，和前面类似。

难度：easy

解法：按部就班。

<hr>

14 Longest Common Prefix

题意：给定一组字符串，找出最长的公共前缀。

难度：easy

解法：不要考虑<b>字典树</b>之类的复杂结构，直接保留当前最长前缀，逐个比较并更新即可。

<hr>

15 3Sum

题意：给定无序数组和目标值0，返回所有<b>元素和</b>加起来等于0的三元组的下标(i, j, k)。注意不要有重复结果。

难度：medium

解法：第一道<b>变体题</b>，这也是算法题的妙处之一。以同一类问题进行<b>延伸</b>，考察人对事物的理解，以及灵活变通的能力。2Sum有好多变体，包括3sum，4sum等等。3sum可以枚举第一维，对后两维使用2sum做法。

<hr>

16 3Sum Closest

题意：类似3sum，但要求返回一个三元组(i, j, k)使得元素和<b>最接近</b>目标值target。

难度：medium

解法：3sum的变体，和之前方法完全一样，只是更新答案的比较条件有所变化而已。从判断相等改为了<b>判断更为接近</b>。

<hr>

17 Letter Combinations of a Phone Number

题意：给定老式的手机9键键盘，把一串数字翻译成所有可能的字母映射。

难度：medium

解法：按部就班，直接搜即可。

<hr>

18 4Sum

题意：2sum的变体，这次是4个元素相加等于target，要求返回所有可能的组合。

难度：medium

解法：其实还是类似，枚举的维度多了一维，剩余的维度还是按2sum做法搞定。比如你可以左右各一维进行枚举，中间两维进行2sum。方法很多，灵活掌握。

<hr>

19 Remove Nth Node From End of List

题意：给定单链表，删除倒数第n个节点并返回表头。

难度：medium

解法：传统链表题，主要考察仔细一遍过的能力，注意边界case。

<hr>

20 Valid Parentheses

题意：给定括号序列，可能包括大中小括号的混合，判断是否是一个开闭匹配的合法序列。

难度：easy

解法：入栈出栈即可。

<hr>

21 Merge Two Sorted Lists

题意：给定两个有序链表，合并为一个，返回表头。

难度：easy

解法：水题。

<hr>

22 Generate Parentheses

题意：给定长度n，请生成所有不同的，长度为n的，合法的小括号序列。

难度：medium

解法：结果个数是卡塔兰数，至于生成，用记忆化搜索+递归的方法可以完成，且效率可接受。

<hr>

23 Merge k Sorted Lists

题意：给定k个有序链表，合并为一个有序链表，返回表头。

难度：hard

解法：虽然标记为hard，其实思路并不难。保证每次取最小元素的效率即可，因此使用<b>最小堆</b>，不断把k个表头往里放并总是取出当前值<b>最小的表头</b>。

<hr>

24 Swap Nodes in Pairs

题意：给定链表，按每两个元素一对，进行交换。返回表头。

难度：medium

解法：按部就班，注意边界case即可。

<hr>

25 Reverse Nodes in k-Group

题意：和上面的交换两个节点类似，这次是每k个节点一组进行反转。返回表头。

难度：hard

解法：按部就班，多多注意边界case。

<hr>

26 Remove Duplicates from Sorted Array

题意：给定有序数组，<b>去重</b>并把剩余的元素依次往前放，返回剩余元素个数。

难度：easy

解法：解法比讲清楚题意还简单的一道题。

<hr>

27 Remove Element

题意：给定数组，去掉其中所有值为val的元素，并把剩余元素依次往前放，返回剩余元素个数。

难度：easy

解法：水题。

<hr>

28 Find the Index of the First Occurrence in a String

题意：实现strstr，即字符串匹配的功能。

难度：easy

解法：<b>字符串匹配</b>是最最最经典的问题之一，有Sunday、BM、KMP还有多模式匹配的AC自动机等神奇算法。这个题要求比较低，所以暴力匹配也能接受。

<hr>

29 Divide Two Integers

题意：给定两个整数，返回整除结果，但不能用 * / %运算。

难度：medium

解法：很有意思的一题，<b>绑手绑脚还要秀功夫</b>的类型。我专门看了一眼自己当年的代码，一分钟还没理解到底在干嘛。又看了一遍，发现是用类似<b>位运算和除法器</b>（学过数字电路的话肯定就懂了）的思路去做除法。

<hr>

30 Substring with Concatenation of All Words

题意：给定一个长字符串s，和一组<b>长度相同</b>的单词words。找出所有s的子串，使得这些子串恰好等于words中的<b>全部单词</b>以<b>任意顺序</b>拼接起来。返回这些子串的<b>起始下标</b>。

难度：hard

解法：确实比较hard，放下现在算是medium hard。从数据规模，不允许暴力搜索。考虑用滑动窗口+统计出现字符串出现次数的方法。当年用cpp写，还设计了个非常蹩脚的字符串哈希函数，导致代码读起来很费劲。如果用py重写，两个Counter对象就搞定了。我看了大概五分钟才看明白当年的代码想表达什么。

<hr>

31 Next Permutation

题意：给定一个<b>无序且可能有重复元素</b>的数组，返回按<b>字典序</b>的下一个排列。要求就地完成，不复制数组。

难度：medium

解法：总归是个O(n)时间的操作，因为挪动数组元素是线性时间的。

<hr>

32 Longest Valid Parentheses

题意：给定一个小括号序列，返回其中能找到的最长合法序列的长度。

难度：hard

解法：难度是hard，规模上不允许O(n^2)的直白解法。既然是<b>括号匹配</b>，必然想到用栈。但一个栈可以作为数组用，却无法给你快速查找某个值的功能。因此换了一个比较巧的做法，用一个<b>计数</b>表示栈大小，同时用一个<b>哈希表</b>来存放内容，这样就能快速查找并更新内容了。所以这也<b>不能算是个栈</b>，但思路还是用了栈。

<hr>

33 Search in Rotated Sorted Array

题意：一个有序数组经过了（也可能没有）循环移位，请找出target值所在的下标。

难度：medium

解法：和那个“两个有序数组求中位数”一样，属于经典的<b>脑洞题</b>。直白解法很直白，但最高效解法你可能就是想不出来，这种类型的坑货题在LeetCode上还有十几题，散落在各处。二分做法反正我第一次费了很大劲才想出来，<b>自愧不如</b>。我也很难用一句话描述清楚怎么<b>独立想出来这种鬼点子</b>，因为我<b>做不到</b>。

<hr>

34 Find First and Last Position of Element in Sorted Array

题意：给定有序但可能有重复元素的数组，找出某个值target的起始和终止位置。

难度：medium

解法：二分查找，其实就是bisect_left和bisect_right的定义。

<hr>

35 Search Insert Position

题意：给定有序数组，要插入一个新值，请找出应该插入的位置。

难度：easy

解法：二分查找。

<hr>

36 Valid Sudoku

题意：三阶数独，9x9的那种。这次只需要检查一个填法是否合法而已。

难度：medium

解法：按数独的规则记录和检查即可。每行1-9，每列1-9，每个3x3小方格1-9。

<hr>

37 Sudoku Solver

题意：三阶数独，9x9的那种。这次要你用算法来填了。

难度：hard

解法：倒是算个hard，不过按部就班地使用<b>搜索+回溯</b>的方法，其实也不算难。如果一定要求用神奇的<b>Dancing Links算法</b>去做，我还是放弃吧。其实这辈子估计也没打算学会这个算法。

<hr>

38 Count and Say

题意：给定初始字符串“1”，使用游程编码（RLE）的方式不断把这个字符串“读出来”，并用读的结果替换原字符串。如此重复n-1次，返回最终结果。

难度：medium

解法：按部就班，模拟题。

<hr>

39 Combination Sum

题意：给定一个无重复元素的候选集合，找出所有加起来和为target的不同组合，返回全部组合。

难度：medium

解法：非常经典的<b>搜索题</b>，注意设计好递归函数，处理边界case即可。第一次写这种递归代码容易晕，写多了就能找出比较简洁的方式。注意适当<b>剪枝</b>，提高效率。

<hr>

40 Combination Sum II

题意：组合求和的变体，候选集合是可以有重复元素的。

难度：medium

解法：思路完全一样，就是改用一个map计数器来代替set，因为可以有重复值，需要统计每个值当前用了多少次。

<hr>

41 First Missing Positive

题意：给定一个长度为n的无序数组，请找出<b>不在数组中的</b>最小的<b>正整数</b>。要求不能用额外数组或存储结构做记录。

难度：hard

解法：这好像是一道近乎脑筋急转弯的<b>小聪明式的算法题</b>，要求做一件很直白的事，但不能用额外空间。个人非常反感这类<b>“专考聪明人”</b>的题。你得不到任何训练，且每一个这种题都<b>独一无二</b>，没什么规律可言。这题想要省空间，其实就是<b>直接把原数组当成一个bool数组用</b>，在上面叠一层True or False标记，来记录1-n是否都出现过了。如果你做不出来或者想不到，<b>不用有任何失望</b>。这不代表你不聪明，只代表你此时此刻在这道题上不聪明，和过去、和未来毫无关系。

<hr>

42 Trapping Rain Water

题意：给定一个高高低低的一维地形，雨水可以存在各种地势低洼处，给定无穷多的雨量，问总共能存下多少水。

难度：hard

解法：<b>接雨水</b>，这个是LeetCode名梗之一了，二维接雨水也被视为算法题里嘲讽功能最强的题目之一。这种题目虽然很精妙，但也因为其费脑、解法五花八门且实在没什么鸟用，而被视为浪费脑细胞的最佳途径。一维接雨水其实还好，可以视为传统的O(n) DP题。这个hard当年确实费了很多人的脑细胞，而且也很经典。<b>二维接雨水</b>还要离谱的多。

<hr>

43 Multiply Strings

题意：大数乘法，但是用字符串表示的大数。

难度：medium

解法：按部就班，不过对数据格式做一下转换，注意别出错即可。

<hr>

44 Wildcard Matching

题意：通配符匹配，和正则匹配类似，但要求实现?和*匹配功能。

难度：hard

解法：<b>比正则匹配简单</b>，但也算名副其实的hard问题。难度主要在把事情想清楚，代码其实很短。

<hr>

45 Jump Game II

题意：给定一个长度为n的数组nums，你从0位置出发，每次从i位置最多可以往前跳nums[i]步，问最远能到哪儿。

难度：medium

解法：跳数组系列问题中比较简单的一题，这系列有好多个变体。只要<b>每前进一步</b>，不断更新<b>当前能跳到的最远位置</b>即可。

<hr>

46 Permutations

题意：给定无重复元素的数组，返回它的所有不同排列方式。

难度：medium

解法：最直接的思路其实是先排序，然后不断使用<b>next permutation</b>找到下一个排列，直到<b>找不到（也就是变成倒序了）为止</b>。另一种思路就是搜索+记录排列的方式。前者更直观，代码也更好写。

<hr>

47 Permutations II

题意：和上题一样，返回所有排列，但这次数组可能有重复元素。

难度：medium

解法：我还是选择next permutation，这个无所谓重复元素。

<hr>

48 Rotate Image

题意：给定一个n x n矩阵，顺时针旋转90度。

难度：medium

解法：按部就班，注意奇偶情况的处理。

<hr>

49 Group Anagrams

题意：给定一组字符串，把互为anagram的词归到一个组里。

难度：medium

解法：<b>anagram</b>没有中文叫法，只能叫“同字母异序词”。对anagram的处理就是<b>排序之后统一比较</b>，相等就是anagram。

<hr>

50 Pow(x, n)

题意：给定整数x和n，都可以是负数，求x的n次方。

难度：medium

解法：快速幂，二分法。

<hr>

51 N-Queens

题意：N皇后问题，在n x n棋盘上放置n个皇后，不能存在同行、同列、同对角线、同反对角线的情况。返回所有摆法。

难度：hard

解法：这是算法和数据结构课的教科书例子了，可以说是<b>搜索+回溯</b>的教材。

<hr>

52 N-Queens II

题意：N皇后问题，并不能算变体。这次只需要返回解的个数。

难度：hard

解法：搜索+回溯。

<hr>

53 Maximum Subarray

题意：给定数组，求出其中最大的子数组和，返回和。

难度：medium

解法：<b>贪心策略</b>的最经典例子之一。累加并更新最大值，如果累加和为负数，就直接放弃，重置为0。

<hr>

54 Spiral Matrix

题意：给定m x n的矩阵，按照顺时针螺旋方式从外向内遍历。

难度：medium

解法：模拟题，逐字逐句照做即可。

<hr>

55 Jump Game

题意：给定一个长度为n的数组nums，你从0位置出发，每次从i位置最多可以往前跳nums[i]步，问能不能跳到最后一格。

难度：medium

解法：思路和Jump Game II完全一样，为什么这个的题号反而在后面？

<hr>

56 Merge Intervals

题意：给定一些用[x, y]表示的区间，将其进行合并，使得结果中的区间互不重叠。

难度：medium

解法：按<b>先首后尾</b>的顺序进行<b>排序</b>，然后逐个进行合并处理。python的<b>元组默认顺序</b>是个很有用的特性，可以处理很多这类问题。

<hr>

57 Insert Interval

题意：给定一组有序且互不重叠的区间，插入一个新区间[x, y]并进行适当的合并，使得结果依然有序且互不重叠。

难度：medium

解法：和上面的合并区间同一思路，二分找到插入位置，然后逐个合并，直到无需合并为止。

<hr>

58 Length of Last Word

题意：给定一个句子，找出最后一个词的长度。

难度：easy

解法：水题。

<hr>

59 Spiral Matrix II

题意：给定n x n的方阵，按照顺时针由外向内的方式，螺旋遍历这个矩阵，并把1到n^2依次填入每个每个位置。返回结果方阵。

难度：medium

解法：和前面的螺旋遍历一样，模拟题照做即可。

<hr>

60 Permutation Sequence

题意：给定整数n，{1, 2, ..., n}可以组成n!个不同排列。给定整数k，请求出<b>字典序排第k</b>的排列。

难度：hard

解法：<b>组合数学题</b>。可以按<b>子问题</b>逐个考虑。当第1位固定，剩下的n-1位则有(n-1)!种不同排列。逐个往下减，最后一位减完了，整个排列就确定了。

<hr>

61 Rotate List

题意：对一个单链表进行循环右移k次，返回表头。

难度：medium

解法：对k的一些特殊情况处理一下，剩下小心完成即可。可以通过<b>反转数组</b>的方式实现<b>循环移位</b>。[a...a b...b]，先反a，再反b，最后反全部，结果就等效于循环移位。

<hr>

62 Unique Paths

题意：给点m x n矩阵，你从(0, 0)出发，每次只允许向右或者向下，请问到达(m - 1, n - 1)有多少种方法。

难度：medium

解法：其实是个<b>纯数学题</b>，可以用<b>组合公式</b>直接求。但依然可以用土办法，开个二维数组进行累加。组合公式多数人不一定记得住，或者现场推也推不清楚，不必强求。这个应该就是著名的<b>杨辉三角</b>了，二项式定理。

<hr>

63 Unique Paths II

题意：Unique Paths的变体，但这次矩阵中存在无法通过的障碍格子。求到达(m - 1, n - 1)的路径个数。

难度：medium

解法：这次不能套数学公式了，还是用之前相同的办法，<b>二维数组</b>统计个数。

<hr>

64 Minimum Path Sum

题意：给定一个m x n矩阵，每个格子有一个值。从(0, 0)出发，每步只允许向右或向下，到达(m - 1, n - 1)。求可能累加得到的最小路径和。

难度：medium

解法：非常典型且直白的DP题。既然只能<b>右和下</b>，那就在<b>左和上</b>里找一个较小的值即可，这样最后得到的就是最小的路径和。

<hr>

65 Valid Number

题意：给定字符串，判断是否是一个有效的整数、小数或者科学计数法表示的数。

难度：hard

解法：难度全在于是否<b>够仔细，够严谨，够耐心</b>。能一次过这种题的，反正我挺难想象的。<b>边界case</b>多的出奇。

<hr>

66 Plus One

题意：给定用数组表示的一个大数，对其执行+1操作。

难度：easy

解法：没有难度，就是注意进位的情况。

<hr>

67 Add Binary

题意：两个字符串表示的大数相加，二进制。

难度：easy

解法：十进制，二进制，没什么大区别。

<hr>

68 Text Justification

题意：给定一系列单词，要求在<b>保持单词顺序</b>的情况下，按照一个最大宽度进行逐行排版。最终得到的<b>每行总宽度相同</b>，且每行内的单词间空格要尽可能均匀。这个其实就是我们常见的<b>“分散对齐”</b>功能。

难度：hard

解法：难度主要在于要求比较多，费事，实现每一步倒是不难。小心完成即可。

<hr>

69 Sqrt(x)

题意：给定非负整数，求它的平方根，结果<b>向下取整</b>。

难度：easy

解法：二分查找。

<hr>

70 Climbing Stairs

题意：从0级台阶开始，每次允许向上1级或者2级，求到达第n级台阶的方法有多少种。

难度：easy

解法：Fibonacci数列。

<hr>

71 Simplify Path

题意：给定一个“/”分割的文件路径，可能存在“.”和“..”这样的相对路径。求简化后的<b>绝对路径</b>。

难度：medium

解法：解析路径，用栈处理一下，然后拼回完整路径即可。

<hr>

72 Edit Distance

题意：给定两个字符串s和t，求其最短编辑距离。一次编辑包括<b>增、删或改一个字符</b>。

难度：medium

解法：教科书里讲<b>动态规划</b>的经典例子，DP。编辑距离还有个专有名词，叫“Levenshtein distance”。

<hr>

73 Set Matrix Zeroes

题意：给定一个01矩阵，如果某个元素值为0，就把它对应的整行和整列都设为0。要求对所有元素同时做这个操作，且<b>就地完成</b>，不使用额外的矩阵。

难度：medium

解法：挺巧妙的一题，难度当然是<b>就地完成</b>了，否则直接记录一下再处理就很简单。使用第0行和第0列作为标记，再单独用两个变量r0和c0记录0行和0列本身是否有0，这样就<b>有地方做记录</b>了。起码没要求我<b>一个变量也不能用</b>，对吧？

<hr>

74 Search a 2D Matrix

题意：给定一个m x n矩阵，每行向右都是递增的，且下一行的第一个元素都大于上一行末尾。请设计一个高效算法在其中查找目标值是否存在。

难度：medium

解法：注意，这个并不是<b>Young tableau</b>，只是一个有序的一维数组被变形成了二维。把它还原成一维，进行常规的二分查找即可。

<hr>

75 Sort Colors

题意：给定一个包含红白蓝三色的数组，要求<b>就地进行排序</b>，得到红、白、蓝顺序的结果。

难度：medium

解法：既然只有三种颜色，那就把红、蓝<b>往两边放</b>好了，以<b>交换</b>的方式实现。我记得很清楚，当时很讨厌这种<b>“自废武功”</b>式的题目，一边这也不让那也不让，一边又要你做这做那。

<hr>

76 Minimum Window Substring

题意：给定长串s和短串t，请找出<b>长度最短</b>，但<b>包含了t中所有字母</b>的s的子串。t可能有重复字母，所以要在个数上包含。

难度：hard

解法：放在现在是很标准的medium了，<b>滑动窗口题</b>。甚至题目里都提示了window。<b>滑动、计数、判断，再滑动</b>。这会成为一个标准的统计手法，后面经常用到。

<hr>

77 Combinations

题意：给定正整数n和k，返回从1-n中选k个数的所有不同<b>组合</b>。

难度：medium

解法：搜索即可。

<hr>

78 Subsets

题意：给定一个无重复元素的数组（其实就是集合），返回它的所有子集（其实就是幂集）。

难度：medium。

解法：搜索即可。

<hr>

79 Word Search

题意：给定一个m x n矩阵，每一格有一个字母。给定一个目标字符串word，从任意位置出发，上下左右走不重复的格子，对应序列是否能组成word？

难度：medium

解法：<b>搜索+回溯</b>，成功就结束，失败就回溯。

<hr>

80 Remove Duplicates from Sorted Array II

题意：有序数组就地去重，但是重复元素<b>至多保留两个</b>，而不是一个。

难度：medium

解法：大同小异，往前挪的时候，留两个位置即可。

<hr>

81 Search in Rotated Sorted Array II

题意：和之前Search in Rotated Sorted Array类似，一个有序数组经过了（也可能没有）循环移位，但这次数组可能有<b>重复元素</b>。在其中查找一个目标值target。

难度：medium

解法：依然二分，但因为重复值的存在，可能需要做一些+1、-1的O(n)操作，因此<b>最坏时间是线性</b>，最优时间是对数。

<hr>

82 Remove Duplicates from Sorted List II

题意：给定有序单链表，把存在重复值的对应节点<b>全部去掉</b>，只留下无重复值的节点。

难度：medium

解法：注意读题，<b>不是去重</b>，而是有重复的直接全删了。

<hr>

83 Remove Duplicates from Sorted List

题意：给定有序单链表，去重并返回表头。

难度：easy

解法：这个是去重，标准操作。

<hr>

84 Largest Rectangle in Histogram

题意：给定一个高高低低的直方图，每格的宽度是1，求在其中能画出的<b>最大的矩形面积</b>是多少。

难度：hard

解法：很经典也很著名的一道面试题，DP解决。主要思路就是对每个位置，看看<b>往左、往右</b>能找到多少个<b>连续的，高于它的位置</b>。因为必须<b>更高才能继续扩展这个矩形</b>。算好左右宽度之后，乘以高就是<b>面积</b>。

<hr>

85 Maximal Rectangle

题意：给定一个01矩阵，允许在其中<b>框一个矩形</b>，要求其中<b>所有元素都是1</b>。求这个矩形框的最大面积。

难度：hard

解法：相当巧妙的一题，其实就是上一题，<b>直方图矩形面积</b>的变体。我当时花了10多分钟才想到。每往下扫一行，直方图的数据就更新一次。当然，<b>遇到0的时候</b>，直方图的对应列就归零了。

<hr>

86 Partition List

题意：给定一个链表和一个值x，对节点进行划分，使得小于x的元素在前，大于等于x的在后。两组节点的<b>内部顺序</b>要和之前保持一样。

难度：medium

解法：题目已经暗示得很明显了，<b>按顺序</b>一个个分类，两条链表再拼起来即可。

<hr>

87 Scramble String

题意：给定一个长度大于1的字符串s，可以随机选取一个位置切分为两个子串x + y，并将两串交换，变为s' = y + x，称为一次“乱序”。乱序操作可以<b>对子串递归执行</b>。当对一个字符串s递归执行<b>任意次乱序操作</b>后，能否将其变为字符串t？

难度：hard

解法：第一念头当然是DP或者搜索，但既然是hard难度，一定要在效率上有所考虑。其实DP还是搜索没有本质区别，都是对<b>子问题</b>的表达方法。搜索如果效率不达标，也需要<b>记忆化</b>的办法去提高效率。最后我还是选了DP，对s和t的不同位置的<b>同长度子串</b>进行匹配。循环层数比较多，注意不要搞晕了。

<hr>

88 Merge Sorted Array

题意：有序数组归并，但这次<b>数组1</b>中留了足够的位置给你。

难度：easy

解法：水题。

<hr>

89 Gray Code

题意：格雷码，一种很神奇的编码方式。任意相邻的两个代码（包括第一和最后）之间都只有1位不同。给定长度n，请生成一种合法的n位格雷码编码。

难度：medium

解法：<b>递归</b>的完美例子，你用脑子硬想格雷码，肯定想不明白。但想一想n和n-1之间的关系，代码就很容易写出来。递归是一种非常<b>反直觉</b>的思维方式，但又极其优雅，很能体现数学的魅力。你把n-1位格雷码反转过来，开头都加个“1”，再拼起来不就是n位格雷码。

<hr>

90 Subsets II

题意：还是求集合的幂集，但这次元素可能有重复，相当于数学上的multiset。

难度：medium

解法：依然是搜索，这次有重复元素，改用map代替set来进行计数。

<hr>

91 Decode Ways

题意：按照1-26对应A-Z的编码方式，给定一个<b>数字串</b>，请求出有多少种不同的翻译方式来<b>翻译成字母</b>。

难度：medium

解法：线性DP，无序使用数组，只记录最近两三个位置的结果即可。

<hr>

92 Reverse Linked List II

题意：给定单链表和left、right位置，将[left, right]位置内的部分链表反转，并返回表头。

难度：medium

解法：注意处理各种<b>边界case</b>即可，只求仔细。

<hr>

93 Restore IP Addresses

题意：给定一个数字串，允许在其中插入“.”，请返回能得到的所有<b>有效IP地址</b>。

难度：medium

解法：一边搜一边插入点，检查有效性即可。

<hr>

94 Binary Tree Inorder Traversal

题意：给定二叉树，求中序遍历。

难度：easy

解法：这是必知必会了，<b>前中后序遍历</b>。用栈来<b>模拟递归</b>，也属于不算很难的东西。但我记得还有个非常诡异且偏难怪的<b>O(1)空间遍历</b>，那个我至今也没学会。好像和教材里讲过的“线索树”有关。

<hr>

95 Unique Binary Search Trees II

题意：给定值1-n，请问可以组成多少种不同结构的n节点二叉搜索树。返回所有树。

难度：medium

解法：其实这和括号匹配一样，都是卡塔兰数的例子。搜索记录即可，这个规模是<b>阶乘级</b>的，n不可能给到很大，C(n) = (2n)! / ((n + 1)! n!)。

<hr>

96 Unique Binary Search Trees

题意：给定值1-n，请问可以组成多少种不同结构的n节点二叉搜索树。只需要返回个数。

难度：medium

解法：就是<b>卡塔兰数</b>，标准的，原封不动的，C(n) = (2n)! / ((n + 1)! n!)。

<hr>

97 Interleaving String

题意：给定字符串s1、s2、s3，判断s3是否可以由s1、s2的字符<b>按次序穿插组成</b>。

难度：medium

解法：穿插，也就是把s2的字符<b>依次分散插入</b>s1，或者s1分散插入s2（同理）。使用两个指针逐个判断s3的当前字符是否和其中一方匹配，一步步往前。但是，<b>这个思路是错的</b>。虽然很直观，但行不通。需要用DP解决，贪心策略不对。从这点看，这题其实挺hard，属于medium里比较坑人的。

<hr>

98 Validate Binary Search Tree

题意：给定一个二叉树，判断它是不是一个二叉搜索树。

难度：medium

解法：按定义来即可，对<b>每个位置</b>，判断<b>左子树最右</b>和<b>右子树最左</b>是不是分别小于、大于根节点。

<hr>

99 Recover Binary Search Tree

题意：给定一个二叉搜索树，有两个节点的位置被交换了，请在不改变节点指向的情况下，找到两个值并换回来。

难度：medium

解法：挺巧妙且有点难的一题。利用<b>BST的中序遍历结果有序</b>这个特点，如果乱序了，这个地方一定有节点被换了。记录下<b>发现乱序</b>的位置，做交换。要注意两个点<b>恰好相邻</b>和<b>不相邻</b>两种情况

<hr>

100 Same Tree

题意：给定两个二叉树，判断它们是否完全相同。

难度：easy

解法：递归比较即可。

## 0101 - 0200

101 Symmetric Tree

题意：给定一个二叉树，判断是不是左右镜像对称。

难度：easy

解法：从根节点开始，左右同时往下走，按对应位置递归检查即可。

<hr>

102 Binary Tree Level Order Traversal

题意：二叉树层序遍历。

难度：medium

解法：我忘了是不是叫“层序遍历”，总之就是一层层横着扫，使用<b>队列</b>。

<hr>

103 Binary Tree Zigzag Level Order Traversal

题意：还是层序遍历，但是这次按照左右、右左、左右这样交替进行。

难度：medium

解法：可以层序遍历之后，把结果反转一下。

<hr>

104 Maximum Depth of Binary Tree

题意：求二叉树的最大深度。

难度：easy

解法：属于树的基本操作之一，求长度、求深度。递归统计即可。

<hr>

105 Construct Binary Tree from Preorder and Inorder Traversal

题意：给定二叉树的前序和中序遍历结果，重建这棵树。

难度：medium

解法：教科书级的题目，有<b>前中</b>或者<b>中后</b>，就可以重建整棵树，但是<b>前后</b>不行。想一想怎么逐渐往下递归，并找到<b>当前哪个点是根节点</b>。如果值唯一的话，还可以用<b>哈希表</b>把<b>值的对应下标</b>记下来，方便快速找到。

<hr>

106 Construct Binary Tree from Inorder and Postorder Traversal

题意：同上，通过中序和后序遍历结果，重建二叉树。

难度：medium

解法：同上，就是前序和后序的位置不同而已，关键其实都在于用好<b>中序遍历</b>。

<hr>

107 Binary Tree Level Order Traversal II

题意：还是层序遍历，但这次要求从下到上。

难度：medium

解法：把层序遍历的结果上下反转一下即可。

<hr>

108 Convert Sorted Array to Binary Search Tree

题意：给定有序无重复数组，将其转换成一个二叉搜索树。

难度：easy

解法：二叉搜索树的中序遍历是有序的。为了使树的<b>左右子树尽可能平衡</b>，递归重建。每次<b>左右都取一半</b>，中间是根节点。

<hr>

109 Convert Sorted List to Binary Search Tree

题意：这次是有序链表，转换成一个二叉搜索树。

难度：medium

解法：思路完全一样，不过你无法直接取链表的下标，所以要小心往前走到对应位置。链表题考察的都是<b>“仔细”</b>二字。递归时记得记录链表片段的<b>头尾节点</b>。

<hr>

110 Balanced Binary Tree

题意：给定二叉树，检查高度是否平衡。

难度：easy

解法：平衡的定义是，<b>每个节点</b>左右子树的<b>高度差不大于1</b>。按定义递归检查即可。

<hr>

111 Minimum Depth of Binary Tree

题意：给定二叉树，以根节点深度为1，求最小的叶节点深度。

难度：easy

解法：和节点值毫无关系，递归搜索即可。

<hr>

112 Path Sum

题意：给定二叉树和目标值target，判断是否有一条从根到叶的路径，<b>节点值之和</b>等于target。

难度：easy

解法：水题。

<hr>

113 Path Sum II

题意：给定二叉树和目标值target，找出所有<b>节点值之和</b>等于target的路径，并返回。

难度：medium

解法：递归搜索，判断并<b>收集结果</b>。完成后全部返回。

<hr>

114 Flatten Binary Tree to Linked List

题意：给定二叉树，请将其做一下变换，按<b>右指针</b>连接，变成一个链表。要求链表的值恰好和二叉树的<b>前序遍历</b>一样。

难度：medium

解法：一道有点脑洞的题，后面还有好几个这种<b>链表魔术题</b>。肯定是递归，对吧？前序的做法是<b>“根左右”</b>，那就递归处理好，然后按根->左->右把<b>递归结果</b>拼起来。

<hr>

115 Distinct Subsequences

题意：给定字符串s和t，从s中取出子序列，使其等于t。请问有多少种不同取法。

难度：hard

解法：既然是问<b>多少种不同的取法</b>，而不是要<b>找一个</b>，或者判断<b>能不能</b>，那应该是DP了。有这个思路了，设计DP关系式应该不难。凡是这种只关心<b>“上一步”</b>的DP，在空间上都是可以优化的，滚动数组。

<hr>

116 Populating Next Right Pointers in Each Node

题意：给定一个<b>满二叉树</b>（不是完全二叉树，是满），每个节点有一个next指针，将其指向它<b>层序遍历</b>的<b>右边最近</b>的节点。但是不准用层序遍历。

难度：medium

解法：<b>脑洞题</b>，而且脑洞还不小。其实不论是什么树，用<b>层序遍历</b>，相邻的两个节点如果在同一层，肯定要连上一个next指针的。这种思路<b>直观且易实现</b>。但这题就是给你出个脑洞，要求O(1)空间。这个也是满二叉树这种丰满结构才有的特点，左右挨得非常近。我没法解释那个代码是怎么设计出来的，当年<b>我应该没有独立想出来</b>。

<hr>

117 Populating Next Right Pointers in Each Node II

题意：同上116，这次不是满二叉树了，任意二叉树。还是不准用层序遍历。

难度：medium

解法：怎么说呢，用递归思路做其实也不算难，但还是有脑洞的。但是递归显然不符合O(1)空间的要求，递归最起码栈空间是O(h)对吧，h是树的高度。我不太理解这种<b>天才题</b>到达有什么意义，特定场景下如果实在没内存了，一定要做这些<b>走钢丝</b>的事吗？

<hr>

118 Pascal's Triangle

题意：帕斯卡三角，中国叫<b>杨辉三角</b>。给定整数n，输出1-n行杨辉三角。

难度：easy

解法：水题。

<hr>

119 Pascal's Triangle II

题意：同118，这次只输出第n行。

难度：easy

解法：水题。

<hr>

120 Triangle

题意：给定一个三角形的二维数组，每行比上一行多一个元素。从顶部往下左右走，求<b>累加和的最小值</b>。

难度：medium

解法：常规DP题，在<b>上一步的两种路里</b>，找更小的即可。

<hr>

121 Best Time to Buy and Sell Stock

题意：给定一个数组，表示一只股票的每日价格。允许你选一天买入，另一天卖出，<b>做一次买卖交易</b>，求出最大的盈利。如果无法盈利则不交易。

难度：easy

解法：<b>炒股系列</b>，应该总共四五题。总是记录<b>当前的最低价</b>即可。

<hr>

122 Best Time to Buy and Sell Stock II

题意：还是炒股。这期间你可以<b>多次买卖</b>，但不能<b>同一时间多次买入或者持有</b>，必须卖出才能再买。求最大盈利。

难度：medium

解法：其实比121更简单，<b>只要涨价就买</b>，第二天就卖出。属实是<b>短线之神</b>了。

<hr>

123 Best Time to Buy and Sell Stock III

题意：还是炒股。这次你<b>至多</b>可以进行两次买卖，还是不能在同一时间内多次买入持有。求最大盈利。

难度：hard

解法：比121稍微难一点，并不能算真的hard。既然至多2次，那就在0次、1次的基础上，再处理2次的情况。DP解决，后面还会遇到<b>至多k次</b>的情况，还是DP。

<hr>

124 Binary Tree Maximum Path Sum

题意：给定一个二叉树，每个节点有一个值。允许从任意点出发，到达任意点。求所得路径和的最大值。

难度：hard

解法：早年的hard，现在属于中规中矩的medium了。这题如果把树转换成无向图，再去搜索，那就搞复杂了。其实思路就是递归向下，走<b>左右两条路拼起来</b>。另一种情况就是从<b>当前根节点</b>直接出发走一条路。注意，是<b>“当前根节点”</b>，不是整棵树的根节点。

<hr>

125 Valid Palindrome

题意：给定字符串，只保留字母并转换为小写之后，判断是不是回文串。

难度：easy

解法：水题。

<hr>

126 Word Ladder II

题意：给定一个起始词，一个终止词，和一个<b>单词长度都相同</b>的词表。从起始词开始，每次允许<b>更改一个字母</b>，逐步将其变为终止词，并要求每步<b>变换后的词都要在词表中</b>。请给出<b>最短的</b>变换方法，如果不存在则返回空。

难度：hard

解法：这是个图。对，很多<b>图论题</b>的关键在于能<b>看到图</b>。因为每次只能变一个字母，对词表里相差一个字母的情况，可以<b>建一条双向边</b>，这图就出来了。以图为根据，从起点开始执行<b>BFS</b>，到达终点为止。因为求的是<b>最短的</b>，每条边<b>权重都是1</b>，BFS正合适。奇怪的是，我当年代码写得巨长，还用了DFS，搞不懂。

<hr>

127 Word Ladder

题意：和126完全相同，这次只需要返回变换序列的长度。

难度：hard

解法：很奇怪为什么简化版的放在后面，更难的反而在前。同上。

<hr>

128 Longest Consecutive Sequence

题意：给定一个无序数组，求出其中的最长连续序列的长度。最长连续序列指的是在<b>排序之后</b>可以构成一个<b>公差为1的等差数列</b>。

难度：medium

解法：当然，你不能排序，要求在O(n)时间完成，因此这个挺有难度的。为了保证效率，我用了个区间延伸、合并的方法。用<b>两个哈希表</b>来记录区间的<b>首尾位置</b>，每增加一个元素，就检查<b>哪个区间可以延伸，哪两个区间可以合并</b>。这样全处理完后，找到最长的区间即可。思路不算很麻烦，但代码写得还挺麻烦。<b>确实有难度</b>。我想不出<b>更简洁或者更诡异</b>的方法了。很多人都说这题应该是hard，我同意。

<hr>

129 Sum Root to Leaf Numbers

题意：一个二叉树，每个节点有一个0-9的数字。从根到叶的路径可以代表一个<b>大数</b>。请求出所有<b>这些路径构成的数</b>的和。

难度：medium

解法：递归即可。

<hr>

130 Surrounded Regions

题意：给定一个m x n矩阵，每个格子是X或者O，和上下左右四个方向相邻。对于一个连同的O区域，如果周围全被X格包围，则该区域全部变成X。处在边界的O不算被包围。<b>就地进行</b>以上变换。

难度：medium

解法：<b>搜索</b>，不论深度还是广度都行。需要注意，搜完之后要判断<b>全包围</b>才能<b>统一处理</b>。还有一种做法，就是可以先把<b>和边界相邻的区域</b>设为另一值（以便保护起来），这样就不受包围操作的影响了。

<hr>

131 Palindrome Partitioning

题意：给定一个字符串，将其划分为多个子串，使得每个子串都是回文串。请返回所有划分方式。

难度：medium

解法：长度很短，可以暴力搜索。当然，提前把判断回文串的工作做好也行。

<hr>

132 Palindrome Partitioning II

题意：给定一个字符串，将其划分为多个子串，使得每个子串都是回文串。请返回<b>最少的划分次数</b>。

难度：hard

解法：比131难一点，不过也不算很难。很明显的DP思路，O(n^2)解决。

<hr>

133 Clone Graph

题意：给定一个<b>单连通</b>的无向图，请设计算法将其复制一份，并返回<b>和输入同一位置</b>的节点。

难度：medium

解法：这个其实更多是帮助初学者了解基础知识，比如<b>深拷贝浅拷贝</b>。当然，最标准的思路，要克隆一个东西，还是知道它的<b>序列化、反序列化</b>方式最靠得住。搞一些<b>奇奇怪怪的指针操作</b>，那就是纯属无事生非了。我记得我就是<b>用哈希做了一对一映射</b>，按部就班做的。

<hr>

134 Gas Station

题意：给定一个长度为n的<b>环形路</b>，每个加油站前往下一站会有一定的油耗cost[i]。假定你的油箱不限量，每个加油站有一定的油量gas[i]提供。如果你可以从任一站，以0油量出发（起步可以加油），要求<b>能走完一整圈</b>，请返回<b>选定的出发站</b>。

难度：medium

解法：处理<b>循环数组</b>有个通用的技巧，就是<b>把同一数组拼两份</b>，来个a + a，这样就<b>不怕下标越界</b>了。从任意点出发，你始终关心的是<b>当前油量是否变成负的</b>。是的话，<b>当前这段就可以放弃</b>，因为<b>你油不够</b>了。这个题和<b>最大子数组和</b>有点像，都是略有脑洞，但不过分的程度。

<hr>

135 Candy

题意：给定n个小朋友和一些糖果。每个小朋友有个<b>排位值ratings</b>。如果你至少每个小朋友要给1颗糖，且如果一个小朋友的<b>排位比相邻小朋友高</b>，糖的个数也<b>对应要更多</b>。请问最少需要准备多少糖，才能满足分配要求。

难度：hard

解法：确实挺难的，读完题目大概5分钟毫无想法的那种难度。再想5分钟，判断是不是可以<b>贪心</b>，结论是可以。按照全部1颗起步，遇到排位有高低的情况，就给高的+1。<b>从左到右，从右到左。</b>注意，+1不是加一颗，而是要<b>比旁边的多一颗</b>。

<hr>

136 Single Number

题意：给定一个数组，出了一个数之外，其他数都出现了两次。找出这个单独的数。

难度：easy

解法：好像是《编程珠玑》还是《编程之美》上的一个经典例子吧？<b>异或</b>是位运算里最神奇，最有魔性的一个。有很多坑货玩法，都可以借助异或实现。

<hr>

137 Single Number II

题意：136的变体题，这次其他数都出现了3次，而不是2次。找出这个单独的数。要求只使用O(1)空间

难度：medium

解法：有点<b>脑洞</b>了，这次不能用异或来抵消结果。用的是逐个二进制位统计1的个数。因为是出现3次，那个数肯定是3个倍数。因此，如果<b>余数是1</b>，就表示单独的数<b>在这一位是1</b>，否则这位是0。这样<b>一位位拼起来</b>就是最终结果。

<hr>

138 Copy List with Random Pointer

题意：给定一个链表，每个节点有一个random指针，指向了链表里另一个节点，位置没有规律。请设计算法复制这个链表，使得复制链表的random指针仍指向新表中的对应位置。挑战是<b>只使用O(1)额外空间</b>。

难度：medium

解法：这题是我见过的链表题里，<b>最诡异、最偏难怪、最奇技淫巧</b>的一题。直接通过哈希、数组或者随便什么<b>辅助结构</b>来完成的话，当然不难。难点在于不开辟额外结构，直接对next、random两个指针做出一些极难理解的操作。反正我无法描述清楚，到底发生了什么...你需要做一些p->random->next = xxx、p->next->random = xxx之类的魔法才能完成O(1)空间的解法。我觉得这题是<b>名副其实的hard</b>，也可以算tricky hard。

<hr>

139 Word Break

题意：给定一个长字符串s和一个词表。判断s是否可以被<b>划分成多个子串</b>，每个子串<b>都在词表中</b>。

难度：medium

解法：<b>正向思维</b>就是往后搜，<b>逆向思维</b>就是DP往前找。其实本质是一样的，只要效率够高就可以。

<hr>

140 Word Break II

题意：同139，但这次要求返回所有划分方式，结果中的<b>单词用空格连成句子</b>。

难度：hard

解法：这次就<b>必须搜</b>了，因为要求返回所有划分方式。

<hr>

141 Linked List Cycle

题意：给定一个单链表，判断是否存在环路。

难度：easy

解法：找有环链表的入口节点，这应该是《编程之美》上的例子了。不过这个只需要确定是否有环，不用找位置。有直白的<b>哈希表</b>解法，有<b>快慢指针跑圈</b>解法。快慢跑圈就是两个指针，快的走2步，慢的走1步，如果<b>能追上并且重新相遇</b>，就一定有环。

<hr>

142 Linked List Cycle II

题意：类似141，给定一个有环的链表，你需要找出环的入口节点。

难度：medium

解法：《编程之美》上的经典例子。还是哈希解法或者快慢指针解法。不过这次因为要找到入口节点，快慢指针会有一个很有意思的用法（也非常难想）。当两指针第一次相遇时，把其中一个<b>放回表头</b>，然后两个用<b>相同速度</b>前进。当两者再次相遇，就在入口处。<b>神奇吧？我反正第一次看到都懵了。</b>

<hr>

143 Reorder List

题意：给定一个链表，按照1、n、2、n-1、...的方式重新排列节点。不允许修改节点的值。

难度：medium

解法：照做即可。拆分，反转，拼装。注意边界case。

<hr>

144 Binary Tree Preorder Traversal

题意：二叉树前序遍历。

难度：easy

解法：递归，或者使用栈模拟递归都可以。

<hr>

145 Binary Tree Postorder Traversal

题意：二叉树后序遍历。

难度：easy

解法：递归，或者使用栈模拟递归都可以。

<hr>

146 LRU Cache

题意：就是LRU Cache，定义就不说了，操作系统课的内容。主要是说起来比较麻烦，懒得写。

难度：medium

解法：这题是<b>完美的面试题</b>。东西描述得清清楚楚，说难其实也不难，但就是<b>很麻烦</b>。你知道自己会做，但你要<b>耐心，仔细，还得写得快</b>。实现方式的话，就用<b>一个双向链表和一个哈希表</b>配合。这题在面试时<b>通常用来刷人</b>，犯一点错或者写的太慢，就挂了。这题其实是面试的hard，题目本身属于medium。<b>hard在于心理压力。</b>

<hr>

147 Insertion Sort List

题意：插入排序。按照插入排序的定义，对链表进行排序。

难度：medium

解法：也是<b>教科书内容</b>了，首先你得知道<b>插入排序</b>的具体做法。因为插入排序是顺序寻找位置的（没用二分查找，也就没有<b>随机访问</b>），所以同样的方法也可以在链表上实现。照做即可，注意边界case。

<hr>

148 Sort List

题意：给定单链表，进行元素排序。

难度：medium

解法：教科书。排序是算法课的最基础且重要的内容之一，<b>必知必会</b>。可以用归并排序的思路做，都是顺序访问。如果用<b>快速排序</b>，你的划分元素就只能用<b>表头</b>了。当然，也不是不能做，但比较费劲而且不好理解。<b>对链表来说，还是归并排序最直接。</b>

<hr>

149 Max Points on a Line

题意：给定一些<b>整数点</b>，请问一条直线最多可以穿过多少点。

难度：hard

解法：其实不算难，平方复杂度能解决就行。对于每个点，考虑其他点连线的<b>斜率</b>，同斜率就等于共线了。但如果直接这么做，就错了。因为<b>浮点数计算</b>会有<b>精度问题</b>。另外，别忘了有<b>重合点</b>的情况。应该用<b>x/y这种分数来表示斜率</b>，也包括0/1和1/0两种特殊情况。分数，记得<b>约分</b>。

<hr>

150 Evaluate Reverse Polish Notation

题意：给定一个算数表达式的<b>逆波兰表达式</b>写法，计算它的结果。

难度：medium

解法：属实是专业术语了，这是形式语言的一部分。<b>逆波兰表达式</b>是<b>语法树</b>的<b>后序遍历</b>。语法树是什么呢？不展开了，都在编译原理的基础课里。比如`1+2*3`，对应的后序就是`['1', '2', '3', '*', '+']`。思路就是<b>栈</b>。递归是栈操作，所以你要模拟递归，就用栈做一遍。

<hr>

151 Reverse Words in a String

题意：给定一个句子，单词间用空格连接。请反转单词顺序，但不要反转单词里的字母。

难度：medium

解法：水题。题目还提到了，如果字符串结构是<b>可变</b>的（很多语言的字符串是<b>不可变类型</b>），有没有什么更高效的O(1)空间做法。

<hr>

152 Maximum Product Subarray

题意：给定一个整数数组，可能有正负数和0，求累乘最大的子数组，返回乘积。

难度：medium

解法：这题很有意思，也有点难。如果只有正数的话，可以直接取对数，<b>把乘积化为求和</b>。如果有正数和0的话，可以<b>把0作为分界线</b>，因为跨过分界线乘积一定是0。但还有负数，问题就复杂了，因为负负得正。也可能整个数组都是负数。我的思路是既要求<b>最大值</b>，也要求<b>最小值</b>，因为<b>最小值再乘一个负数</b>，可能就<b>变最大</b>了。讲了很多，其实代码挺简短的。并没有取对数，没必要。

<hr>

153 Find Minimum in Rotated Sorted Array

题意：给定一个<b>可能经过</b>循环移位的有序数组，找出最小值。

难度：medium

解法：二分，肯定二分。

<hr>

154 Find Minimum in Rotated Sorted Array II

题意：同153，但数组可能包含重复。

难度：hard

解法：给升级到hard其实夸张了，并没有变难。对于重复元素，也只能采取下标+1的办法。这个思路之前已经遇到过了，因此最坏时间是O(n)，最好依然是O(logn)。

<hr>

155 Min Stack

题意：设计一个最小栈，既可以像普通栈一样<b>出栈入栈</b>，也可以随时返回当前栈内最小元素。

难度：medium

解法：额外用一个<b>单调栈</b>，始终只放入<b>不大于栈顶</b>的元素。这样得到的单调栈是<b>递减</b>的。在出栈时，如果当前<b>栈顶元素</b>也等于<b>单调栈的栈顶</b>，则单调栈也出一个。后面还会有几个类似的题，在<b>栈、队列</b>之间玩一些<b>左右互搏的魔法</b>。

<hr>

156 Binary Tree Upside Down

题意：给定一个特殊的二叉树，所有非叶节点<b>都有左右子树</b>。请执行上下反转操作，<b>使得右邻居节点变为左子树，父节点变为右子树。</b>

难度：medium

解法：付费题。LeetCode的<b>第一道付费题</b>，我现在已经打不开题目页面了。这个反转方式比较诡异，读一遍题都看不懂。解法<b>并不需要递归</b>，在草稿纸上画一下形状，用循环可以搞定。因为题目要求比较奇怪，解法自然也奇怪。

<hr>

157 Read N Characters Given Read4

题意：如果你有一个read4函数，每次可以读4个字符，请设法实现一个read函数，读任意长度字符。

难度：medium

解法：付费题。这个需求倒是不奇怪，很多通讯方式就是定长的，需要各种特殊处理。这题考点就是<b>处理剩余的字符，不要丢失数据</b>。

<hr>

158 Read N Characters Given Read4 II - Call multiple times

题意：157的变体，这次你实现的读取n个字符的read函数<b>可能被调用多次</b>。

难度：hard

解法：付费题。多次调用，那就有<b>更多的边界case</b>要处理。

<hr>

159 Longest Substring with At Most Two Distinct Characters

题意：给定字符串s，求出其中最多包含<b>两种不同字符</b>的最长子串。返回长度。

难度：medium

解法：付费题。和后面还会遇到n次的各种类似题目一样，<b>滑动窗口+计数</b>。

<hr>

160 Intersection of Two Linked Lists

题意：给定两个单链表，可能在某一点交汇。请找出交汇点。

难度：easy

解法：这题也是链表脑洞合集之一。如果先统计长度，然后对齐位置找汇合点，就没什么脑洞。我记得好像有个奇奇怪怪的解法，涉及到反转链表。但考虑到<b>先求长度再对齐位置</b>的方法已经是O(1)空间了，没必要节外生枝。

<hr>

161 One Edit Distance

题意：给定两个字符串s和t，判断它们的编辑距离是否为1。

难度：medium

解法：付费题。之前已经讲过编辑距离的定义了，增、删、改一个字符，算一次编辑。第一念头是DP，但想了下发现不需要。直接<b>双指针</b>对应位置匹配，如果不匹配，则需要1次编辑。如果编辑次数大于1，就可以返回了。你并不是在找<b>最短编辑距离</b>。

<hr>

162 Find Peak Element

题意：给定一个数组，所有相邻元素都不想等。峰值元素的定义是，比左右邻居都大。边界处可以视为负无穷，也满足定义。请找出任一峰值的下标。要求在O(logn)时间完成。

难度：medium

解法：线性解法是显然的，不讨论。对数当然要依靠<b>二分</b>。二分的思路，就是如果处在上坡`a<b<c`，就应该<b>向右</b>；如果处在下坡`a>b>c`，就应该<b>向左</b>。这样逐渐缩小范围，总能夹出一个峰值。

<hr>

163 Missing Ranges

题意：给定一个有序数组，以及<b>闭区间</b>的上下界lower和upper。请返回所有<b>不在数组中的值</b>构成的<b>区间列表</b>。

难度：medium

解法：付费题。倒是没什么特别，一个个地添加、合并区间，然后<b>用总区间减一下</b>。或者也可以从`[lower, upper]`开始，一个个去掉数组中的元素。总之思路很简单，<b>实现起来麻烦</b>，而且<b>边界case很多</b>。

<hr>

164 Maximum Gap

题意：给定无序数组，请返回排序后，<b>相邻元素</b>的最大差值。但是<b>不允许排序</b>，需要在O(n)时间空间完成。

难度：medium

解法：多年之后，我重新花了10分钟想，没想出来。看了当年的代码，原来是<b>桶排序</b>。没错，当年想不出来，现在还是想不出来。这种<b>神谕时刻</b>，不是后天训练能学会的。统计<b>最大最小值</b>，和<b>不同值的个数</b>，对所有元素进行<b>区间分桶</b>。那么，关键来了，最大的相邻差值，一定来自`某桶的最小值 - 之前某桶的最大值`，且这两个元素之间没有任何元素了，否则它们就不相邻了。事后你再看，整个设计其实非常清晰、系统化，但不得不说脑洞就是很大。<b>“这是人想得出来的？”</b>。这可以算是super tricky hard了，设为medium难度不合理。最后，其实<b>桶排序不能算线性</b>，所有这个脑洞并不是100%讲道理，有点耍赖了。鉴定为<b>纯纯的坑货</b>。

<hr>

165 Compare Version Numbers

题意：给定两个类似1.1、1.2.34格式的版本号，比较其大小。版本号内数字<b>按整数处理</b>，无视多余的前置“0”。

难度：medium

解法：其实就是字典序，注意细节即可。

<hr>

166 Fraction to Recurring Decimal

题意：给定一个分数的分子分母，请用字符串表示它的<b>小数形式</b>。对于循环小数，要标记出<b>循环节</b>。

难度：medium

解法：小学数学，<b>分数和循环小数</b>的定义，这个挺有意思的。不断<b>做除法</b>，用一个数组（或者哈希表）来标记余数。如果一个余数<b>被第二次访问到</b>，就说明循环了。这个计算过程中记录的商，就是循环节。要注意开头可能<b>有不循环的部分</b>，不要漏掉。如果余数为0，则除尽了，结果是<b>有限小数</b>。总之是一道有点难度，要小心处理的题。

<hr>

167 Two Sum II - Input Array Is Sorted

题意：给定有序数组，找出两个元素，使得和等于target。返回下标。

难度：medium

解法：因为有序，可以直接用<b>双指针</b>向中间靠拢了。

<hr>

168 Excel Sheet Column Title

题意：给定列数，返回Excel中对应的列名称。

难度：easy

解法：Excel确实是这么定的。做一下特殊的进制转换，26进制。

<hr>

169 Majority Element

题意：给定一个数组，有一个值在其中出现超过了一半，找出这个值。

难度：easy

解法：这个称为<b>“众数”</b>，也是《编程之类》里的例子。如果不用哈希表统计个数，那就只留一个counter变量。是它，就+1；不是它，就-1。<b>计数减到负数了，就换掉。</b>因为数量超过了一半，怎么减最终也会大于0。因此留下的那个值肯定是众数。

<hr>

170 Two Sum III - Data structure design

题意：还是two sum，但这次要设计一个可以<b>不断添加元素</b>，可以<b>随时查找</b>two sum的数据结构。

难度：easy

解法：付费题。所幸只用判断<b>是否存在</b>，用一个哈希表统计已有元素，就可以随时查了。查找的方式就是遍历x，看`target - x`是否存在。注意处理`target = x + x`的情况。还有一种解法不如这个直白，效率上也不算优秀，不讨论了。

<hr>

171 Excel Sheet Column Number

题意：和168一样，但这次反过来了。给定Excel列名称，转换成列数。

难度：easy

解法：26进制，转换方式反过来即可。

<hr>

172 Factorial Trailing Zeroes

题意：给定自然数n，求n!末尾有多少个0。

难度：medium

解法：《编程之美》的经典题目之一。很巧妙，可以<b>一步步想出来</b>。多少个0，就代表<b>10的多少次方</b>。10的多少次方就是<b>2*5</b>的多少次方。阶乘嘛，<b>5的个数肯定比2少</b>，那就是多少个5。n!有多少个5？5是1个5，25是两个5，125是3个5。想出来了吗？

<hr>

173 Binary Search Tree Iterator

题意：给定一个二叉树，设计一个迭代器，用于<b>逐个访问</b>这个二叉树的<b>中序遍历</b>结果。每调用一次next()函数，得到中序遍历的下一个值。

难度：medium

解法：<b>栈</b>，用栈来模拟递归。

<hr>

174 Dungeon Game

题意：m x n的地下城，勇士从(0,0)出发，要去营救位于(m-1,n-1)的公主。每次允许<b>向右或者向下</b>移动一格。如果格子为正，表示<b>加血的瓶子</b>；如果格子为负，表示<b>打怪损失的血量</b>。请问勇士<b>最少需要多少血量出发</b>，才能成功救出公主。在任意位置，<b>至少血量为1</b>才能生存。

难度：hard

解法：要是允许上下左右走，那就复杂了。只能向右向下的话，可以<b>DP</b>解决。可以考虑<b>倒推</b>，从公主的位置，往左上走。

<hr>

179 Largest Number

题意：给定一系列非负整数，允许你用<b>任意顺序将其拼接起来</b>组成一个大数，请返回最大的结果。

难度：medium

解法：这题有个妙处，你想得很复杂，那就会越想越复杂。其实只做个排序就可以了。关键是，<b>排序的依据</b>。如果`a+b>b+a`，那就a在前，b在后。

<hr>

186 Reverse Words in a String II

题意：给定一个句子，只反转每个单词的字母，而不反转单词顺序。

难度：medium

解法：付费题。水题，和之前151的要求相反。

<hr>

187 Repeated DNA Sequences

题意：给定一个ATCG构成的DNA序列，请找出所有<b>长度为10</b>，且出现至少2次的子串。

难度：medium

解法：生物课知识就不讲了，DNA是ATCG，RNA是AUCG。如果直接暴力匹配或者统计的话，可以把各种子串都<b>哈希一下</b>，效率当然不高。因为字符只有4种，长度为10，给位运算提供了方便。所以改为用一个<b>20位二进制</b>来表示<b>10长度的DNA序列</b>，剩下的就是统计了。

<hr>

188 Best Time to Buy and Sell Stock IV

题意：同123，但这次你<b>至多可以做k次买卖</b>。求最大盈利。

难度：hard

解法：做两次买卖的时候，其实已经可以用<b>DP</b>思路解决了。延伸到k次，没有区别。考虑k-1次买卖的情况，递推即可。注意，是<b>至多</b>。

<hr>

189 Rotate Array

题意：给定数组和k，把数组循环右移k次。

难度：medium

解法：左反，右反，全反。

<hr>

190 Reverse Bits

题意：给定一个整数，把它的<b>二进制表示</b>反转一下。

难度：easy

解法：和数位反转一样，二进制十进制都一样。就是<b>模10乘10</b>和<b>模2乘2</b>的区别。

<hr>

191 Number of 1 Bits

题意：给定一个整数，求二进制表示里1的个数。

难度：easy

解法：经典位操作。`b=x&-x`提取一位，`x&=x-1`去除一位。

<hr>

198 House Robber

题意：给定n个房子依次排列。你是小偷，规定不能在相邻的房子偷东西。请问最多能偷到多少钱？

难度：medium

解法：比较直白的线性DP，保留<b>倒1和倒2</b>的状态，不断<b>滚动更新</b>即可。

<hr>

199 Binary Tree Right Side View

题意：给定一个二叉树，如果从<b>最右侧</b>看树，请返回能看到的节点值的列表。按<b>从上到下顺序</b>返回。

难度：medium

解法：其实方法倒是很多，目的都是遍历找到<b>最右边的节点</b>。可以按<b>先右后左</b>的方式进行<b>前序遍历</b>。也可以直接<b>层序遍历</b>。

<hr>

200 Number of Islands

题意：给定一个01矩阵表示的地形图。1表示陆地，0表示水。陆地按照上下左右相邻。请返回<b>连成一片的岛屿</b>的个数。

难度：medium

解法：搜，深度广度都可以。课本里管这个叫<b>“flood fill”</b>，洪泛算法。画图的<b>填色功能</b>，就是这么做的。
