# LeetCode 一句话题解 - 0001-0500

[返回目录](./algorithms-review-overview.md)

- [LeetCode 一句话题解 - 0001-0500](#leetcode-一句话题解---0001-0500)
  - [0001 - 0100](#0001---0100)
  - [0101 - 0200](#0101---0200)
  - [0201 - 0300](#0201---0300)

代码库地址：  
[https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/0001-0500](https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/0001-0500)

## 0001 - 0100

1 Two Sum

题意：给定一个无序数组和一个值target，返回下标[i, j]使得a[i] + a[j]等于target。

难度：easy

解法：使用哈希表，记录已访问到的值x和下标i，比较当前值是否等于剩余部分target - x。

<hr>

2 Add Two Numbers

题意：使用链表表示两个十进制大数，做加法。

难度：medium

解法：第一道链表题，注意边界case，比如进位问题即可。

<hr>

3 Longest Substring Without Repeating Characters

题意：给定一个字符串，求出最长的不带重复字符的子串长度。

难度：medium

解法：第一道滑动窗口题，后面会有无穷多的类似<b>滑动窗口、子串、子数组类型</b>的问题。使用前后两个指针向前走，中间夹住部分即为滑动窗口。同时使用一个计数器（哈希表）来统计个数，确保条件成立（或者刚好不成立）。

<hr>

4 Median of Two Sorted Arrays

题意：给定两个升序数组，求出两者归并后的中位数。

难度：hard

解法：第一道经典的费脑子题，你就很难理解有的人为什么可以瞬间想到。线性解法是显然的，难点在于如何在<b>不归并</b>的情况下，使用二分方法求出中位数。第一次做我想了一个多钟头也没想清楚。

<hr>

5 Longest Palindromic Substring

题意：给定字符串，返回最长回文子串，需要返回子串。

难度：medium

解法：O(n^2)解法显然，难点在于巧妙且经典的<b>Manacher算法</b>。对于没接触过的人，凭自己琢磨出同样算法几乎不可能，实在太精妙了。

<hr>

6 Zigzag Conversion

题意：把字符串按奇怪的方式排列一下，按部就班的模拟题。

难度：medium

解法：照做即可。

<hr>

7 Reverse Integer

题意：给定一个整数，把除了符号位以外的数位倒过来。

难度：medium

解法：不用字符串，直接用除10模10的办法即可。

<hr>

8 String to Integer (atoi)

题意：实现atoi，字符串转整数的功能。

难度：medium

解法：非常非常经典的，适合用来面试的题目。不难，但考察你耐心、仔细的程度，是很好的工程师考题。

<hr>

9 Palindrome Number

题意：判断一个数是否是回文数。

难度：easy

解法：水题，负数都不是回文数。

<hr>

10 Regular Expression Matching

题意：实现正则表达式中的单字符以及.和*匹配。

难度：hard

解法：第一道parser题，编译原理是计算机科学里极其优雅且复杂，但也非常有用的一门课。写各种解析器就是一种打地基式的劳动，值得练习。正则表达式既简短又博大精深，这个是非常简化的版本。

<hr>

11 Container With Most Water

题意：给定一些高高低低的挡板从左到右排列，相邻宽度都是1。允许你选其中两个挡板，连同地板组成一个容器。请问最多能存多少水？

难度：medium

解法：这个不是著名的接雨水，是一道比较简单的题。<b>双指针</b>逐渐往中间靠拢，一边靠拢一边不断更新能存水的最大值即可。

<hr>

12 Integer to Roman

题意：古老的罗马数字，IVXLCDM。做一下数字转换，把阿拉伯翻译成罗马。

难度：medium

解法：按部就班。

<hr>

13 Roman to Integer

题意：罗马数字转阿拉伯，和前面类似。

难度：easy

解法：按部就班。

<hr>

14 Longest Common Prefix

题意：给定一组字符串，找出最长的公共前缀。

难度：easy

解法：不要考虑<b>字典树</b>之类的复杂结构，直接保留当前最长前缀，逐个比较并更新即可。

<hr>

15 3Sum

题意：给定无序数组和目标值0，返回所有<b>元素和</b>加起来等于0的三元组的下标(i, j, k)。注意不要有重复结果。

难度：medium

解法：第一道<b>变体题</b>，这也是算法题的妙处之一。以同一类问题进行<b>延伸</b>，考察人对事物的理解，以及灵活变通的能力。2Sum有好多变体，包括3sum，4sum等等。3sum可以枚举第一维，对后两维使用2sum做法。

<hr>

16 3Sum Closest

题意：类似3sum，但要求返回一个三元组(i, j, k)使得元素和<b>最接近</b>目标值target。

难度：medium

解法：3sum的变体，和之前方法完全一样，只是更新答案的比较条件有所变化而已。从判断相等改为了<b>判断更为接近</b>。

<hr>

17 Letter Combinations of a Phone Number

题意：给定老式的手机9键键盘，把一串数字翻译成所有可能的字母映射。

难度：medium

解法：按部就班，直接搜即可。

<hr>

18 4Sum

题意：2sum的变体，这次是4个元素相加等于target，要求返回所有可能的组合。

难度：medium

解法：其实还是类似，枚举的维度多了一维，剩余的维度还是按2sum做法搞定。比如你可以左右各一维进行枚举，中间两维进行2sum。方法很多，灵活掌握。

<hr>

19 Remove Nth Node From End of List

题意：给定单链表，删除倒数第n个节点并返回表头。

难度：medium

解法：传统链表题，主要考察仔细一遍过的能力，注意边界case。

<hr>

20 Valid Parentheses

题意：给定括号序列，可能包括大中小括号的混合，判断是否是一个开闭匹配的合法序列。

难度：easy

解法：入栈出栈即可。

<hr>

21 Merge Two Sorted Lists

题意：给定两个有序链表，合并为一个，返回表头。

难度：easy

解法：水题。

<hr>

22 Generate Parentheses

题意：给定长度n，请生成所有不同的，长度为n的，合法的小括号序列。

难度：medium

解法：结果个数是卡塔兰数，至于生成，用记忆化搜索+递归的方法可以完成，且效率可接受。

<hr>

23 Merge k Sorted Lists

题意：给定k个有序链表，合并为一个有序链表，返回表头。

难度：hard

解法：虽然标记为hard，其实思路并不难。保证每次取最小元素的效率即可，因此使用<b>最小堆</b>，不断把k个表头往里放并总是取出当前值<b>最小的表头</b>。

<hr>

24 Swap Nodes in Pairs

题意：给定链表，按每两个元素一对，进行交换。返回表头。

难度：medium

解法：按部就班，注意边界case即可。

<hr>

25 Reverse Nodes in k-Group

题意：和上面的交换两个节点类似，这次是每k个节点一组进行反转。返回表头。

难度：hard

解法：按部就班，多多注意边界case。

<hr>

26 Remove Duplicates from Sorted Array

题意：给定有序数组，<b>去重</b>并把剩余的元素依次往前放，返回剩余元素个数。

难度：easy

解法：解法比讲清楚题意还简单的一道题。

<hr>

27 Remove Element

题意：给定数组，去掉其中所有值为val的元素，并把剩余元素依次往前放，返回剩余元素个数。

难度：easy

解法：水题。

<hr>

28 Find the Index of the First Occurrence in a String

题意：实现strstr，即字符串匹配的功能。

难度：easy

解法：<b>字符串匹配</b>是最最最经典的问题之一，有Sunday、BM、KMP还有多模式匹配的AC自动机等神奇算法。这个题要求比较低，所以暴力匹配也能接受。

<hr>

29 Divide Two Integers

题意：给定两个整数，返回整除结果，但不能用 * / %运算。

难度：medium

解法：很有意思的一题，<b>绑手绑脚还要秀功夫</b>的类型。我专门看了一眼自己当年的代码，一分钟还没理解到底在干嘛。又看了一遍，发现是用类似<b>位运算和除法器</b>（学过数字电路的话肯定就懂了）的思路去做除法。

<hr>

30 Substring with Concatenation of All Words

题意：给定一个长字符串s，和一组<b>长度相同</b>的单词words。找出所有s的子串，使得这些子串恰好等于words中的<b>全部单词</b>以<b>任意顺序</b>拼接起来。返回这些子串的<b>起始下标</b>。

难度：hard

解法：确实比较hard，放下现在算是medium hard。从数据规模，不允许暴力搜索。考虑用滑动窗口+统计出现字符串出现次数的方法。当年用cpp写，还设计了个非常蹩脚的字符串哈希函数，导致代码读起来很费劲。如果用py重写，两个Counter对象就搞定了。我看了大概五分钟才看明白当年的代码想表达什么。

<hr>

31 Next Permutation

题意：给定一个<b>无序且可能有重复元素</b>的数组，返回按<b>字典序</b>的下一个排列。要求就地完成，不复制数组。

难度：medium

解法：总归是个O(n)时间的操作，因为挪动数组元素是线性时间的。

<hr>

32 Longest Valid Parentheses

题意：给定一个小括号序列，返回其中能找到的最长合法序列的长度。

难度：hard

解法：难度是hard，规模上不允许O(n^2)的直白解法。既然是<b>括号匹配</b>，必然想到用栈。但一个栈可以作为数组用，却无法给你快速查找某个值的功能。因此换了一个比较巧的做法，用一个<b>计数</b>表示栈大小，同时用一个<b>哈希表</b>来存放内容，这样就能快速查找并更新内容了。所以这也<b>不能算是个栈</b>，但思路还是用了栈。

<hr>

33 Search in Rotated Sorted Array

题意：一个有序数组经过了（也可能没有）循环移位，请找出target值所在的下标。

难度：medium

解法：和那个“两个有序数组求中位数”一样，属于经典的<b>脑洞题</b>。直白解法很直白，但最高效解法你可能就是想不出来，这种类型的坑货题在LeetCode上还有十几题，散落在各处。二分做法反正我第一次费了很大劲才想出来，<b>自愧不如</b>。我也很难用一句话描述清楚怎么<b>独立想出来这种鬼点子</b>，因为我<b>做不到</b>。

<hr>

34 Find First and Last Position of Element in Sorted Array

题意：给定有序但可能有重复元素的数组，找出某个值target的起始和终止位置。

难度：medium

解法：二分查找，其实就是bisect_left和bisect_right的定义。

<hr>

35 Search Insert Position

题意：给定有序数组，要插入一个新值，请找出应该插入的位置。

难度：easy

解法：二分查找。

<hr>

36 Valid Sudoku

题意：三阶数独，9x9的那种。这次只需要检查一个填法是否合法而已。

难度：medium

解法：按数独的规则记录和检查即可。每行1-9，每列1-9，每个3x3小方格1-9。

<hr>

37 Sudoku Solver

题意：三阶数独，9x9的那种。这次要你用算法来填了。

难度：hard

解法：倒是算个hard，不过按部就班地使用<b>搜索+回溯</b>的方法，其实也不算难。如果一定要求用神奇的<b>Dancing Links算法</b>去做，我还是放弃吧。其实这辈子估计也没打算学会这个算法。

<hr>

38 Count and Say

题意：给定初始字符串“1”，使用游程编码（RLE）的方式不断把这个字符串“读出来”，并用读的结果替换原字符串。如此重复n-1次，返回最终结果。

难度：medium

解法：按部就班，模拟题。

<hr>

39 Combination Sum

题意：给定一个无重复元素的候选集合，找出所有加起来和为target的不同组合，返回全部组合。

难度：medium

解法：非常经典的<b>搜索题</b>，注意设计好递归函数，处理边界case即可。第一次写这种递归代码容易晕，写多了就能找出比较简洁的方式。注意适当<b>剪枝</b>，提高效率。

<hr>

40 Combination Sum II

题意：组合求和的变体，候选集合是可以有重复元素的。

难度：medium

解法：思路完全一样，就是改用一个map计数器来代替set，因为可以有重复值，需要统计每个值当前用了多少次。

<hr>

41 First Missing Positive

题意：给定一个长度为n的无序数组，请找出<b>不在数组中的</b>最小的<b>正整数</b>。要求不能用额外数组或存储结构做记录。

难度：hard

解法：这好像是一道近乎脑筋急转弯的<b>小聪明式的算法题</b>，要求做一件很直白的事，但不能用额外空间。个人非常反感这类<b>“专考聪明人”</b>的题。你得不到任何训练，且每一个这种题都<b>独一无二</b>，没什么规律可言。这题想要省空间，其实就是<b>直接把原数组当成一个bool数组用</b>，在上面叠一层True or False标记，来记录1-n是否都出现过了。如果你做不出来或者想不到，<b>不用有任何失望</b>。这不代表你不聪明，只代表你此时此刻在这道题上不聪明，和过去、和未来毫无关系。

<hr>

42 Trapping Rain Water

题意：给定一个高高低低的一维地形，雨水可以存在各种地势低洼处，给定无穷多的雨量，问总共能存下多少水。

难度：hard

解法：<b>接雨水</b>，这个是LeetCode名梗之一了，二维接雨水也被视为算法题里嘲讽功能最强的题目之一。这种题目虽然很精妙，但也因为其费脑、解法五花八门且实在没什么鸟用，而被视为浪费脑细胞的最佳途径。一维接雨水其实还好，可以视为传统的O(n) DP题。这个hard当年确实费了很多人的脑细胞，而且也很经典。<b>二维接雨水</b>还要离谱的多。

<hr>

43 Multiply Strings

题意：大数乘法，但是用字符串表示的大数。

难度：medium

解法：按部就班，不过对数据格式做一下转换，注意别出错即可。

<hr>

44 Wildcard Matching

题意：通配符匹配，和正则匹配类似，但要求实现?和*匹配功能。

难度：hard

解法：<b>比正则匹配简单</b>，但也算名副其实的hard问题。难度主要在把事情想清楚，代码其实很短。

<hr>

45 Jump Game II

题意：给定一个长度为n的数组nums，你从0位置出发，每次从i位置最多可以往前跳nums[i]步，问最远能到哪儿。

难度：medium

解法：跳数组系列问题中比较简单的一题，这系列有好多个变体。只要<b>每前进一步</b>，不断更新<b>当前能跳到的最远位置</b>即可。

<hr>

46 Permutations

题意：给定无重复元素的数组，返回它的所有不同排列方式。

难度：medium

解法：最直接的思路其实是先排序，然后不断使用<b>next permutation</b>找到下一个排列，直到<b>找不到（也就是变成倒序了）为止</b>。另一种思路就是搜索+记录排列的方式。前者更直观，代码也更好写。

<hr>

47 Permutations II

题意：和上题一样，返回所有排列，但这次数组可能有重复元素。

难度：medium

解法：我还是选择next permutation，这个无所谓重复元素。

<hr>

48 Rotate Image

题意：给定一个n x n矩阵，顺时针旋转90度。

难度：medium

解法：按部就班，注意奇偶情况的处理。

<hr>

49 Group Anagrams

题意：给定一组字符串，把互为anagram的词归到一个组里。

难度：medium

解法：<b>anagram</b>没有中文叫法，只能叫“同字母异序词”。对anagram的处理就是<b>排序之后统一比较</b>，相等就是anagram。

<hr>

50 Pow(x, n)

题意：给定整数x和n，都可以是负数，求x的n次方。

难度：medium

解法：快速幂，二分法。

<hr>

51 N-Queens

题意：N皇后问题，在n x n棋盘上放置n个皇后，不能存在同行、同列、同对角线、同反对角线的情况。返回所有摆法。

难度：hard

解法：这是算法和数据结构课的教科书例子了，可以说是<b>搜索+回溯</b>的教材。

<hr>

52 N-Queens II

题意：N皇后问题，并不能算变体。这次只需要返回解的个数。

难度：hard

解法：搜索+回溯。

<hr>

53 Maximum Subarray

题意：给定数组，求出其中最大的子数组和，返回和。

难度：medium

解法：<b>贪心策略</b>的最经典例子之一。累加并更新最大值，如果累加和为负数，就直接放弃，重置为0。

<hr>

54 Spiral Matrix

题意：给定m x n的矩阵，按照顺时针螺旋方式从外向内遍历。

难度：medium

解法：模拟题，逐字逐句照做即可。

<hr>

55 Jump Game

题意：给定一个长度为n的数组nums，你从0位置出发，每次从i位置最多可以往前跳nums[i]步，问能不能跳到最后一格。

难度：medium

解法：思路和Jump Game II完全一样，为什么这个的题号反而在后面？

<hr>

56 Merge Intervals

题意：给定一些用[x, y]表示的区间，将其进行合并，使得结果中的区间互不重叠。

难度：medium

解法：按<b>先首后尾</b>的顺序进行<b>排序</b>，然后逐个进行合并处理。python的<b>元组默认顺序</b>是个很有用的特性，可以处理很多这类问题。

<hr>

57 Insert Interval

题意：给定一组有序且互不重叠的区间，插入一个新区间[x, y]并进行适当的合并，使得结果依然有序且互不重叠。

难度：medium

解法：和上面的合并区间同一思路，二分找到插入位置，然后逐个合并，直到无需合并为止。

<hr>

58 Length of Last Word

题意：给定一个句子，找出最后一个词的长度。

难度：easy

解法：水题。

<hr>

59 Spiral Matrix II

题意：给定n x n的方阵，按照顺时针由外向内的方式，螺旋遍历这个矩阵，并把1到n^2依次填入每个每个位置。返回结果方阵。

难度：medium

解法：和前面的螺旋遍历一样，模拟题照做即可。

<hr>

60 Permutation Sequence

题意：给定整数n，{1, 2, ..., n}可以组成n!个不同排列。给定整数k，请求出<b>字典序排第k</b>的排列。

难度：hard

解法：<b>组合数学题</b>。可以按<b>子问题</b>逐个考虑。当第1位固定，剩下的n-1位则有(n-1)!种不同排列。逐个往下减，最后一位减完了，整个排列就确定了。

<hr>

61 Rotate List

题意：对一个单链表进行循环右移k次，返回表头。

难度：medium

解法：对k的一些特殊情况处理一下，剩下小心完成即可。可以通过<b>反转数组</b>的方式实现<b>循环移位</b>。[a...a b...b]，先反a，再反b，最后反全部，结果就等效于循环移位。

<hr>

62 Unique Paths

题意：给点m x n矩阵，你从(0, 0)出发，每次只允许向右或者向下，请问到达(m - 1, n - 1)有多少种方法。

难度：medium

解法：其实是个<b>纯数学题</b>，可以用<b>组合公式</b>直接求。但依然可以用土办法，开个二维数组进行累加。组合公式多数人不一定记得住，或者现场推也推不清楚，不必强求。这个应该就是著名的<b>杨辉三角</b>了，二项式定理。

<hr>

63 Unique Paths II

题意：Unique Paths的变体，但这次矩阵中存在无法通过的障碍格子。求到达(m - 1, n - 1)的路径个数。

难度：medium

解法：这次不能套数学公式了，还是用之前相同的办法，<b>二维数组</b>统计个数。

<hr>

64 Minimum Path Sum

题意：给定一个m x n矩阵，每个格子有一个值。从(0, 0)出发，每步只允许向右或向下，到达(m - 1, n - 1)。求可能累加得到的最小路径和。

难度：medium

解法：非常典型且直白的DP题。既然只能<b>右和下</b>，那就在<b>左和上</b>里找一个较小的值即可，这样最后得到的就是最小的路径和。

<hr>

65 Valid Number

题意：给定字符串，判断是否是一个有效的整数、小数或者科学计数法表示的数。

难度：hard

解法：难度全在于是否<b>够仔细，够严谨，够耐心</b>。能一次过这种题的，反正我挺难想象的。<b>边界case</b>多的出奇。

<hr>

66 Plus One

题意：给定用数组表示的一个大数，对其执行+1操作。

难度：easy

解法：没有难度，就是注意进位的情况。

<hr>

67 Add Binary

题意：两个字符串表示的大数相加，二进制。

难度：easy

解法：十进制，二进制，没什么大区别。

<hr>

68 Text Justification

题意：给定一系列单词，要求在<b>保持单词顺序</b>的情况下，按照一个最大宽度进行逐行排版。最终得到的<b>每行总宽度相同</b>，且每行内的单词间空格要尽可能均匀。这个其实就是我们常见的<b>“分散对齐”</b>功能。

难度：hard

解法：难度主要在于要求比较多，费事，实现每一步倒是不难。小心完成即可。

<hr>

69 Sqrt(x)

题意：给定非负整数，求它的平方根，结果<b>向下取整</b>。

难度：easy

解法：二分查找。

<hr>

70 Climbing Stairs

题意：从0级台阶开始，每次允许向上1级或者2级，求到达第n级台阶的方法有多少种。

难度：easy

解法：Fibonacci数列。

<hr>

71 Simplify Path

题意：给定一个“/”分割的文件路径，可能存在“.”和“..”这样的相对路径。求简化后的<b>绝对路径</b>。

难度：medium

解法：解析路径，用栈处理一下，然后拼回完整路径即可。

<hr>

72 Edit Distance

题意：给定两个字符串s和t，求其最短编辑距离。一次编辑包括<b>增、删或改一个字符</b>。

难度：medium

解法：教科书里讲<b>动态规划</b>的经典例子，DP。编辑距离还有个专有名词，叫“Levenshtein distance”。

<hr>

73 Set Matrix Zeroes

题意：给定一个01矩阵，如果某个元素值为0，就把它对应的整行和整列都设为0。要求对所有元素同时做这个操作，且<b>就地完成</b>，不使用额外的矩阵。

难度：medium

解法：挺巧妙的一题，难度当然是<b>就地完成</b>了，否则直接记录一下再处理就很简单。使用第0行和第0列作为标记，再单独用两个变量r0和c0记录0行和0列本身是否有0，这样就<b>有地方做记录</b>了。起码没要求我<b>一个变量也不能用</b>，对吧？

<hr>

74 Search a 2D Matrix

题意：给定一个m x n矩阵，每行向右都是递增的，且下一行的第一个元素都大于上一行末尾。请设计一个高效算法在其中查找目标值是否存在。

难度：medium

解法：注意，这个并不是<b>Young tableau</b>，只是一个有序的一维数组被变形成了二维。把它还原成一维，进行常规的二分查找即可。

<hr>

75 Sort Colors

题意：给定一个包含红白蓝三色的数组，要求<b>就地进行排序</b>，得到红、白、蓝顺序的结果。

难度：medium

解法：既然只有三种颜色，那就把红、蓝<b>往两边放</b>好了，以<b>交换</b>的方式实现。我记得很清楚，当时很讨厌这种<b>“自废武功”</b>式的题目，一边这也不让那也不让，一边又要你做这做那。

<hr>

76 Minimum Window Substring

题意：给定长串s和短串t，请找出<b>长度最短</b>，但<b>包含了t中所有字母</b>的s的子串。t可能有重复字母，所以要在个数上包含。

难度：hard

解法：放在现在是很标准的medium了，<b>滑动窗口题</b>。甚至题目里都提示了window。<b>滑动、计数、判断，再滑动</b>。这会成为一个标准的统计手法，后面经常用到。

<hr>

77 Combinations

题意：给定正整数n和k，返回从1-n中选k个数的所有不同<b>组合</b>。

难度：medium

解法：搜索即可。

<hr>

78 Subsets

题意：给定一个无重复元素的数组（其实就是集合），返回它的所有子集（其实就是幂集）。

难度：medium。

解法：搜索即可。

<hr>

79 Word Search

题意：给定一个m x n矩阵，每一格有一个字母。给定一个目标字符串word，从任意位置出发，上下左右走不重复的格子，对应序列是否能组成word？

难度：medium

解法：<b>搜索+回溯</b>，成功就结束，失败就回溯。

<hr>

80 Remove Duplicates from Sorted Array II

题意：有序数组就地去重，但是重复元素<b>至多保留两个</b>，而不是一个。

难度：medium

解法：大同小异，往前挪的时候，留两个位置即可。

<hr>

81 Search in Rotated Sorted Array II

题意：和之前Search in Rotated Sorted Array类似，一个有序数组经过了（也可能没有）循环移位，但这次数组可能有<b>重复元素</b>。在其中查找一个目标值target。

难度：medium

解法：依然二分，但因为重复值的存在，可能需要做一些+1、-1的O(n)操作，因此<b>最坏时间是线性</b>，最优时间是对数。

<hr>

82 Remove Duplicates from Sorted List II

题意：给定有序单链表，把存在重复值的对应节点<b>全部去掉</b>，只留下无重复值的节点。

难度：medium

解法：注意读题，<b>不是去重</b>，而是有重复的直接全删了。

<hr>

83 Remove Duplicates from Sorted List

题意：给定有序单链表，去重并返回表头。

难度：easy

解法：这个是去重，标准操作。

<hr>

84 Largest Rectangle in Histogram

题意：给定一个高高低低的直方图，每格的宽度是1，求在其中能画出的<b>最大的矩形面积</b>是多少。

难度：hard

解法：很经典也很著名的一道面试题，DP解决。主要思路就是对每个位置，看看<b>往左、往右</b>能找到多少个<b>连续的，高于它的位置</b>。因为必须<b>更高才能继续扩展这个矩形</b>。算好左右宽度之后，乘以高就是<b>面积</b>。

<hr>

85 Maximal Rectangle

题意：给定一个01矩阵，允许在其中<b>框一个矩形</b>，要求其中<b>所有元素都是1</b>。求这个矩形框的最大面积。

难度：hard

解法：相当巧妙的一题，其实就是上一题，<b>直方图矩形面积</b>的变体。我当时花了10多分钟才想到。每往下扫一行，直方图的数据就更新一次。当然，<b>遇到0的时候</b>，直方图的对应列就归零了。

<hr>

86 Partition List

题意：给定一个链表和一个值x，对节点进行划分，使得小于x的元素在前，大于等于x的在后。两组节点的<b>内部顺序</b>要和之前保持一样。

难度：medium

解法：题目已经暗示得很明显了，<b>按顺序</b>一个个分类，两条链表再拼起来即可。

<hr>

87 Scramble String

题意：给定一个长度大于1的字符串s，可以随机选取一个位置切分为两个子串x + y，并将两串交换，变为s' = y + x，称为一次“乱序”。乱序操作可以<b>对子串递归执行</b>。当对一个字符串s递归执行<b>任意次乱序操作</b>后，能否将其变为字符串t？

难度：hard

解法：第一念头当然是DP或者搜索，但既然是hard难度，一定要在效率上有所考虑。其实DP还是搜索没有本质区别，都是对<b>子问题</b>的表达方法。搜索如果效率不达标，也需要<b>记忆化</b>的办法去提高效率。最后我还是选了DP，对s和t的不同位置的<b>同长度子串</b>进行匹配。循环层数比较多，注意不要搞晕了。

<hr>

88 Merge Sorted Array

题意：有序数组归并，但这次<b>数组1</b>中留了足够的位置给你。

难度：easy

解法：水题。

<hr>

89 Gray Code

题意：格雷码，一种很神奇的编码方式。任意相邻的两个代码（包括第一和最后）之间都只有1位不同。给定长度n，请生成一种合法的n位格雷码编码。

难度：medium

解法：<b>递归</b>的完美例子，你用脑子硬想格雷码，肯定想不明白。但想一想n和n-1之间的关系，代码就很容易写出来。递归是一种非常<b>反直觉</b>的思维方式，但又极其优雅，很能体现数学的魅力。你把n-1位格雷码反转过来，开头都加个“1”，再拼起来不就是n位格雷码。

<hr>

90 Subsets II

题意：还是求集合的幂集，但这次元素可能有重复，相当于数学上的multiset。

难度：medium

解法：依然是搜索，这次有重复元素，改用map代替set来进行计数。

<hr>

91 Decode Ways

题意：按照1-26对应A-Z的编码方式，给定一个<b>数字串</b>，请求出有多少种不同的翻译方式来<b>翻译成字母</b>。

难度：medium

解法：线性DP，无序使用数组，只记录最近两三个位置的结果即可。

<hr>

92 Reverse Linked List II

题意：给定单链表和left、right位置，将[left, right]位置内的部分链表反转，并返回表头。

难度：medium

解法：注意处理各种<b>边界case</b>即可，只求仔细。

<hr>

93 Restore IP Addresses

题意：给定一个数字串，允许在其中插入“.”，请返回能得到的所有<b>有效IP地址</b>。

难度：medium

解法：一边搜一边插入点，检查有效性即可。

<hr>

94 Binary Tree Inorder Traversal

题意：给定二叉树，求中序遍历。

难度：easy

解法：这是必知必会了，<b>前中后序遍历</b>。用栈来<b>模拟递归</b>，也属于不算很难的东西。但我记得还有个非常诡异且偏难怪的<b>O(1)空间遍历</b>，那个我至今也没学会。好像和教材里讲过的“线索树”有关。

<hr>

95 Unique Binary Search Trees II

题意：给定值1-n，请问可以组成多少种不同结构的n节点二叉搜索树。返回所有树。

难度：medium

解法：其实这和括号匹配一样，都是卡塔兰数的例子。搜索记录即可，这个规模是<b>阶乘级</b>的，n不可能给到很大，C(n) = (2n)! / ((n + 1)! n!)。

<hr>

96 Unique Binary Search Trees

题意：给定值1-n，请问可以组成多少种不同结构的n节点二叉搜索树。只需要返回个数。

难度：medium

解法：就是<b>卡塔兰数</b>，标准的，原封不动的，C(n) = (2n)! / ((n + 1)! n!)。

<hr>

97 Interleaving String

题意：给定字符串s1、s2、s3，判断s3是否可以由s1、s2的字符<b>按次序穿插组成</b>。

难度：medium

解法：穿插，也就是把s2的字符<b>依次分散插入</b>s1，或者s1分散插入s2（同理）。使用两个指针逐个判断s3的当前字符是否和其中一方匹配，一步步往前。但是，<b>这个思路是错的</b>。虽然很直观，但行不通。需要用DP解决，贪心策略不对。从这点看，这题其实挺hard，属于medium里比较坑人的。

<hr>

98 Validate Binary Search Tree

题意：给定一个二叉树，判断它是不是一个二叉搜索树。

难度：medium

解法：按定义来即可，对<b>每个位置</b>，判断<b>左子树最右</b>和<b>右子树最左</b>是不是分别小于、大于根节点。

<hr>

99 Recover Binary Search Tree

题意：给定一个二叉搜索树，有两个节点的位置被交换了，请在不改变节点指向的情况下，找到两个值并换回来。

难度：medium

解法：挺巧妙且有点难的一题。利用<b>BST的中序遍历结果有序</b>这个特点，如果乱序了，这个地方一定有节点被换了。记录下<b>发现乱序</b>的位置，做交换。要注意两个点<b>恰好相邻</b>和<b>不相邻</b>两种情况

<hr>

100 Same Tree

题意：给定两个二叉树，判断它们是否完全相同。

难度：easy

解法：递归比较即可。

## 0101 - 0200

101 Symmetric Tree

题意：给定一个二叉树，判断是不是左右镜像对称。

难度：easy

解法：从根节点开始，左右同时往下走，按对应位置递归检查即可。

<hr>

102 Binary Tree Level Order Traversal

题意：二叉树层序遍历。

难度：medium

解法：我忘了是不是叫“层序遍历”，总之就是一层层横着扫，使用<b>队列</b>。

<hr>

103 Binary Tree Zigzag Level Order Traversal

题意：还是层序遍历，但是这次按照左右、右左、左右这样交替进行。

难度：medium

解法：可以层序遍历之后，把结果反转一下。

<hr>

104 Maximum Depth of Binary Tree

题意：求二叉树的最大深度。

难度：easy

解法：属于树的基本操作之一，求长度、求深度。递归统计即可。

<hr>

105 Construct Binary Tree from Preorder and Inorder Traversal

题意：给定二叉树的前序和中序遍历结果，重建这棵树。

难度：medium

解法：教科书级的题目，有<b>前中</b>或者<b>中后</b>，就可以重建整棵树，但是<b>前后</b>不行。想一想怎么逐渐往下递归，并找到<b>当前哪个点是根节点</b>。如果值唯一的话，还可以用<b>哈希表</b>把<b>值的对应下标</b>记下来，方便快速找到。

<hr>

106 Construct Binary Tree from Inorder and Postorder Traversal

题意：同上，通过中序和后序遍历结果，重建二叉树。

难度：medium

解法：同上，就是前序和后序的位置不同而已，关键其实都在于用好<b>中序遍历</b>。

<hr>

107 Binary Tree Level Order Traversal II

题意：还是层序遍历，但这次要求从下到上。

难度：medium

解法：把层序遍历的结果上下反转一下即可。

<hr>

108 Convert Sorted Array to Binary Search Tree

题意：给定有序无重复数组，将其转换成一个二叉搜索树。

难度：easy

解法：二叉搜索树的中序遍历是有序的。为了使树的<b>左右子树尽可能平衡</b>，递归重建。每次<b>左右都取一半</b>，中间是根节点。

<hr>

109 Convert Sorted List to Binary Search Tree

题意：这次是有序链表，转换成一个二叉搜索树。

难度：medium

解法：思路完全一样，不过你无法直接取链表的下标，所以要小心往前走到对应位置。链表题考察的都是<b>“仔细”</b>二字。递归时记得记录链表片段的<b>头尾节点</b>。

<hr>

110 Balanced Binary Tree

题意：给定二叉树，检查高度是否平衡。

难度：easy

解法：平衡的定义是，<b>每个节点</b>左右子树的<b>高度差不大于1</b>。按定义递归检查即可。

<hr>

111 Minimum Depth of Binary Tree

题意：给定二叉树，以根节点深度为1，求最小的叶节点深度。

难度：easy

解法：和节点值毫无关系，递归搜索即可。

<hr>

112 Path Sum

题意：给定二叉树和目标值target，判断是否有一条从根到叶的路径，<b>节点值之和</b>等于target。

难度：easy

解法：水题。

<hr>

113 Path Sum II

题意：给定二叉树和目标值target，找出所有<b>节点值之和</b>等于target的路径，并返回。

难度：medium

解法：递归搜索，判断并<b>收集结果</b>。完成后全部返回。

<hr>

114 Flatten Binary Tree to Linked List

题意：给定二叉树，请将其做一下变换，按<b>右指针</b>连接，变成一个链表。要求链表的值恰好和二叉树的<b>前序遍历</b>一样。

难度：medium

解法：一道有点脑洞的题，后面还有好几个这种<b>链表魔术题</b>。肯定是递归，对吧？前序的做法是<b>“根左右”</b>，那就递归处理好，然后按根->左->右把<b>递归结果</b>拼起来。

<hr>

115 Distinct Subsequences

题意：给定字符串s和t，从s中取出子序列，使其等于t。请问有多少种不同取法。

难度：hard

解法：既然是问<b>多少种不同的取法</b>，而不是要<b>找一个</b>，或者判断<b>能不能</b>，那应该是DP了。有这个思路了，设计DP关系式应该不难。凡是这种只关心<b>“上一步”</b>的DP，在空间上都是可以优化的，滚动数组。

<hr>

116 Populating Next Right Pointers in Each Node

题意：给定一个<b>满二叉树</b>（不是完全二叉树，是满），每个节点有一个next指针，将其指向它<b>层序遍历</b>的<b>右边最近</b>的节点。但是不准用层序遍历。

难度：medium

解法：<b>脑洞题</b>，而且脑洞还不小。其实不论是什么树，用<b>层序遍历</b>，相邻的两个节点如果在同一层，肯定要连上一个next指针的。这种思路<b>直观且易实现</b>。但这题就是给你出个脑洞，要求O(1)空间。这个也是满二叉树这种丰满结构才有的特点，左右挨得非常近。我没法解释那个代码是怎么设计出来的，当年<b>我应该没有独立想出来</b>。

<hr>

117 Populating Next Right Pointers in Each Node II

题意：同上116，这次不是满二叉树了，任意二叉树。还是不准用层序遍历。

难度：medium

解法：怎么说呢，用递归思路做其实也不算难，但还是有脑洞的。但是递归显然不符合O(1)空间的要求，递归最起码栈空间是O(h)对吧，h是树的高度。我不太理解这种<b>天才题</b>到达有什么意义，特定场景下如果实在没内存了，一定要做这些<b>走钢丝</b>的事吗？

<hr>

118 Pascal's Triangle

题意：帕斯卡三角，中国叫<b>杨辉三角</b>。给定整数n，输出1-n行杨辉三角。

难度：easy

解法：水题。

<hr>

119 Pascal's Triangle II

题意：同118，这次只输出第n行。

难度：easy

解法：水题。

<hr>

120 Triangle

题意：给定一个三角形的二维数组，每行比上一行多一个元素。从顶部往下左右走，求<b>累加和的最小值</b>。

难度：medium

解法：常规DP题，在<b>上一步的两种路里</b>，找更小的即可。

<hr>

121 Best Time to Buy and Sell Stock

题意：给定一个数组，表示一只股票的每日价格。允许你选一天买入，另一天卖出，<b>做一次买卖交易</b>，求出最大的盈利。如果无法盈利则不交易。

难度：easy

解法：<b>炒股系列</b>，应该总共四五题。总是记录<b>当前的最低价</b>即可。

<hr>

122 Best Time to Buy and Sell Stock II

题意：还是炒股。这期间你可以<b>多次买卖</b>，但不能<b>同一时间多次买入或者持有</b>，必须卖出才能再买。求最大盈利。

难度：medium

解法：其实比121更简单，<b>只要涨价就买</b>，第二天就卖出。属实是<b>短线之神</b>了。

<hr>

123 Best Time to Buy and Sell Stock III

题意：还是炒股。这次你<b>至多</b>可以进行两次买卖，还是不能在同一时间内多次买入持有。求最大盈利。

难度：hard

解法：比121稍微难一点，并不能算真的hard。既然至多2次，那就在0次、1次的基础上，再处理2次的情况。DP解决，后面还会遇到<b>至多k次</b>的情况，还是DP。

<hr>

124 Binary Tree Maximum Path Sum

题意：给定一个二叉树，每个节点有一个值。允许从任意点出发，到达任意点。求所得路径和的最大值。

难度：hard

解法：早年的hard，现在属于中规中矩的medium了。这题如果把树转换成无向图，再去搜索，那就搞复杂了。其实思路就是递归向下，走<b>左右两条路拼起来</b>。另一种情况就是从<b>当前根节点</b>直接出发走一条路。注意，是<b>“当前根节点”</b>，不是整棵树的根节点。

<hr>

125 Valid Palindrome

题意：给定字符串，只保留字母并转换为小写之后，判断是不是回文串。

难度：easy

解法：水题。

<hr>

126 Word Ladder II

题意：给定一个起始词，一个终止词，和一个<b>单词长度都相同</b>的词表。从起始词开始，每次允许<b>更改一个字母</b>，逐步将其变为终止词，并要求每步<b>变换后的词都要在词表中</b>。请给出<b>最短的</b>变换方法，如果不存在则返回空。

难度：hard

解法：这是个图。对，很多<b>图论题</b>的关键在于能<b>看到图</b>。因为每次只能变一个字母，对词表里相差一个字母的情况，可以<b>建一条双向边</b>，这图就出来了。以图为根据，从起点开始执行<b>BFS</b>，到达终点为止。因为求的是<b>最短的</b>，每条边<b>权重都是1</b>，BFS正合适。奇怪的是，我当年代码写得巨长，还用了DFS，搞不懂。

<hr>

127 Word Ladder

题意：和126完全相同，这次只需要返回变换序列的长度。

难度：hard

解法：很奇怪为什么简化版的放在后面，更难的反而在前。同上。

<hr>

128 Longest Consecutive Sequence

题意：给定一个无序数组，求出其中的最长连续序列的长度。最长连续序列指的是在<b>排序之后</b>可以构成一个<b>公差为1的等差数列</b>。

难度：medium

解法：当然，你不能排序，要求在O(n)时间完成，因此这个挺有难度的。为了保证效率，我用了个区间延伸、合并的方法。用<b>两个哈希表</b>来记录区间的<b>首尾位置</b>，每增加一个元素，就检查<b>哪个区间可以延伸，哪两个区间可以合并</b>。这样全处理完后，找到最长的区间即可。思路不算很麻烦，但代码写得还挺麻烦。<b>确实有难度</b>。我想不出<b>更简洁或者更诡异</b>的方法了。很多人都说这题应该是hard，我同意。

<hr>

129 Sum Root to Leaf Numbers

题意：一个二叉树，每个节点有一个0-9的数字。从根到叶的路径可以代表一个<b>大数</b>。请求出所有<b>这些路径构成的数</b>的和。

难度：medium

解法：递归即可。

<hr>

130 Surrounded Regions

题意：给定一个m x n矩阵，每个格子是X或者O，和上下左右四个方向相邻。对于一个连同的O区域，如果周围全被X格包围，则该区域全部变成X。处在边界的O不算被包围。<b>就地进行</b>以上变换。

难度：medium

解法：<b>搜索</b>，不论深度还是广度都行。需要注意，搜完之后要判断<b>全包围</b>才能<b>统一处理</b>。还有一种做法，就是可以先把<b>和边界相邻的区域</b>设为另一值（以便保护起来），这样就不受包围操作的影响了。

<hr>

131 Palindrome Partitioning

题意：给定一个字符串，将其划分为多个子串，使得每个子串都是回文串。请返回所有划分方式。

难度：medium

解法：长度很短，可以暴力搜索。当然，提前把判断回文串的工作做好也行。

<hr>

132 Palindrome Partitioning II

题意：给定一个字符串，将其划分为多个子串，使得每个子串都是回文串。请返回<b>最少的划分次数</b>。

难度：hard

解法：比131难一点，不过也不算很难。很明显的DP思路，O(n^2)解决。

<hr>

133 Clone Graph

题意：给定一个<b>单连通</b>的无向图，请设计算法将其复制一份，并返回<b>和输入同一位置</b>的节点。

难度：medium

解法：这个其实更多是帮助初学者了解基础知识，比如<b>深拷贝浅拷贝</b>。当然，最标准的思路，要克隆一个东西，还是知道它的<b>序列化、反序列化</b>方式最靠得住。搞一些<b>奇奇怪怪的指针操作</b>，那就是纯属无事生非了。我记得我就是<b>用哈希做了一对一映射</b>，按部就班做的。

<hr>

134 Gas Station

题意：给定一个长度为n的<b>环形路</b>，每个加油站前往下一站会有一定的油耗cost[i]。假定你的油箱不限量，每个加油站有一定的油量gas[i]提供。如果你可以从任一站，以0油量出发（起步可以加油），要求<b>能走完一整圈</b>，请返回<b>选定的出发站</b>。

难度：medium

解法：处理<b>循环数组</b>有个通用的技巧，就是<b>把同一数组拼两份</b>，来个a + a，这样就<b>不怕下标越界</b>了。从任意点出发，你始终关心的是<b>当前油量是否变成负的</b>。是的话，<b>当前这段就可以放弃</b>，因为<b>你油不够</b>了。这个题和<b>最大子数组和</b>有点像，都是略有脑洞，但不过分的程度。

<hr>

135 Candy

题意：给定n个小朋友和一些糖果。每个小朋友有个<b>排位值ratings</b>。如果你至少每个小朋友要给1颗糖，且如果一个小朋友的<b>排位比相邻小朋友高</b>，糖的个数也<b>对应要更多</b>。请问最少需要准备多少糖，才能满足分配要求。

难度：hard

解法：确实挺难的，读完题目大概5分钟毫无想法的那种难度。再想5分钟，判断是不是可以<b>贪心</b>，结论是可以。按照全部1颗起步，遇到排位有高低的情况，就给高的+1。<b>从左到右，从右到左。</b>注意，+1不是加一颗，而是要<b>比旁边的多一颗</b>。

<hr>

136 Single Number

题意：给定一个数组，出了一个数之外，其他数都出现了两次。找出这个单独的数。

难度：easy

解法：好像是《编程珠玑》还是《编程之美》上的一个经典例子吧？<b>异或</b>是位运算里最神奇，最有魔性的一个。有很多坑货玩法，都可以借助异或实现。

<hr>

137 Single Number II

题意：136的变体题，这次其他数都出现了3次，而不是2次。找出这个单独的数。要求只使用O(1)空间

难度：medium

解法：有点<b>脑洞</b>了，这次不能用异或来抵消结果。用的是逐个二进制位统计1的个数。因为是出现3次，那个数肯定是3个倍数。因此，如果<b>余数是1</b>，就表示单独的数<b>在这一位是1</b>，否则这位是0。这样<b>一位位拼起来</b>就是最终结果。

<hr>

138 Copy List with Random Pointer

题意：给定一个链表，每个节点有一个random指针，指向了链表里另一个节点，位置没有规律。请设计算法复制这个链表，使得复制链表的random指针仍指向新表中的对应位置。挑战是<b>只使用O(1)额外空间</b>。

难度：medium

解法：这题是我见过的链表题里，<b>最诡异、最偏难怪、最奇技淫巧</b>的一题。直接通过哈希、数组或者随便什么<b>辅助结构</b>来完成的话，当然不难。难点在于不开辟额外结构，直接对next、random两个指针做出一些极难理解的操作。反正我无法描述清楚，到底发生了什么...你需要做一些p->random->next = xxx、p->next->random = xxx之类的魔法才能完成O(1)空间的解法。我觉得这题是<b>名副其实的hard</b>，也可以算tricky hard。

<hr>

139 Word Break

题意：给定一个长字符串s和一个词表。判断s是否可以被<b>划分成多个子串</b>，每个子串<b>都在词表中</b>。

难度：medium

解法：<b>正向思维</b>就是往后搜，<b>逆向思维</b>就是DP往前找。其实本质是一样的，只要效率够高就可以。

<hr>

140 Word Break II

题意：同139，但这次要求返回所有划分方式，结果中的<b>单词用空格连成句子</b>。

难度：hard

解法：这次就<b>必须搜</b>了，因为要求返回所有划分方式。

<hr>

141 Linked List Cycle

题意：给定一个单链表，判断是否存在环路。

难度：easy

解法：找有环链表的入口节点，这应该是《编程之美》上的例子了。不过这个只需要确定是否有环，不用找位置。有直白的<b>哈希表</b>解法，有<b>快慢指针跑圈</b>解法。快慢跑圈就是两个指针，快的走2步，慢的走1步，如果<b>能追上并且重新相遇</b>，就一定有环。

<hr>

142 Linked List Cycle II

题意：类似141，给定一个有环的链表，你需要找出环的入口节点。

难度：medium

解法：《编程之美》上的经典例子。还是哈希解法或者快慢指针解法。不过这次因为要找到入口节点，快慢指针会有一个很有意思的用法（也非常难想）。当两指针第一次相遇时，把其中一个<b>放回表头</b>，然后两个用<b>相同速度</b>前进。当两者再次相遇，就在入口处。<b>神奇吧？我反正第一次看到都懵了。</b>

<hr>

143 Reorder List

题意：给定一个链表，按照1、n、2、n-1、...的方式重新排列节点。不允许修改节点的值。

难度：medium

解法：照做即可。拆分，反转，拼装。注意边界case。

<hr>

144 Binary Tree Preorder Traversal

题意：二叉树前序遍历。

难度：easy

解法：递归，或者使用栈模拟递归都可以。

<hr>

145 Binary Tree Postorder Traversal

题意：二叉树后序遍历。

难度：easy

解法：递归，或者使用栈模拟递归都可以。

<hr>

146 LRU Cache

题意：就是LRU Cache，定义就不说了，操作系统课的内容。主要是说起来比较麻烦，懒得写。

难度：medium

解法：这题是<b>完美的面试题</b>。东西描述得清清楚楚，说难其实也不难，但就是<b>很麻烦</b>。你知道自己会做，但你要<b>耐心，仔细，还得写得快</b>。实现方式的话，就用<b>一个双向链表和一个哈希表</b>配合。这题在面试时<b>通常用来刷人</b>，犯一点错或者写的太慢，就挂了。这题其实是面试的hard，题目本身属于medium。<b>hard在于心理压力。</b>

<hr>

147 Insertion Sort List

题意：插入排序。按照插入排序的定义，对链表进行排序。

难度：medium

解法：也是<b>教科书内容</b>了，首先你得知道<b>插入排序</b>的具体做法。因为插入排序是顺序寻找位置的（没用二分查找，也就没有<b>随机访问</b>），所以同样的方法也可以在链表上实现。照做即可，注意边界case。

<hr>

148 Sort List

题意：给定单链表，进行元素排序。

难度：medium

解法：教科书。排序是算法课的最基础且重要的内容之一，<b>必知必会</b>。可以用归并排序的思路做，都是顺序访问。如果用<b>快速排序</b>，你的划分元素就只能用<b>表头</b>了。当然，也不是不能做，但比较费劲而且不好理解。<b>对链表来说，还是归并排序最直接。</b>

<hr>

149 Max Points on a Line

题意：给定一些<b>整数点</b>，请问一条直线最多可以穿过多少点。

难度：hard

解法：其实不算难，平方复杂度能解决就行。对于每个点，考虑其他点连线的<b>斜率</b>，同斜率就等于共线了。但如果直接这么做，就错了。因为<b>浮点数计算</b>会有<b>精度问题</b>。另外，别忘了有<b>重合点</b>的情况。应该用<b>x/y这种分数来表示斜率</b>，也包括0/1和1/0两种特殊情况。分数，记得<b>约分</b>。

<hr>

150 Evaluate Reverse Polish Notation

题意：给定一个算数表达式的<b>逆波兰表达式</b>写法，计算它的结果。

难度：medium

解法：属实是专业术语了，这是形式语言的一部分。<b>逆波兰表达式</b>是<b>语法树</b>的<b>后序遍历</b>。语法树是什么呢？不展开了，都在编译原理的基础课里。比如`1+2*3`，对应的后序就是`['1', '2', '3', '*', '+']`。思路就是<b>栈</b>。递归是栈操作，所以你要模拟递归，就用栈做一遍。

<hr>

151 Reverse Words in a String

题意：给定一个句子，单词间用空格连接。请反转单词顺序，但不要反转单词里的字母。

难度：medium

解法：水题。题目还提到了，如果字符串结构是<b>可变</b>的（很多语言的字符串是<b>不可变类型</b>），有没有什么更高效的O(1)空间做法。

<hr>

152 Maximum Product Subarray

题意：给定一个整数数组，可能有正负数和0，求累乘最大的子数组，返回乘积。

难度：medium

解法：这题很有意思，也有点难。如果只有正数的话，可以直接取对数，<b>把乘积化为求和</b>。如果有正数和0的话，可以<b>把0作为分界线</b>，因为跨过分界线乘积一定是0。但还有负数，问题就复杂了，因为负负得正。也可能整个数组都是负数。我的思路是既要求<b>最大值</b>，也要求<b>最小值</b>，因为<b>最小值再乘一个负数</b>，可能就<b>变最大</b>了。讲了很多，其实代码挺简短的。并没有取对数，没必要。

<hr>

153 Find Minimum in Rotated Sorted Array

题意：给定一个<b>可能经过</b>循环移位的有序数组，找出最小值。

难度：medium

解法：二分，肯定二分。

<hr>

154 Find Minimum in Rotated Sorted Array II

题意：同153，但数组可能包含重复。

难度：hard

解法：给升级到hard其实夸张了，并没有变难。对于重复元素，也只能采取下标+1的办法。这个思路之前已经遇到过了，因此最坏时间是O(n)，最好依然是O(logn)。

<hr>

155 Min Stack

题意：设计一个最小栈，既可以像普通栈一样<b>出栈入栈</b>，也可以随时返回当前栈内最小元素。

难度：medium

解法：额外用一个<b>单调栈</b>，始终只放入<b>不大于栈顶</b>的元素。这样得到的单调栈是<b>递减</b>的。在出栈时，如果当前<b>栈顶元素</b>也等于<b>单调栈的栈顶</b>，则单调栈也出一个。后面还会有几个类似的题，在<b>栈、队列</b>之间玩一些<b>左右互搏的魔法</b>。

<hr>

156 Binary Tree Upside Down

题意：给定一个特殊的二叉树，所有非叶节点<b>都有左右子树</b>。请执行上下反转操作，<b>使得右邻居节点变为左子树，父节点变为右子树。</b>

难度：medium

解法：付费题。LeetCode的<b>第一道付费题</b>，我现在已经打不开题目页面了。这个反转方式比较诡异，读一遍题都看不懂。解法<b>并不需要递归</b>，在草稿纸上画一下形状，用循环可以搞定。因为题目要求比较奇怪，解法自然也奇怪。

<hr>

157 Read N Characters Given Read4

题意：如果你有一个read4函数，每次可以读4个字符，请设法实现一个read函数，读任意长度字符。

难度：medium

解法：付费题。这个需求倒是不奇怪，很多通讯方式就是定长的，需要各种特殊处理。这题考点就是<b>处理剩余的字符，不要丢失数据</b>。

<hr>

158 Read N Characters Given Read4 II - Call multiple times

题意：157的变体，这次你实现的读取n个字符的read函数<b>可能被调用多次</b>。

难度：hard

解法：付费题。多次调用，那就有<b>更多的边界case</b>要处理。

<hr>

159 Longest Substring with At Most Two Distinct Characters

题意：给定字符串s，求出其中最多包含<b>两种不同字符</b>的最长子串。返回长度。

难度：medium

解法：付费题。和后面还会遇到n次的各种类似题目一样，<b>滑动窗口+计数</b>。

<hr>

160 Intersection of Two Linked Lists

题意：给定两个单链表，可能在某一点交汇。请找出交汇点。

难度：easy

解法：这题也是链表脑洞合集之一。如果先统计长度，然后对齐位置找汇合点，就没什么脑洞。我记得好像有个奇奇怪怪的解法，涉及到反转链表。但考虑到<b>先求长度再对齐位置</b>的方法已经是O(1)空间了，没必要节外生枝。

<hr>

161 One Edit Distance

题意：给定两个字符串s和t，判断它们的编辑距离是否为1。

难度：medium

解法：付费题。之前已经讲过编辑距离的定义了，增、删、改一个字符，算一次编辑。第一念头是DP，但想了下发现不需要。直接<b>双指针</b>对应位置匹配，如果不匹配，则需要1次编辑。如果编辑次数大于1，就可以返回了。你并不是在找<b>最短编辑距离</b>。

<hr>

162 Find Peak Element

题意：给定一个数组，所有相邻元素都不想等。峰值元素的定义是，比左右邻居都大。边界处可以视为负无穷，也满足定义。请找出任一峰值的下标。要求在O(logn)时间完成。

难度：medium

解法：线性解法是显然的，不讨论。对数当然要依靠<b>二分</b>。二分的思路，就是如果处在上坡`a<b<c`，就应该<b>向右</b>；如果处在下坡`a>b>c`，就应该<b>向左</b>。这样逐渐缩小范围，总能夹出一个峰值。

<hr>

163 Missing Ranges

题意：给定一个有序数组，以及<b>闭区间</b>的上下界lower和upper。请返回所有<b>不在数组中的值</b>构成的<b>区间列表</b>。

难度：medium

解法：付费题。倒是没什么特别，一个个地添加、合并区间，然后<b>用总区间减一下</b>。或者也可以从`[lower, upper]`开始，一个个去掉数组中的元素。总之思路很简单，<b>实现起来麻烦</b>，而且<b>边界case很多</b>。

<hr>

164 Maximum Gap

题意：给定无序数组，请返回排序后，<b>相邻元素</b>的最大差值。但是<b>不允许排序</b>，需要在O(n)时间空间完成。

难度：medium

解法：多年之后，我重新花了10分钟想，没想出来。看了当年的代码，原来是<b>桶排序</b>。没错，当年想不出来，现在还是想不出来。这种<b>神谕时刻</b>，不是后天训练能学会的。统计<b>最大最小值</b>，和<b>不同值的个数</b>，对所有元素进行<b>区间分桶</b>。那么，关键来了，最大的相邻差值，一定来自`某桶的最小值 - 之前某桶的最大值`，且这两个元素之间没有任何元素了，否则它们就不相邻了。事后你再看，整个设计其实非常清晰、系统化，但不得不说脑洞就是很大。<b>“这是人想得出来的？”</b>。这可以算是super tricky hard了，设为medium难度不合理。最后，其实<b>桶排序不能算线性</b>，所有这个脑洞并不是100%讲道理，有点耍赖了。鉴定为<b>纯纯的坑货</b>。

<hr>

165 Compare Version Numbers

题意：给定两个类似1.1、1.2.34格式的版本号，比较其大小。版本号内数字<b>按整数处理</b>，无视多余的前置“0”。

难度：medium

解法：其实就是字典序，注意细节即可。

<hr>

166 Fraction to Recurring Decimal

题意：给定一个分数的分子分母，请用字符串表示它的<b>小数形式</b>。对于循环小数，要标记出<b>循环节</b>。

难度：medium

解法：小学数学，<b>分数和循环小数</b>的定义，这个挺有意思的。不断<b>做除法</b>，用一个数组（或者哈希表）来标记余数。如果一个余数<b>被第二次访问到</b>，就说明循环了。这个计算过程中记录的商，就是循环节。要注意开头可能<b>有不循环的部分</b>，不要漏掉。如果余数为0，则除尽了，结果是<b>有限小数</b>。总之是一道有点难度，要小心处理的题。

<hr>

167 Two Sum II - Input Array Is Sorted

题意：给定有序数组，找出两个元素，使得和等于target。返回下标。

难度：medium

解法：因为有序，可以直接用<b>双指针</b>向中间靠拢了。

<hr>

168 Excel Sheet Column Title

题意：给定列数，返回Excel中对应的列名称。

难度：easy

解法：Excel确实是这么定的。做一下特殊的进制转换，26进制。

<hr>

169 Majority Element

题意：给定一个数组，有一个值在其中出现超过了一半，找出这个值。

难度：easy

解法：这个称为<b>“众数”</b>，也是《编程之类》里的例子。如果不用哈希表统计个数，那就只留一个counter变量。是它，就+1；不是它，就-1。<b>计数减到负数了，就换掉。</b>因为数量超过了一半，怎么减最终也会大于0。因此留下的那个值肯定是众数。

<hr>

170 Two Sum III - Data structure design

题意：还是two sum，但这次要设计一个可以<b>不断添加元素</b>，可以<b>随时查找</b>two sum的数据结构。

难度：easy

解法：付费题。所幸只用判断<b>是否存在</b>，用一个哈希表统计已有元素，就可以随时查了。查找的方式就是遍历x，看`target - x`是否存在。注意处理`target = x + x`的情况。还有一种解法不如这个直白，效率上也不算优秀，不讨论了。

<hr>

171 Excel Sheet Column Number

题意：和168一样，但这次反过来了。给定Excel列名称，转换成列数。

难度：easy

解法：26进制，转换方式反过来即可。

<hr>

172 Factorial Trailing Zeroes

题意：给定自然数n，求n!末尾有多少个0。

难度：medium

解法：《编程之美》的经典题目之一。很巧妙，可以<b>一步步想出来</b>。多少个0，就代表<b>10的多少次方</b>。10的多少次方就是<b>2*5</b>的多少次方。阶乘嘛，<b>5的个数肯定比2少</b>，那就是多少个5。n!有多少个5？5是1个5，25是两个5，125是3个5。想出来了吗？

<hr>

173 Binary Search Tree Iterator

题意：给定一个二叉树，设计一个迭代器，用于<b>逐个访问</b>这个二叉树的<b>中序遍历</b>结果。每调用一次next()函数，得到中序遍历的下一个值。

难度：medium

解法：<b>栈</b>，用栈来模拟递归。

<hr>

174 Dungeon Game

题意：m x n的地下城，勇士从(0,0)出发，要去营救位于(m-1,n-1)的公主。每次允许<b>向右或者向下</b>移动一格。如果格子为正，表示<b>加血的瓶子</b>；如果格子为负，表示<b>打怪损失的血量</b>。请问勇士<b>最少需要多少血量出发</b>，才能成功救出公主。在任意位置，<b>至少血量为1</b>才能生存。

难度：hard

解法：要是允许上下左右走，那就复杂了。只能向右向下的话，可以<b>DP</b>解决。可以考虑<b>倒推</b>，从公主的位置，往左上走。

<hr>

179 Largest Number

题意：给定一系列非负整数，允许你用<b>任意顺序将其拼接起来</b>组成一个大数，请返回最大的结果。

难度：medium

解法：这题有个妙处，你想得很复杂，那就会越想越复杂。其实只做个排序就可以了。关键是，<b>排序的依据</b>。如果`a+b>b+a`，那就a在前，b在后。

<hr>

186 Reverse Words in a String II

题意：给定一个句子，只反转每个单词的字母，而不反转单词顺序。

难度：medium

解法：付费题。水题，和之前151的要求相反。

<hr>

187 Repeated DNA Sequences

题意：给定一个ATCG构成的DNA序列，请找出所有<b>长度为10</b>，且出现至少2次的子串。

难度：medium

解法：生物课知识就不讲了，DNA是ATCG，RNA是AUCG。如果直接暴力匹配或者统计的话，可以把各种子串都<b>哈希一下</b>，效率当然不高。因为字符只有4种，长度为10，给位运算提供了方便。所以改为用一个<b>20位二进制</b>来表示<b>10长度的DNA序列</b>，剩下的就是统计了。

<hr>

188 Best Time to Buy and Sell Stock IV

题意：同123，但这次你<b>至多可以做k次买卖</b>。求最大盈利。

难度：hard

解法：做两次买卖的时候，其实已经可以用<b>DP</b>思路解决了。延伸到k次，没有区别。考虑k-1次买卖的情况，递推即可。注意，是<b>至多</b>。

<hr>

189 Rotate Array

题意：给定数组和k，把数组循环右移k次。

难度：medium

解法：左反，右反，全反。

<hr>

190 Reverse Bits

题意：给定一个整数，把它的<b>二进制表示</b>反转一下。

难度：easy

解法：和数位反转一样，二进制十进制都一样。就是<b>模10乘10</b>和<b>模2乘2</b>的区别。

<hr>

191 Number of 1 Bits

题意：给定一个整数，求二进制表示里1的个数。

难度：easy

解法：经典位操作。`b=x&-x`提取一位，`x&=x-1`去除一位。

<hr>

198 House Robber

题意：给定n个房子依次排列。你是小偷，规定不能在相邻的房子偷东西。请问最多能偷到多少钱？

难度：medium

解法：比较直白的线性DP，保留<b>倒1和倒2</b>的状态，不断<b>滚动更新</b>即可。

<hr>

199 Binary Tree Right Side View

题意：给定一个二叉树，如果从<b>最右侧</b>看树，请返回能看到的节点值的列表。按<b>从上到下顺序</b>返回。

难度：medium

解法：其实方法倒是很多，目的都是遍历找到<b>最右边的节点</b>。可以按<b>先右后左</b>的方式进行<b>前序遍历</b>。也可以直接<b>层序遍历</b>。

<hr>

200 Number of Islands

题意：给定一个01矩阵表示的地形图。1表示陆地，0表示水。陆地按照上下左右相邻。请返回<b>连成一片的岛屿</b>的个数。

难度：medium

解法：搜，深度广度都可以。课本里管这个叫<b>“flood fill”</b>，洪泛算法。画图的<b>填色功能</b>，就是这么做的。

## 0201 - 0300

201 Bitwise AND of Numbers Range

题意：给定闭区间`[left, right]`，求其中所有数的<b>按位与&</b>的结果。

难度：medium

解法：位运算的<b>小聪明题</b>，`x = (x & x - 1);`。这种题都挺扯的，想不出来就很离谱，想出来了就很无聊。这就跟<b>法国国旗变荷兰</b>一样，小聪明。

<hr>

202 Happy Number

题意：给定一个正整数，用它<b>各位数的平方和</b>去替换它，不断重复这个过程。如果最终结果为1，则称为“快乐数”。判断一个数是否为快乐数。

难度：easy

解法：水题。

<hr>

203 Remove Linked List Elements

题意：给定链表，删除所有值为val的节点，返回表头。

难度：easy

解法：注意边界case即可。

<hr>

204 Count Primes

题意：给定正整数n，返回小于n的<b>质数</b>的个数。

难度：medium

解法：筛法，这个筛子的名字，是纪念古希腊数学家Eratosthenes的。

<hr>

205 Isomorphic Strings

题意：给定字符串s和t，问是否<b>同构</b>。同构的定义是，可以对s的字符进行某种<b>一对一映射</b>，映射之后的s串恰好变换为t，比如abb和xyy。

难度：easy

解法：首先检查长度是否相同。逐个找新字符，<b>建立这个映射即可</b>。如果映射过程中发现不匹配了，那就不同构。

<hr>

206 Reverse Linked List

题意：反转链表。

难度：easy

解法：标准题，原题。

<hr>

207 Course Schedule

题意：你需要学习n门课，标号为0到n-1。给定一些前置要求`[x, y]`，表示你需要<b>先完成y课才能学x</b>。请判断能否完成所有课。

难度：medium

解法：怎么感觉说反了？题目一目了然，有向图，<b>拓扑排序</b>，检查是否有环。拓扑排序是图论的标准算法之一，必知必会。记录每个点的入度，总之<b>不断找入度为0的点</b>，删除<b>它发出的边</b>，同时更新<b>指向点的入度</b>，再继续找。所有入度为0的点都找完了，如果还有剩余的点和边，<b>那就有环</b>。得到的<b>点顺序</b>就是拓扑排序。这个后面还会经常遇到，图论题里经常要用的方法。

<hr>

208 Implement Trie (Prefix Tree)

题意：实现<b>字典树</b>。

难度：medium

解法：就是标准的字典树，教科书题目。不解释细节了。字典树主要适合大量数据插入，且数据分布比较均匀的情况。好处是<b>随时更新、随时检索</b>。

<hr>

209 Minimum Size Subarray Sum

题意：给定整数数组和target值，找到<b>和大于等于target</b>的<b>最短的</b>子数组。返回长度。

难度：medium

解法：所有元素都非负，因此累加和是<b>单调递增</b>的。用这个方法可以弄个O(nlogn)的解法。但用<b>滑动窗口</b>的话，一前一后还可以更快，O(n)。

<hr>

210 Course Schedule II

题意：同207，课表问题。这次你需要求出<b>合理的选课顺序</b>。如果无法学完所有课，则返回空。

难度：medium

解法：如前所述，<b>拓扑排序</b>。这次要的就是拓扑顺序。如果有环的话，拓扑排序的结果就是不完整的，<b>不会包括环里的节点</b>。

<hr>

211 Design Add and Search Words Data Structure

题意：设计一个数据结构，可以添加单词，也可以查询单词是否存在。查询功能要支持以“.”表示任意单字符的功能。比如“b..”可以匹配“bcd”、“bxy”等等。

难度：medium

解法：一种比较直白，但实现略麻烦的思路是<b>字典树</b>。之前遇到过，所以应该会写了。对于“.”单字符通配的情况，那就<b>分叉搜</b>吧。看了下我的代码，确实用了字典树。

<hr>

212 Word Search II

题意：给定一个m x n的字母矩阵和一个词表。允许从矩阵<b>任一位置出发</b>，<b>上下左右走</b>，但不能<b>重复访问格子</b>。请返回词表中所有可以<b>在矩阵中拼接出来</b>的词。

难度：hard

解法：这个hard，其实现在看来也不算很难了。因为思路是很明确的，<b>搜</b>，但效率不能太差。<b>矩阵不大，每个单词也很短，但词表很长。</b>因此可以利用这个特点，做一些针对性的优化。我用了<b>字典树</b>，把词都装进去后，再做的搜索。所以可以认为这个“hard”主要体现在<b>费劲</b>，而不是难想。

<hr>

213 House Robber II

题意：同198，小偷系列的第二题。这次房子首尾排成一个圈，你还是不能在相邻房子偷东西。请问最多能搞多少钱？

难度：medium

解法：<b>循环数组</b>，还是同类问题。用a+a的方式处理循环下标问题，其他的和198没有区别。

<hr>

214 Shortest Palindrome

题意：给定一个字符串s，允许你在<b>左侧</b>添加字符，将其变为<b>回文串</b>。请返回得到的最短回文串。

难度：hard

解法：题目规模要求必须O(n)时间解决。第一思路是，如果我知道前k位是回文串，那剩下n-k位就要补全，总长度是n+n-k。让这个k尽可能大，总长度就会尽可能小。因此要求<b>最长的回文串前缀</b>。必须是前缀，因为你只能往左添加字符。最后我想了个比较丑，但是能用的办法。<b>字符串，滚动哈希值。</b>利用类似多项式计算的办法，快速求出子串的哈希。目的就是<b>快速比较两个子串是否相同</b>。这题是回文串，因此你需要<b>正反比较</b>，因此计算哈希的方式也需要<b>一正一反</b>。多年之后再看这题，除了这个思路我还是没什么好点子。不过，这应该就是<b>Rabin-Karp字符串匹配算法</b>的思路，也不算什么诡异的设计。看评论区都说<b>KMP</b>，那个比RK算法还烧脑。

<hr>

215 Kth Largest Element in an Array

题意：给定无序数组，返回第k大元素。

难度：medium

解法：教科书题目，快速排序的变体，<b>快速选择算法</b>。注意是第k大，不是第k小。也可以用堆完成，保持一个<b>大小为k的最大堆</b>。个人更倾向于用堆。

<hr>

216 Combination Sum III

题意：组合求和系列的第三题。给定整数n和k，从1-9中选出k个数，使其加起来等于n。不能重复选数，返回所有<b>组合方式</b>。

难度：medium

解法：搜。

<hr>

217 Contains Duplicate

题意：给定数组，判断是否有重复元素。

难度：easy

解法：水题，集合判重即可。

<hr>

218 The Skyline Problem

题意：给定一些用矩形表示的房子，互相可能重叠。要求你画出一个<b>总的轮廓</b>，也就是城市天际线。返回的方式比较奇特，只返回所有<b>天际线高度发生变化</b>的<b>拐角点</b>。

难度：hard

解法：挺经典的一道hard。比较复杂，也很有意思。第一思路是一堆区间，高度就是区间的值。那么要拼出总轮廓，就要<b>对区间进行拆分、合并</b>，这样才能知道任何地方的最大值（也就是高度）。所以按照区间排序、合并的方法，可以做出来。但这么做，很费劲而且容易出错，所以不推荐。还有一种思路，是<b>以高度为入手点</b>，你只关心<b>当前最高的</b>，因此如果你需要有<b>排好序的高度</b>，还要<b>能增能删</b>，因此使用map可以达到目的。总体思路就是，不断地<b>添加建筑、删除建筑</b>，同时更新高度记录，并<b>能随时查到最大高度</b>。确实hard，<b>难想且比较难写</b>。

<hr>

219 Contains Duplicate II

题意：给定一个数组，判断是否有重复元素，且重复元素的<b>下标距离</b>不超过k。

难度：easy

解法：滑动窗口，不断<b>记录下标</b>，移出窗口的元素删掉就行了。

<hr>

220 Contains Duplicate III

题意：数组判重第三题。给定数组，请判断是否存在两个元素，它们值相差小于某个阈值，位置相差也小于某个阈值。也就是<b>值接近，位置也接近</b>。

难度：hard

解法：这个都不能算判重了，可以算是<b>“判接近”</b>。同理，还是<b>滑动窗口</b>。因为要判断值<b>接近</b>，而不是<b>等于</b>，那就找一个可以<b>增删查</b>，还可以<b>搜范围</b>的数据结构，因此用map正合适。python里的OrderedDict，也可以用bisect方法来进行二分查找。总之思路是一样的，<b>滑动窗口</b>更新记录，配合<b>二分查找</b>附近的值是否存在。

<hr>

221 Maximal Square

题意：给定m x n的01矩阵。请找出其中元素全为1的最大正方形。返回面积。

难度：medium

解法：之前85题是最大矩形，这个是正方形。这题更简单，不需要做各种变形，用<b>DP</b>。每个位置的dp[i][j]记录以这个点为<b>右下角</b>，能<b>往左上延伸多大的正方形</b>。想想这个关系式怎么列？最终max(dp[i][j])就是答案。不过我看了下<b>当年写的代码</b>，好像想的特别复杂，<b>不是我现在这个思路</b>。

<hr>

222 Count Complete Tree Nodes

题意：给定一个<b>完全二叉树</b>，在<b>小于O(n)时间</b>内，求出树的节点数。

难度：easy

解法：完全二叉树是除了最后一层之外，其它层都是满的。这种树可以用<b>紧凑的数组</b>表示，可以用来做<b>堆</b>。其实就是让你二分，二分找那个分界点，每次二分的代价是O(h)，h其实就是logn，你需要执行logn次二分，因此总代价是O((logn)^2)。log在多项式阶数是等效于0阶的，平方之后还是0阶，小于O(n)。符合要求。平心而论，这也不easy了，考察的东西<b>非常“科班”，近乎教条</b>。

<hr>

223 Rectangle Area

题意：给定两个和<b>坐标轴对齐</b>的矩形，求总共覆盖面积。

难度：medium

解法：初级的几何题。要知道如何求<b>矩形的交集</b>。相加，减去交集即可。

<hr>

224 Basic Calculator

题意：给定算数表达式，求值。要求支持整数的+、-、()运算。表达式可能带有无用的空格字符。

难度：hard

解法：很不错的面试题。东西不算很难，但能考察一个完整功能的实现，也包含了一些理论知识。知识点就是词法解析、语法树、栈操作。注意三点，运算数<b>入栈</b>；运算符<b>出栈</b>，且执行对应运算函数；括号调整<b>优先级</b>。后面的题目还会遇到<b>加减乘除</b>，对优先级也需要处理。

<hr>

225 Implement Stack using Queues

题意：请用<b>队列</b>实现一个<b>栈</b>。

难度：easy

解法：<b>这题很奇怪</b>。栈是反的，队列是正的。你可以负负得正，但不能正正得负吧？用两个队列也可以勉强实现，但我很确定这样得不到全O(1)的结果。<b>总之，是有问题的。</b>注意不能用deque，<b>deque是双向队列</b>，属于栈和队列的复合体。

<hr>

226 Invert Binary Tree

题意：反转二叉树。

难度：easy

解法：<b>LeetCode名梗之一</b>，用于嘲讽不刷题也不会写代码的菜，或者超会写代码且不屑于刷题的大佬。递归解决。

<hr>

227 Basic Calculator II

题意：224的变体。这次要支持<b>加减乘除</b>，但好像不用支持括号运算？

难度：medium

解法：其实没必要，之前已经写了<b>括号的逻辑</b>，就要<b>处理好优先级逻辑</b>。这次加入乘除，还是注意优先级即可。

<hr>

228 Summary Ranges

题意：给定<b>有序数组</b>，将其整理为区间段，每个区间表示<b>数组用已全部包含的数</b>。

难度：easy

解法：<b>因为有序</b>，所以难度大大降低了。直接逐个区间统计出来即可。

<hr>

229 Majority Element II

题意：169的变体。众数，但这个要求返回所有<b>出现超过1/3</b>的元素，不是1/2。

难度：medium

解法：还是脑洞题，问能不能在O(1)空间下解决。仿照之前的办法，<b>用两个计数器</b>，用同样的+1 -1的办法。你要是1/k，我就用k-1个计数器。不过这种脑洞搞得太多，就没意思了。

<hr>

230 Kth Smallest Element in a BST

题意：给定二叉搜索树，求其中第k小的值。

难度：medium

解法：首先，BST的中序遍历有序。做完整遍历取第k个是直接解法，时间O(n)。那么目标就是能不能在<b>对数时间</b>完成。而且题目还提出了，如果<b>树经常修改</b>，随时要求查询，有没有优化方法。看了下我的代码，用的是<b>统计节点个数，做记录</b>的方法。<b>用节点个数来判断左右走</b>。这方法其实不怎么好，但也没想出更好的。如果你说再用一个k大小的<b>最大堆</b>来记录k个值，那就有点耍赖了。都考察二叉树了，再用一些更复杂的数据结构来辅助，是不合理的。总之，这题<b>我没有很优雅的解法</b>。

<hr>

231 Power of Two

题意：给定一个整数，判断是不是2的整次幂。

难度：easy

解法：位运算，`x&x-1 == 0`。

<hr>

232 Implement Queue using Stacks

题意：请用<b>栈</b>实现一个<b>队列</b>。

难度：easy

解法：记住复杂度，如果原本都是O(1)，你的解法<b>至少要保证都是均摊O(1)</b>。如果弄成O(n)，那就失败了。具体做法，就是<b>两个栈</b>，左手倒右手，负负得正。

<hr>

233 Number of Digit One

题意：给定自然数n，求从0-n的所有数里，数字1出现的总次数。

难度：hard

解法：<b>数位动归</b>题。这种应该是非常标准的“算法题”了，不论题目还是思维，在工作、生活里估计一辈子也用不上。<b>DP</b>解决。具体就是考虑所有k位数里总共有多少个1，递推k和k-1的关系。DP关系式是从低往高推，对n则是从高往低处理。<b>第一次遇到确实挺难想的</b>。

<hr>

234 Palindrome Linked List

题意：给定链表，判断是否是回文链表。

难度：easy

解法：单链表，<b>不能随机访问，也不能回头</b>，因此还是有点难度。做法是对半拆分、反转、比较。这么想其实挺费劲的。当然，如果你<b>不在乎O(1)空间</b>的话，直接放到数组里就好了。

<hr>

235 Lowest Common Ancestor of a Binary Search Tree

题意：给定二叉搜索树，求两个点的<b>最近公共祖先</b>。

难度：medium

解法：<b>最近公共祖先，LCA问题</b>，是算法课遇到的最精妙（且难理解）的问题之一。主要是<b>Tarjan离线算法</b>的功劳，实在太神奇了。这题因为是二叉搜索树，有一个<b>有序</b>的特点，要容易很多。如果你发现x、y一个比r大，一个比r小，<b>那不就要分叉了</b>？那答案就是r，找到了。如果你发现r<b>恰好等于</b>x或者y，那也找到了。

<hr>

236. Lowest Common Ancestor of a Binary Tree

题意：235的变体，这次是普通二叉树了，无序。还是找<b>最近公共祖先</b>。

难度：medium

解法：这次没有<b>有序</b>的特点了。直白的做法，就是确定x、y两节点的深度，把<b>深度对齐</b>了，然后<b>一起往上走直到汇合</b>。神奇的<b>Tarjan算法</b>可以<b>一次性处理</b>很多这样的<b>批量查询</b>，这是它的神奇之处。这题就先用土办法搞定吧。

<hr>

237 Delete Node in a Linked List

题意：给定一个链表，你要删除某个节点。但你<b>只有这个节点的位置</b>，没有表头，请<b>就地修改</b>。

难度：medium

解法：脑洞题。反正在<b>“这也不行那也不行”</b>的情况下，我选择把<b>下一个节点的值</b>赋给它，然后把下一个点删了。这题目还特地提示你，这个点<b>不会出现在表尾</b>，你说是不是成心的？这种题就没意思，<b>为赋新词强说愁</b>。

<hr>

238 Product of Array Except Self

题意：给定数组，对每个元素，求出<b>除了它以外</b>其他元素的乘积。要求O(n)时间完成，且不使用除法。

难度：medium

解法：有意思的一题，且这个<b>思维方式</b>在后面还会用到。用<b>前缀、后缀</b>的方式，记录左连乘、右连乘，然后乘起来就行了。这样需要O(n)空间，因为要用数组记录左右结果。也可以省一个，但<b>不能两个都省</b>。

<hr>

239 Sliding Window Maximum

题意：给定长度为n的数组，用一个k大小的滑动窗口不断向前。在每个位置，求出<b>当前窗口的最大值</b>。

难度：hard

解法：这题是手把手教你用<b>滑动窗口</b>了，很有<b>教育意义</b>的一题。最直接的方法就是<b>map</b>，java叫TreeMap，python叫OrderedDict。这些结构的更新代价是O(logn)，查询最大最小值则是O(1)的。不断更新窗口的统计，按要求进行增删，每次都查询map里的最大值即可。

<hr>

240 Search a 2D Matrix II

题意：给定一个特殊的m x n矩阵，<b>每行向右</b>都是递增的，<b>每列向下</b>也是递增的。请在其中查找target值<b>是否存在</b>。

难度：medium

解法：74题和这个长得非常像，<b>但不一样</b>。74题的矩阵可以展开成<b>一个有序的一维数组</b>，而这个矩阵则是一种特殊的<b>数学结构</b>，叫Young tableau。有一种比较好理解的线性解法，提示是<b>“向左、向下”</b>。查资料显示<b>O(logn)的解法应该是不存在的</b>，但论证过程复杂点，没看懂。另外有O(nlogn)解法，也很容易想，逐行（或逐列）进行二分查找即可。但已经有线性解法，这个就没有必要了。

<hr>

241 Different Ways to Add Parentheses

题意：给定一个包含<b>加减乘</b>的算数表达式，允许你<b>任意添加括号</b>，请求出所有可能的计算结果。

难度：medium

解法：意思是你可以随便处理<b>优先级</b>。既然这样，就<b>递归搜</b>每个表达式片段的结果。当然，可以变动的是<b>结合优先级</b>，<b>运算数的先后</b>不能变。有点难，有点麻烦，但不算很难。

<hr>

242 Valid Anagram

题意：给定两个串s和t，判断是否为anagram。

难度：easy

解法：<b>排序后比较</b>即可。不排序的话，那就统计字母，再比较。

<hr>

243 Shortest Word Distance

题意：给定一个词表和其中两个词，求它们的<b>位置之差</b>。

难度：easy

解法：付费题。水题。

<hr>

244 Shortest Word Distance II

题意：243的变体，这次词表是固定的，但<b>查询单词位置之差</b>的操作会多次调用。请设计<b>高效算法</b>。

难度：medium

解法：付费题。用<b>哈希表</b>记录单词的下标即可。

<hr>

245 Shortest Word Distance III

题意：243的变体，这次词表可以有重复，选取的两个词也可以重复。

难度：medium

解法：付费题。那就还是<b>记录下标</b>，找最小差值就行了。没什么大区别。我琢磨至少需要<b>访问整个数组</b>才知道有哪些词，在什么位置。所以你不可能在O(logn)时间内完成，因此最优的时间也是线性的。不过这题也有点小技巧，就是<b>用两个变量i1、i2记录你找到的word1和word2的位置</b>，不断更新这个位置。当你<b>两个词都找到了</b>，就有结果了。你不断更新位置，也同时不断更新结果，使其越来越小。

<hr>

246 Strobogrammatic Number

题意：给定一个数，判断是否为中心对称的数。

难度：easy

解法：付费题。这个单词就够艰深的，strobogrammatic。意思是<b>中心对称</b>，旋转180度那种。<b>619</b>，6和9，中间的1。题目倒是水题。

<hr>

247 Strobogrammatic Number II

题意：246的变体，这次要求出所有<b>长度为n</b>的中心对称的数。

难度：medium

解法：付费题。稍微麻烦一点，但也不难。0对0、1对1、6对9、8对8，就这么多了。<b>左半边枚举</b>，右半边是确定的。

<hr>

248 Strobogrammatic Number III

题意：246的变体，这次要求出所有在`[low, high]`范围内的中心对称数。

难度：hard

解法：付费题。忘了为什么难度是hard，应该是<b>low、high的范围很大</b>。还是按照01689去搜就行了。注意搜的时候处理好low和high的<b>边界终止条件</b>。

<hr>

249 Group Shifted Strings

题意：给定一些只包含a-z的字符串，如果通过<b>任意次</b>字符循环后移可以变成<b>同一字符串</b>，则归为一组。<b>字符循环后移</b>是指类似`acc->bdd->...->zbb`这样的变换。请返回分组后的结果。

难度：medium

解法：付费题。<b>锚定一个位置</b>，进行对齐即可。比如所有字符串都移位成首字母为“a”，比较结果是否相同，相同就是一组的。

<hr>

250 Count Univalue Subtrees

题意：给定二叉树，求出单值子树的个数。<b>单值</b>的意思是，整棵树的节点值都相同。

难度：medium

解法：付费题。<b>递归搜</b>，同时用<b>集合</b>记录当前子树的不同值个数。个数为1就是单值子树了。

<hr>

251 Flatten 2D Vector

题意：设计一个迭代器，用来访问<b>二维数组</b>。按照<b>先行后列</b>的顺序，逐个访问每个元素。

难度：medium

解法：付费题。也没什么特别的，就一行行扫。

<hr>

252 Meeting Rooms

题意：给定一些会议的起始终止时间，问一个人能否参加所有会议。

难度：easy

解法：付费题。就是判断<b>区间是否重叠</b>。

<hr>

253 Meeting Rooms II

题意：252的变体。这次要判断组织这些会议至少需要多少个会议室。

难度：medium

解法：付费题。有一点难度了。这题要求的是同一时间，最多<b>有几个会议在同时进行</b>。评论区肯定有不少搞竞赛的说<b>这肯定线段树啊、树状数组秒了</b>这个那个。其实目的就是<b>针对区间做+1</b>，最后统计最大值。没必要搞那些，用<b>后缀和累加的方式</b>，也能搞定，不需要复杂的数据结构。需要注意，如果这个+1操作和查询操作是穿插的，换言之，不是<b>一口气加完了再查</b>，那就必须用奇奇怪怪的工具才行了。这就是<b>离线算法</b>和<b>在线算法</b>的区别。我看了下当年的代码，怎么用了个<b>排序+堆</b>的解法，搞不懂。

<hr>

254 Factor Combinations

题意：给定一个整数n，返回所有<b>n的约数相乘等于n</b>的<b>组合方式</b>。所选约数必须小于n。

难度：medium

解法：付费题。<b>搜</b>，注意搜法，使得结果不重复。如果<b>花额外代价做去重</b>，就不值得了。

<hr>

255 Verify Preorder Sequence in Binary Search Tree

题意：给定一个二叉树的<b>前序遍历</b>结果，判断对应的二叉树是否为<b>二叉搜索树</b>。

难度：medium

解法：付费题。比较直接的解法，是对`<值, 下标>`做一下映射记录，然后递归比较。如果是BST的话，左边都小于根，右边都大于根，这样能找到<b>分界位置</b>。递归往下找。如果发现矛盾，则不是一个合法的BST。还有一种思路，就是用<b>栈</b>。因为前序遍历<b>总是尝试往左走，越走越小</b>，走不动了就往右。利用这个特点想一想怎么入栈出栈，怎么做判断。题目还提出了<b>O(1)空间</b>的挑战，这个有点<b>小聪明</b>。在栈解法的基础上，直接把<b>原数组的头部</b>当成栈来用。总体上，这题挺扯的，有点费脑子。

<hr>

256 Paint House

题意：有n个房子依次排列，每个房子可以涂成红绿蓝的一种。每个房子涂每种颜色的代价用cost[i][j]表示，可能各不相同。现在要求<b>相邻房子</b>不能同色，问<b>最低代价之和</b>是多少？

难度：medium

解法：付费题。很标准的<b>DP</b>题。以前难度定为easy，后来改medium了。

<hr>

257 Binary Tree Paths

题意：给定二叉树，返回所有<b>从根到叶</b>的路径。用一种特定格式输出。

难度：easy

解法：<b>搜</b>，拼装结果。

<hr>

258 Add Digits

题意：给定一个整数，不断将它替换为它的<b>数字和</b>，直到<b>剩下一位数</b>。返回最终结果。

难度：easy

解法：水题。

<hr>

259 3Sum Smaller

题意：15的变体。给定数组和target值，求出所有加起来<b>小于target</b>的<b>三元组</b>的个数。

难度：medium

解法：付费题。思路依然类似。<b>枚举第一维</b>，另外两维采取<b>滑动窗口</b>的方法统计个数。

<hr>

260 Single Number III

题意：136的变体。给定一个数组，除了<b>两个值出现一次外</b>，其他值都出现两次。找出这两个值。

难度：medium

解法：脑洞题。肯定又要<b>位运算</b>了。重新想了十分钟，想不出来。看答案，发现是按<b>异或和</b>进行分类。针对某一位，0站一边，1站另一边。注意，是“某一位”，不是“每一位”。选哪一位呢？随便找两数不相同的一位就行，也就是异或和里<b>随便找个1</b>就行。不得不说这个<b>脑洞是真的大</b>，<b>天才题</b>。

<hr>

261 Graph Valid Tree

题意：给定一个无向图，判断是否是一棵树。

难度：medium

解法：付费题。树的定义其实就是<b>单连通、n个点、n-1条边</b>。你想想，这个条件卡下来，一定是棵树。<b>重复边不算</b>，有重复边也不能算是树了。

<hr>

263 Ugly Number

题意：一个数如果没有2、3、5之外的<b>质因数</b>，称为<b>丑数</b>。判断给定n是否是丑数。

难度：easy

解法：水题。

<hr>

264 Ugly Number II

题意：263的变体。给定n，返回第n个丑数。

难度：medium

解法：有点难度了，可以用<b>最小堆</b>实现。起步思路是3个指针指向x2、x3、x5，每次都从里面取出最小的那个，并把对应指针<b>往前一步</b>。不过毕竟<b>只有3条路</b>，用代码<b>手工取最小</b>也行。

<hr>

265 Paint House II

题意：256的变体。这次三颜色变成了k颜色。还是求最小代价。

难度：hard

解法：付费题。和之前完全一样，<b>DP</b>思路不变。3和k没有区别。

<hr>

266 Palindrome Permutation

题意：给定一个字符串，判断能否通过<b>字母乱序</b>变为一个回文串。

难度：easy

解法：付费题。水题，统计字符个数即可。

<hr>

267 Palindrome Permutation II

题意：266的变体。这次要求返回所有可通过<b>字母乱序</b>而变换出的<b>回文串</b>。

难度：medium

解法：付费题。有一点难度，需要想清楚。因为是回文串，后半部分是确定的，<b>前半部分可以自由枚举</b>。因此，用<b>next permutation</b>的方式枚举所有的前半部分，每次都<b>对应拼出后半段</b>就行了。<b>不用递归，都是循环。</b>

<hr>

268 Missing Number

题意：给定一个长度为n，且元素都在`[0,n]`范围内的数组。请找出<b>范围内没出现</b>的值。要求O(1)空间完成。

难度：easy

解法：<b>1-n累加</b>，看看差哪个。还有很多奇奇怪怪的做法，不讨论了。

<hr>

269 Alien Dictionary

题意：给定一种奇怪的外星语言，用了26个字母，但是顺序和正常的不一样。给你一组外星单词，且是<b>按照这个语言的字典序排列</b>的词表。请你推测出26个字母的先后顺序。

难度：hard

解法：付费题。有意思的一题，难度定为hard可能夸张了，但确实有意思，也不脑洞。这题的难点在于能快速看出<b>它是个图</b>。图在哪儿？就是26个字母建成一张图，你需要判断谁前谁后，就是<b>拓扑排序</b>。要拓扑就需要边，<b>边在哪儿</b>？就是词表里，<b>相邻两个单词的比较</b>，第一个不同的字母，就是边。当然，需要有不同字母的比较，才有用。比如`['bax', 'baxde']`这样是没用的。比如`['bax', 'bacd']`就有用，你知道了`x>c`。

<hr>

270 Closest Binary Search Tree Value

题意：给定一个二叉搜索树和一个target值，求出最接近target的节点值。

难度：easy

解法：付费题。不用想太复杂，按BST的规矩左右走，记录上一个访问到的值。因为当前值和上一个值，都可能是<b>最接近target</b>的值。另一种更暴力的办法就是先中序遍历，再从结果里找。但那样就效率低了。

<hr>

271 Encode and Decode Strings

题意：设计一个<b>编解码器</b>，把一组字符串编码成一个串。同时提供对应的解码方式。

难度：medium

解法：付费题。这是个<b>系统设计题</b>了，不太属于算法题。这个需要一些<b>编码理论课程</b>了，如果没学过完全凭自己创意做，估计会离题万里或者有各种问题。我当年怎么写了个base64的解法，代码还巨啰嗦。

<hr>

272 Closest Binary Search Tree Value II

题意：270的变体。这次要返回最接近target值的k个节点值。

难度：hard

解法：付费题。这题确实有难度了，难在比较麻烦。这个查询需求其实在实际工作里挺常见，尤其是<b>数据分析时</b>，所以这是道好题。我的思路是借助270的方法，用<b>正反两个方向</b>找到接近target的位置，然后<b>朝两边延伸，直到凑够k个结果</b>。想不出比较简洁的实现，所有代码巨长，专门写了<b>正反迭代器</b>。其实<b>思路是可以的</b>，应该是代码写得太差了

<hr>

273 Integer to English Words

题意：给定整数，用<b>英语</b>把它读出来。

难度：hard

解法：很费劲，而且要处理一些语法规则。很考验耐心的一题。<b>这个hard指的是work hard</b>。

<hr>

274 H-Index

题意：学术界有个H-index，能表示一个学者的<b>著作影响力</b>。定义是这个人如果<b>有h篇著作的引用数不低于h</b>，这个<b>h的最大值</b>就是其H-index。

难度：medium

解法：可以<b>排序</b>，然后<b>二分再二分</b>。先二分值，每个值二分查个数。

<hr>

275 H-Index II

题意：274的变体。这次<b>已经排好序</b>了，要求在<b>对数时间</b>完成。

难度：medium

解法：274里其实已经说了思路。<b>二分再二分</b>，复杂度是O((logn)^2)。

<hr>

276 Paint Fence

题意：有一个篱笆，有n个桩子。你可以选择k种颜色，给每个桩子上色。要求不能有<b>3个以上的相邻桩子</b>使用同一颜色。请问有多少种上色方法？

难度：medium

解法：付费题。思路上当然是个DP题，不过<b>可以不使用数组</b>。你只关心过去两个元素是<b>相同</b>还是<b>不同</b>。相同如何，不同如何，按这个思路递推。

<hr>

277 Find the Celebrity

题意：给定一些“谁认识谁”的关系，请找出圈子里的名人。名人的定义，就是大家都认识他，他不认识大家。

难度：付费题。嗯，名人，很拽。统计<b>入度和出度</b>即可。

解法：

<hr>

278 First Bad Version

题意：给定一个<b>检测函数</b>，告诉你某个版本号是否损坏。你需要设计策略，尽快找出第一个坏版本。

难度：easy

解法：二分。

<hr>

279 Perfect Squares

题意：给定一个整数n，请将其划分为几个完全平方数之和，并使得划分的个数最少。

难度：medium

解法：可以<b>DP</b>解决，也可以<b>BFS搜索</b>解决。个人觉得搜索的思路更直观。

<hr>

280 Wiggle Sort

题意：给定一个无序数组，将其乱序，使得结果满足类似“小大小大小大...”的关系，称为<b>摇摆排序</b>。返回<b>任意一种</b>有效结果即可。

难度：medium

解法：付费题。一种比较容易的思路，是<b>先排序</b>，然后把后半段<b>大的部分</b>穿插进<b>前半段里</b>。因为要求“小大小大小...”，穿插的部分都是<b>“大”</b>，用后半段正合适。不过我看了下自己以前的代码，用了更奇怪的一种思路。使用快选quick select的方式选一个中轴点，然后左右摆放，很难理解。<b>不知道当年怎么想的。</b>

<hr>

281 Zigzag Iterator

题意：给定一个二维数组，设计一个迭代器，采取<b>“先列后行”</b>的方式迭代访问这个数组。

难度：medium

解法：付费题。不难，就是有点麻烦，注意边界case即可。

<hr>

282 Expression Add Operators

题意：给定一个数字串和一个target值，允许你在任意位置插入<b>加减乘</b>号来构成一个<b>有效的</b>算术表达式。请问有多少种方法使得结果为target，返回所有方法。

难度：hard

解法：难度是hard，其实思路非常明确，<b>搜</b>。处理过程稍麻烦一点，而且注意进行剪枝。耐心完成即可。

<hr>

283 Move Zeroes

题意：给定一个数组，把0移到末尾，同时把非0元素<b>依次</b>往前移动。

难度：easy

解法：水题，和<b>就地去重</b>的方法一样。

<hr>

284 Peeking Iterator

题意：给定一个已有迭代器，请在此基础上设计一个迭代器，增加peek()功能，可以在<b>不前进的情况下</b>得到当前元素。

难度：medium

解法：题目没有说用于<b>访问什么具体的结构</b>，也就是没让你在某种特定结构上想点子。那就考虑peek()本身了。既然已有的iterator你调用一次next()必然会前进一步，那就<b>把调用的值存起来，下次不调就行了。进货，存货，出货</b>，对吧？就这个思路。

<hr>

285 Inorder Successor in BST

题意：给定二叉搜索树和一个<b>特定节点p</b>，请返回p在<b>中序遍历</b>的后继结点。

难度：medium

解法：付费题。注意，给的是节点对象，<b>不是节点值</b>。BST，中序遍历，显然还是用<b>栈</b>解决。想想进出栈的设计。

<hr>

286 Walls and Gates

题意：给定一个m x n矩阵，-1表示墙、0表示门、INF表示空地。请求出所有<b>空地</b>到<b>离它最近的门</b>的距离。如果找不到门，那就保持INF值。

难度：medium

解法：付费题。像这种每走一步距离都是1的问题，第一直觉都是<b>BFS，搜</b>。那么要找所有空地，就在开始时<b>把所有空地放进队列</b>去搜好了。看了下当年代码，确实这么写的。

<hr>

287 Find the Duplicate Number

题意：给定一个n+1长度的数组，所有元素都在`[1,n]`范围。只有一个值存在重复，请找出这个值。

难度：medium

解法：这题和268不一样，因为这题的<b>重复元素不一定出现两次</b>，也可以是很多次。挑战是<b>O(1)空间</b>，那就用常规的<b>统计思路</b>，但是就地取材。在原数组上“叠一层”，用+n表示+1，+2n表示+2，如此点点点。其实就和<b>二维坐标打平成一维</b>的思路相同，`a[i][j]等效于a[i*m+j]`。

<hr>

288 Unique Word Abbreviation

题意：单词简写的一种常用方式是`<首字母><中间的个数><尾字母>`，比如i18n、l10n，国际化和本地化。现在给定一个词表，按这种方式简写，请判断<b>每个词的对应简写</b>在词表中是否<b>唯一</b>，也就是是否<b>有其他词使用了相同简写</b>。

难度：medium

解法：付费题。思路不难，简写然后归类即可。

<hr>

289 Game of Life

题意：由英国数学家John Conway发明的生命游戏，一个很有<b>哲学内涵</b>的玩具模型。具体规则不讲了，给定m x n的棋盘和起步状态，请推算出下一步的棋盘状态。

难度：medium

解法：怎么说呢，<b>自动机理论</b>也是一种很优雅，且很有哲学味道的<b>世界观</b>。比如<b>“命运的齿轮、造物主”</b>就是一种对人生和万事万物的很工程化的理解。挑战是不使用额外矩阵，<b>就地完成</b>。其实这个挑战有点取巧，用类似287的<b>“叠罗汉”</b>做法，在数据范围不大的情况下，叠一层就行。叠完了，用除法给变回来就是最终结果。你想想<b>一个整数表示32位真彩色，包含了argb四个通道，每个8位</b>，这不就是叠罗汉？

<hr>

290 Word Pattern

题意：给定模式串p和句子s。请判断是否存在一种`p的字符<->s的单词`的一对一映射（双射），能将p变换为s。

难度：easy

解法：和205的<b>字符串同构</b>有点相似，不过稍难。这题之所以easy，是因为<b>帮你做好了分割</b>，给你明确的“单词”了。如果s中的字母都连在一起，那难度就高一些了，但依然可解。

<hr>

291 Word Pattern II

题意：290的变体。<b>这次s中的字母都连一起了</b>，还是判断是否存在p到s的一一映射。

难度：hard

解法：付费题。如上，难点就是<b>找到分割方式</b>了。在<b>字符串不那么长</b>的情况下，可以<b>边搜边做映射</b>，映射出现矛盾就回溯。所以是<b>搜索+回溯</b>的思路。没想出其他更高效的思路。

<hr>

292 Nim Game

题意：博弈论烧脑系列。A和B玩游戏，有一堆n个石头，两人交替拿。每次拿1-3个，成功拿到最后一个的人赢。问谁赢。

难度：easy

解法：几乎所有人都对“both players play optimally”这句话深恶痛绝。这是直觉无法理解的神仙操作。讲道理这种题目的难度标记都没有意义，因为你<b>想不清楚</b>的话，就和<b>看天书</b>一样。比如此刻我就没理解为什么是easy，然后我<b>突然懂了</b>。<b>4的倍数</b>，你想吧。就这么坑人脑细胞。

<hr>

293 Flip Game

题意：给定一个<b>+-号组成的字符串</b>，允许你选<b>两个相邻的同符号</b>进行反转。请返回所有有效的反转结果。没有，则返回空。

难度：easy

解法：付费题。下一题就难了，这题是热身。

<hr>

294 Flip Game II

题意：293的变体。两人轮流执行如上的反转操作，无法执行的人输。如果两人都用<b>最优策略</b>，请问谁赢。

难度：medium

解法：付费题。博弈论。说实话，想不出来。<b>暴力搜索</b>很容易想，但效率肯定很差（其实可以过，够用了）。看了下当年写的代码，注释里提到了<b>Sprague Grundy定理</b>。查了一下发现是有关<b>博弈论</b>里<b>公平游戏</b>和<b>nim game模型</b>的转换。也就是前面提到的nim game。如此<b>理论且晦涩</b>的东西，我当年肯定也没做出来，代码也不是独立想出来的。躺了吧。我又尝试看了下当年的代码，实在看不懂。

<hr>

295 Find Median from Data Stream

题意：给定一个不断流入的数据源。你需要提供<b>随时添加数据和查询中位数</b>的功能。

难度：hard

解法：有意思，有一定难度。首先，它是动态更新且随时查询的，当然不能<b>排序</b>。其次，你不能把以前的数据<b>丢掉</b>，因为新来的数据不知道大小，你丢了就没法比较，也没法确定中位数了。那么关键就是怎么添加，怎么存了。最后想出来一个比较好理解的方法，<b>两个堆</b>。一个<b>最大堆存小的一半</b>，一个<b>最小堆存大的一半</b>。剩下不多说了。查询代价是O(1)，添加代价是O(logn)。看了下当年代码，怎么用的是map，奇怪。

<hr>

296 Best Meeting Point

题意：给定一个m x n的01矩阵，1表示人，0表示空地。<b>所有人</b>希望选取<b>一个地点</b>见面，请计算所有人要移动的<b>最小总距离</b>。距离计算采用<b>曼哈顿距离</b>，也就是`|x1-x2|+|y1-y2|`。

难度：hard

解法：付费题。确实有点难，起步能想出很多<b>搜法</b>，但效率好像都不高。因为没有<b>“障碍物”</b>的概念，也就不存在<b>上下左右“绕路”</b>的需求了。那么，思路有了。比如选取(x,y)作为集合点，你算出了总距离是d。请问能不能用<b>O(1)的代价</b>，把(x-1,y)、(x+1,y)、(x,y-1)、(x,y+1)的对应总距离算出来。<b>答案是可以</b>，往下想吧。再具体点说，<b>行距离和列距离是分开算的</b>，互不影响。如果不用曼哈顿距离，问题就完全不同了。

<hr>

297 Serialize and Deserialize Binary Tree

题意：设计一个二叉树的序列化、反序列化方案。

难度：hard

解法：不是算法题，是<b>系统设计题</b>。序列化、反序列化的要求就是两点。一个是<b>编解码的唯一性</b>，要<b>一一对应</b>，这样才能反回来。一个是<b>执行效率要高</b>，实际应用的序列化函数都是<b>要在性能、安全上做极致要求</b>的，毕竟是<b>很底层的函数</b>，不能马虎。这道题的话，给出一种看得懂且效率不错的方案就可以了。我用了个挺土，不算很好的方案。<b>前序遍历，配合“#”表示null</b>来做序列化。前序最直观，第一个元素就是根。

<hr>

298 Binary Tree Longest Consecutive Sequence

题意：给定二叉树，允许从任意点出发<b>向下走</b>。请找出得到的最长连续序列的长度。连续指的是<b>公差为1且递增</b>。

难度：medium

解法：付费题。递归搜索即可。

<hr>

299 Bulls and Cows

题意：玩一个4位猜数游戏。你有一个4位数字，朋友猜一个4位数字，进行比较。如果<b>位置数字都对</b>，称为“A”；如果<b>位置错误但数字对</b>，称为“B”。给定这两个4位数，请返回检查结果。

难度：medium

解法：公牛和奶牛？为什么叫这个名字，应该是习俗了。完全匹配叫bull，数字对但是位置错误叫cow。你玩《辐射4》的话，还会用这个规则开锁。

<hr>

300 Longest Increasing Subsequence

题意：给定数组，求最长<b>严格</b>递增子序列的长度。

难度：medium

解法：这个，也没什么大区别吧。LIS是递增，可以相等。这个就是要求<b>严格递增</b>。还是一样，就是<b>比较时<=和<的区别</b>。
