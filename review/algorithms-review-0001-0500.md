# LeetCode 一句话题解 - 0001-0500

[返回目录](./algorithms-review-overview.md)

- [LeetCode 一句话题解 - 0001-0500](#leetcode-一句话题解---0001-0500)
  - [0001 - 0100](#0001---0100)

代码库地址：  
[https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/0001-0500](https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/0001-0500)

## 0001 - 0100

1 Two Sum

题意：给定一个无序数组和一个值target，返回下标[i, j]使得a[i] + a[j]等于target。

难度：easy

解法：使用哈希表，记录已访问到的值x和下标i，比较当前值是否等于剩余部分target - x。

<hr>

2 Add Two Numbers

题意：使用链表表示两个十进制大数，做加法。

难度：medium

解法：第一道链表题，注意边界case，比如进位问题即可。

<hr>

3 Longest Substring Without Repeating Characters

题意：给定一个字符串，求出最长的不带重复字符的子串长度。

难度：medium

解法：第一道滑动窗口题，后面会有无穷多的类似<b>滑动窗口、子串、子数组类型</b>的问题。使用前后两个指针向前走，中间夹住部分即为滑动窗口。同时使用一个计数器（哈希表）来统计个数，确保条件成立（或者刚好不成立）。

<hr>

4 Median of Two Sorted Arrays

题意：给定两个升序数组，求出两者归并后的中位数。

难度：hard

解法：第一道经典的费脑子题，你就很难理解有的人为什么可以瞬间想到。线性解法是显然的，难点在于如何在<b>不归并</b>的情况下，使用二分方法求出中位数。第一次做我想了一个多钟头也没想清楚。

<hr>

5 Longest Palindromic Substring

题意：给定字符串，返回最长回文子串，需要返回子串。

难度：medium

解法：O(n^2)解法显然，难点在于巧妙且经典的<b>Manacher算法</b>。对于没接触过的人，凭自己琢磨出同样算法几乎不可能，实在太精妙了。

<hr>

6 Zigzag Conversion

题意：把字符串按奇怪的方式排列一下，按部就班的模拟题。

难度：medium

解法：照做即可。

<hr>

7 Reverse Integer

题意：给定一个整数，把除了符号位以外的数位倒过来。

难度：medium

解法：不用字符串，直接用除10模10的办法即可。

<hr>

8 String to Integer (atoi)

题意：实现atoi，字符串转整数的功能。

难度：medium

解法：非常非常经典的，适合用来面试的题目。不难，但考察你耐心、仔细的程度，是很好的工程师考题。

<hr>

9 Palindrome Number

题意：判断一个数是否是回文数。

难度：easy

解法：水题，负数都不是回文数。

<hr>

10 Regular Expression Matching

题意：实现正则表达式中的单字符以及.和*匹配。

难度：hard

解法：第一道parser题，编译原理是计算机科学里极其优雅且复杂，但也非常有用的一门课。写各种解析器就是一种打地基式的劳动，值得练习。正则表达式既简短又博大精深，这个是非常简化的版本。

<hr>

11 Container With Most Water

题意：给定一些高高低低的挡板从左到右排列，相邻宽度都是1。允许你选其中两个挡板，连同地板组成一个容器。请问最多能存多少水？

难度：medium

解法：这个不是著名的接雨水，是一道比较简单的题。<b>双指针</b>逐渐往中间靠拢，一边靠拢一边不断更新能存水的最大值即可。

<hr>

12 Integer to Roman

题意：古老的罗马数字，IVXLCDM。做一下数字转换，把阿拉伯翻译成罗马。

难度：medium

解法：按部就班。

<hr>

13 Roman to Integer

题意：罗马数字转阿拉伯，和前面类似。

难度：easy

解法：按部就班。

<hr>

14 Longest Common Prefix

题意：给定一组字符串，找出最长的公共前缀。

难度：easy

解法：不要考虑<b>字典树</b>之类的复杂结构，直接保留当前最长前缀，逐个比较并更新即可。

<hr>

15 3Sum

题意：给定无序数组和目标值0，返回所有<b>元素和</b>加起来等于0的三元组的下标(i, j, k)。注意不要有重复结果。

难度：medium

解法：第一道<b>变体题</b>，这也是算法题的妙处之一。以同一类问题进行<b>延伸</b>，考察人对事物的理解，以及灵活变通的能力。2Sum有好多变体，包括3sum，4sum等等。3sum可以枚举第一维，对后两维使用2sum做法。

<hr>

16 3Sum Closest

题意：类似3sum，但要求返回一个三元组(i, j, k)使得元素和<b>最接近</b>目标值target。

难度：medium

解法：3sum的变体，和之前方法完全一样，只是更新答案的比较条件有所变化而已。从判断相等改为了<b>判断更为接近</b>。

<hr>

17 Letter Combinations of a Phone Number

题意：给定老式的手机9键键盘，把一串数字翻译成所有可能的字母映射。

难度：medium

解法：按部就班，直接搜即可。

<hr>

18 4Sum

题意：2sum的变体，这次是4个元素相加等于target，要求返回所有可能的组合。

难度：medium

解法：其实还是类似，枚举的维度多了一维，剩余的维度还是按2sum做法搞定。比如你可以左右各一维进行枚举，中间两维进行2sum。方法很多，灵活掌握。

<hr>

19 Remove Nth Node From End of List

题意：给定单链表，删除倒数第n个节点并返回表头。

难度：medium

解法：传统链表题，主要考察仔细一遍过的能力，注意边界case。

<hr>

20 Valid Parentheses

题意：给定括号序列，可能包括大中小括号的混合，判断是否是一个开闭匹配的合法序列。

难度：easy

解法：入栈出栈即可。

<hr>

21 Merge Two Sorted Lists

题意：给定两个有序链表，合并为一个，返回表头。

难度：easy

解法：水题。

<hr>

22 Generate Parentheses

题意：给定长度n，请生成所有不同的，长度为n的，合法的小括号序列。

难度：medium

解法：结果个数是卡塔兰数，至于生成，用记忆化搜索+递归的方法可以完成，且效率可接受。

<hr>

23 Merge k Sorted Lists

题意：给定k个有序链表，合并为一个有序链表，返回表头。

难度：hard

解法：虽然标记为hard，其实思路并不难。保证每次取最小元素的效率即可，因此使用<b>最小堆</b>，不断把k个表头往里放并总是取出当前值<b>最小的表头</b>。

<hr>

24 Swap Nodes in Pairs

题意：给定链表，按每两个元素一对，进行交换。返回表头。

难度：medium

解法：按部就班，注意边界case即可。

<hr>

25 Reverse Nodes in k-Group

题意：和上面的交换两个节点类似，这次是每k个节点一组进行反转。返回表头。

难度：hard

解法：按部就班，多多注意边界case。

<hr>

26 Remove Duplicates from Sorted Array

题意：给定有序数组，<b>去重</b>并把剩余的元素依次往前放，返回剩余元素个数。

难度：easy

解法：解法比讲清楚题意还简单的一道题。

<hr>

27 Remove Element

题意：给定数组，去掉其中所有值为val的元素，并把剩余元素依次往前放，返回剩余元素个数。

难度：easy

解法：水题。

<hr>

28 Find the Index of the First Occurrence in a String

题意：实现strstr，即字符串匹配的功能。

难度：easy

解法：<b>字符串匹配</b>是最最最经典的问题之一，有Sunday、BM、KMP还有多模式匹配的AC自动机等神奇算法。这个题要求比较低，所以暴力匹配也能接受。

<hr>

29 Divide Two Integers

题意：给定两个整数，返回整除结果，但不能用 * / %运算。

难度：medium

解法：很有意思的一题，<b>绑手绑脚还要秀功夫</b>的类型。我专门看了一眼自己当年的代码，一分钟还没理解到底在干嘛。又看了一遍，发现是用类似<b>位运算和除法器</b>（学过数字电路的话肯定就懂了）的思路去做除法。

<hr>

30 Substring with Concatenation of All Words

题意：给定一个长字符串s，和一组<b>长度相同</b>的单词words。找出所有s的子串，使得这些子串恰好等于words中的<b>全部单词</b>以<b>任意顺序</b>拼接起来。返回这些子串的<b>起始下标</b>。

难度：hard

解法：确实比较hard，放下现在算是medium hard。从数据规模，不允许暴力搜索。考虑用滑动窗口+统计出现字符串出现次数的方法。当年用cpp写，还设计了个非常蹩脚的字符串哈希函数，导致代码读起来很费劲。如果用py重写，两个Counter对象就搞定了。我看了大概五分钟才看明白当年的代码想表达什么。

<hr>

31 Next Permutation

题意：给定一个<b>无序且可能有重复元素</b>的数组，返回按<b>字典序</b>的下一个排列。要求就地完成，不复制数组。

难度：medium

解法：总归是个O(n)时间的操作，因为挪动数组元素是线性时间的。

<hr>

32 Longest Valid Parentheses

题意：给定一个小括号序列，返回其中能找到的最长合法序列的长度。

难度：hard

解法：难度是hard，规模上不允许O(n^2)的直白解法。既然是<b>括号匹配</b>，必然想到用栈。但一个栈可以作为数组用，却无法给你快速查找某个值的功能。因此换了一个比较巧的做法，用一个<b>计数</b>表示栈大小，同时用一个<b>哈希表</b>来存放内容，这样就能快速查找并更新内容了。所以这也<b>不能算是个栈</b>，但思路还是用了栈。

<hr>

33 Search in Rotated Sorted Array

题意：一个有序数组经过了（也可能没有）循环移位，请找出target值所在的下标。

难度：medium

解法：和那个“两个有序数组求中位数”一样，属于经典的<b>脑洞题</b>。直白解法很直白，但最高效解法你可能就是想不出来，这种类型的坑货题在LeetCode上还有十几题，散落在各处。二分做法反正我第一次费了很大劲才想出来，<b>自愧不如</b>。我也很难用一句话描述清楚怎么<b>独立想出来这种鬼点子</b>，因为我<b>做不到</b>。

<hr>

34 Find First and Last Position of Element in Sorted Array

题意：给定有序但可能有重复元素的数组，找出某个值target的起始和终止位置。

难度：medium

解法：二分查找，其实就是bisect_left和bisect_right的定义。

<hr>

35 Search Insert Position

题意：给定有序数组，要插入一个新值，请找出应该插入的位置。

难度：easy

解法：二分查找。

<hr>

36 Valid Sudoku

题意：三阶数独，9x9的那种。这次只需要检查一个填法是否合法而已。

难度：medium

解法：按数独的规则记录和检查即可。每行1-9，每列1-9，每个3x3小方格1-9。

<hr>

37 Sudoku Solver

题意：三阶数独，9x9的那种。这次要你用算法来填了。

难度：hard

解法：倒是算个hard，不过按部就班地使用<b>搜索+回溯</b>的方法，其实也不算难。如果一定要求用神奇的<b>Dancing Links算法</b>去做，我还是放弃吧。其实这辈子估计也没打算学会这个算法。

<hr>

38 Count and Say

题意：给定初始字符串“1”，使用游程编码（RLE）的方式不断把这个字符串“读书来”，并用读的结果替换原字符串。如此重复n-1次，返回最终结果。

难度：medium

解法：按部就班，模拟题。

<hr>

39 Combination Sum

题意：给定一个无重复元素的候选集合，找出所有加起来和为target的不同组合，返回全部组合。

难度：medium

解法：非常经典的<b>搜索题</b>，注意设计好递归函数，处理边界case即可。第一次写这种递归代码容易晕，写多了就能找出比较简洁的方式。注意适当<b>剪枝</b>，提高效率。

<hr>

40 Combination Sum II

题意：组合求和的变体，候选集合是可以有重复元素的。

难度：medium

解法：思路完全一样，就是改用一个map计数器来代替set，因为可以有重复值，需要统计每个值当前用了多少次。

<hr>

41 First Missing Positive

题意：给定一个长度为n的无序数组，请找出<b>不在数组中的</b>最小的<b>正整数</b>。要求不能用额外数组或存储结构做记录。

难度：hard

解法：这好像是一道近乎脑筋急转弯的<b>小聪明式的算法题</b>，要求做一件很直白的事，但不能用额外空间。个人非常反感这类<b>“专考聪明人”</b>的题。你得不到任何训练，且每一个这种题都<b>独一无二</b>，没什么规律可言。这题想要省空间，其实就是<b>直接把原数组当成一个bool数组用</b>，在上面叠一层True or False标记，来记录1-n是否都出现过了。如果你做不出来或者想不到，<b>不用有任何失望</b>。这不代表你不聪明，只代表你此时此刻在这道题上不聪明，和过去、和未来毫无关系。

<hr>

42 Trapping Rain Water

题意：给定一个高高低低的一维地形，雨水可以存在各种地势低洼处，给定无穷多的雨量，问总共能存下多少水。

难度：hard

解法：<b>接雨水</b>，这个是LeetCode名梗之一了，二维接雨水也被视为算法题里嘲讽功能最强的题目之一。这种题目虽然很精妙，但也因为其费脑、解法五花八门且实在没什么鸟用，而被视为浪费脑细胞的最佳途径。一维接雨水其实还好，可以视为传统的O(n) DP题。这个hard当年确实费了很多人的脑细胞，而且也很经典。<b>二维接雨水</b>还要离谱的多。

<hr>

43 Multiply Strings

题意：大数乘法，但是用字符串表示的大数。

难度：medium

解法：按部就班，不过对数据格式做一下转换，注意别出错即可。

<hr>

44 Wildcard Matching

题意：通配符匹配，和正则匹配类似，但要求实现?和*匹配功能。

难度：hard

解法：<b>比正则匹配简单</b>，但也算名副其实的hard问题。难度主要在把事情想清楚，代码其实很短。

<hr>

45 Jump Game II

题意：给定一个长度为n的数组nums，你从0位置出发，每次从i位置最多可以往前跳nums[i]步，问最远能到哪儿。

难度：medium

解法：跳数组系列问题中比较简单的一题，这系列有好多个变体。只要<b>每前进一步</b>，不断更新<b>当前能跳到的最远位置</b>即可。

<hr>

46 Permutations

题意：给定无重复元素的数组，返回它的所有不同排列方式。

难度：medium

解法：最直接的思路其实是先排序，然后不断使用<b>next permutation</b>找到下一个排列，直到<b>找不到（也就是变成倒序了）为止</b>。另一种思路就是搜索+记录排列的方式。前者更直观，代码也更好写。

<hr>

47 Permutations II

题意：和上题一样，返回所有排列，但这次数组可能有重复元素。

难度：medium

解法：我还是选择next permutation，这个无所谓重复元素。

<hr>

48 Rotate Image

题意：给定一个n x n矩阵，顺时针旋转90度。

难度：medium

解法：按部就班，注意奇偶情况的处理。

<hr>

49 Group Anagrams

题意：给定一组字符串，把互为anagram的词归到一个组里。

难度：medium

解法：<b>anagram</b>没有中文叫法，只能叫“同字母异序词”。对anagram的处理就是<b>排序之后统一比较</b>，相等就是anagram。

<hr>

50 Pow(x, n)

题意：给定整数x和n，都可以是负数，求x的n次方。

难度：medium

解法：快速幂，二分法。

<hr>

51 N-Queens

题意：N皇后问题，在n x n棋盘上放置n个皇后，不能存在同行、同列、同对角线、同反对角线的情况。返回所有摆法。

难度：hard

解法：这是算法和数据结构课的教科书例子了，可以说是<b>搜索+回溯</b>的教材。

<hr>

52 N-Queens II

题意：N皇后问题，并不能算变体。这次只需要返回解的个数。

难度：hard

解法：搜索+回溯。

<hr>

53 Maximum Subarray

题意：给定数组，求出其中最大的子数组和，返回和。

难度：medium

解法：<b>贪心策略</b>的最经典例子之一。累加并更新最大值，如果累加和为负数，就直接放弃，重置为0。

<hr>

54 Spiral Matrix

题意：给定m x n的矩阵，按照顺时针螺旋方式从外向内遍历。

难度：medium

解法：模拟题，逐字逐句照做即可。

<hr>

55 Jump Game

题意：给定一个长度为n的数组nums，你从0位置出发，每次从i位置最多可以往前跳nums[i]步，问能不能跳到最后一格。

难度：medium

解法：思路和Jump Game II完全一样，为什么这个的题号反而在后面？

<hr>

56 Merge Intervals

题意：给定一些用[x, y]表示的区间，将其进行合并，使得结果中的区间互不重叠。

难度：medium

解法：按<b>先首后尾</b>的顺序进行<b>排序</b>，然后逐个进行合并处理。python的<b>元组默认顺序</b>是个很有用的特性，可以处理很多这类问题。

<hr>

57 Insert Interval

题意：给定一组有序且互不重叠的区间，插入一个新区间[x, y]并进行适当的合并，使得结果依然有序且互不重叠。

难度：medium

解法：和上面的合并区间同一思路，二分找到插入位置，然后逐个合并，直到无需合并为止。

<hr>

58 Length of Last Word

题意：给定一个句子，找出最后一个词的长度。

难度：easy

解法：水题。

<hr>

59 Spiral Matrix II

题意：给定n x n的方阵，按照顺时针由外向内的方式，螺旋遍历这个矩阵，并把1到n^2依次填入每个每个位置。返回结果方阵。

难度：medium

解法：和前面的螺旋遍历一样，模拟题照做即可。

<hr>

60 Permutation Sequence

题意：给定整数n，{1, 2, ..., n}可以组成n!个不同排列。给定整数k，请求出<b>字典序排第k</b>的排列。

难度：hard

解法：<b>组合数学题</b>。可以按<b>子问题</b>逐个考虑。当第1位固定，剩下的n-1位则有(n-1)!种不同排列。逐个往下减，最后一位减完了，整个排列就确定了。

<hr>

61 Rotate List

题意：对一个单链表进行循环右移k次，返回表头。

难度：medium

解法：对k的一些特殊情况处理一下，剩下小心完成即可。可以通过<b>反转数组</b>的方式实现<b>循环移位</b>。[a...a b...b]，先反a，再反b，最后反全部，结果就等效于循环移位。

<hr>

62 Unique Paths

题意：给点m x n矩阵，你从(0, 0)出发，每次只允许向右或者向下，请问到达(m - 1, n - 1)有多少种方法。

难度：medium

解法：其实是个<b>纯数学题</b>，可以用<b>组合公式</b>直接求。但依然可以用土办法，开个二维数组进行累加。组合公式多数人不一定记得住，或者现场推也推不清楚，不必强求。这个应该就是著名的<b>杨辉三角</b>了，二项式定理。

<hr>

63 Unique Paths II

题意：Unique Paths的变体，但这次矩阵中存在无法通过的障碍格子。求到达(m - 1, n - 1)的路径个数。

难度：medium

解法：这次不能套数学公式了，还是用之前相同的办法，<b>二维数组</b>统计个数。

<hr>

64 Minimum Path Sum

题意：给定一个m x n矩阵，每个格子有一个值。从(0, 0)出发，每步只允许向右或向下，到达(m - 1, n - 1)。求可能累加得到的最小路径和。

难度：medium

解法：非常典型且直白的DP题。既然只能<b>右和下</b>，那就在<b>左和上</b>里找一个较小的值即可，这样最后得到的就是最小的路径和。

<hr>

65 Valid Number

题意：给定字符串，判断是否是一个有效的整数、小数或者科学计数法表示的数。

难度：hard

解法：难度全在于是否<b>够仔细，够严谨，够耐心</b>。能一次过这种题的，反正我挺难想象的。<b>边界case</b>多的出奇。

<hr>

66 Plus One

题意：给定用数组表示的一个大数，对其执行+1操作。

难度：easy

解法：没有难度，就是注意进位的情况。

<hr>

67 Add Binary

题意：两个字符串表示的大数相加，二进制。

难度：easy

解法：十进制，二进制，没什么大区别。

<hr>

68 Text Justification

题意：给定一系列单词，要求在<b>保持单词顺序</b>的情况下，按照一个最大宽度进行逐行排版。最终得到的<b>每行总宽度相同</b>，且每行内的单词间空格要尽可能均匀。这个其实就是我们常见的<b>“分散对齐”</b>功能。

难度：hard

解法：难度主要在于要求比较多，费事，实现每一步倒是不难。小心完成即可。

<hr>

69 Sqrt(x)

题意：给定非负整数，求它的平方根，结果<b>向下取整</b>。

难度：easy

解法：二分查找。

<hr>

70 Climbing Stairs

题意：从0级台阶开始，每次允许向上1级或者2级，求到达第n级台阶的方法有多少种。

难度：easy

解法：Fibonacci数列。

<hr>

71 Simplify Path

题意：给定一个“/”分割的文件路径，可能存在“.”和“..”这样的相对路径。求简化后的<b>绝对路径</b>。

难度：medium

解法：解析路径，用栈处理一下，然后拼回完整路径即可。

<hr>

72 Edit Distance

题意：给定两个字符串s和t，求其最短编辑距离。一次编辑包括<b>增、删或改一个字符</b>。

难度：medium

解法：教科书里讲<b>动态规划</b>的经典例子，DP。编辑距离还有个专有名词，叫“Levenshtein distance”。

<hr>

73 Set Matrix Zeroes

题意：给定一个01矩阵，如果某个元素值为0，就把它对应的整行和整列都设为0。要求对所有元素同时做这个操作，且<b>就地完成</b>，不使用额外的矩阵。

难度：medium

解法：挺巧妙的一题，难度当然是<b>就地完成</b>了，否则直接记录一下再处理就很简单。使用第0行和第0列作为标记，再单独用两个变量r0和c0记录0行和0列本身是否有0，这样就<b>有地方做记录</b>了。起码没要求我<b>一个变量也不能用</b>，对吧？

<hr>

74 Search a 2D Matrix

题意：给定一个m x n矩阵，每行向右都是递增的，且下一行的第一个元素都大于上一行末尾。请设计一个高效算法在其中查找目标值是否存在。

难度：medium

解法：注意，这个并不是<b>Young tableau</b>，只是一个有序的一维数组被变形成了二维。把它还原成一维，进行常规的二分查找即可。

<hr>

75 Sort Colors

题意：给定一个包含红白蓝三色的数组，要求<b>就地进行排序</b>，得到红、白、蓝顺序的结果。

难度：medium

解法：既然只有三种颜色，那就把红、蓝<b>往两边放</b>好了，以<b>交换</b>的方式实现。我记得很清楚，当时很讨厌这种<b>“自废武功”</b>式的题目，一边这也不让那也不让，一边又要你做这做那。

<hr>

76 Minimum Window Substring

题意：给定长串s和短串t，请找出<b>长度最短</b>，但<b>包含了t中所有字母</b>的s的子串。t可能有重复字母，所以要在个数上包含。

难度：hard

解法：放在现在是很标准的medium了，<b>滑动窗口题</b>。甚至题目里都提示了window。<b>滑动、计数、判断，再滑动</b>。这会成为一个标准的统计手法，后面经常用到。

<hr>

77 Combinations

题意：给定正整数n和k，返回从1-n中选k个数的所有不同<b>组合</b>。

难度：medium

解法：搜索即可。

<hr>

78 Subsets

题意：给定一个无重复元素的数组（其实就是集合），返回它的所有子集（其实就是幂集）。

难度：medium。

解法：搜索即可。

<hr>

79 Word Search

题意：给定一个m x n矩阵，每一格有一个字母。给定一个目标字符串word，从任意位置出发，上下左右走不重复的格子，对应序列是否能组成word？

难度：medium

解法：<b>搜索+回溯</b>，成功就结束，失败就回溯。

<hr>

80 Remove Duplicates from Sorted Array II

题意：有序数组就地去重，但是重复元素<b>至多保留两个</b>，而不是一个。

难度：medium

解法：大同小异，往前挪的时候，留两个位置即可。

<hr>

81 Search in Rotated Sorted Array II

题意：和之前Search in Rotated Sorted Array类似，一个有序数组经过了（也可能没有）循环移位，但这次数组可能有<b>重复元素</b>。在其中查找一个目标值target。

难度：medium

解法：依然二分，但因为重复值的存在，可能需要做一些+1、-1的O(n)操作，因此<b>最坏时间是线性</b>，最优时间是对数。

<hr>

82 Remove Duplicates from Sorted List II

题意：给定有序单链表，把存在重复值的对应节点<b>全部去掉</b>，只留下无重复值的节点。

难度：medium

解法：注意读题，<b>不是去重</b>，而是有重复的直接全删了。

<hr>

83 Remove Duplicates from Sorted List

题意：给定有序单链表，去重并返回表头。

难度：easy

解法：这个是去重，标准操作。

<hr>

84 Largest Rectangle in Histogram

题意：给定一个高高低低的直方图，每格的宽度是1，求在其中能画出的<b>最大的矩形面积</b>是多少。

难度：hard

解法：很经典也很著名的一道面试题，DP解决。主要思路就是对每个位置，看看<b>往左、往右</b>能找到多少个<b>连续的，高于它的位置</b>。因为必须<b>更高才能继续扩展这个矩形</b>。算好左右宽度之后，乘以高就是<b>面积</b>。

<hr>

85 Maximal Rectangle

题意：给定一个01矩阵，允许在其中<b>框一个矩形</b>，要求其中<b>所有元素都是1</b>。求这个矩形框的最大面积。

难度：hard

解法：相当巧妙的一题，其实就是上一题，<b>直方图矩形面积</b>的变体。我当时花了10多分钟才想到。每往下扫一行，直方图的数据就更新一次。当然，<b>遇到0的时候</b>，直方图的对应列就归零了。

<hr>

86 Partition List

题意：给定一个链表和一个值x，对节点进行划分，使得小于x的元素在前，大于等于x的在后。两组节点的<b>内部顺序</b>要和之前保持一样。

难度：medium

解法：题目已经暗示得很明显了，<b>按顺序</b>一个个分类，两条链表再拼起来即可。

<hr>

87 Scramble String

题意：给定一个长度大于1的字符串s，可以随机选取一个位置切分为两个子串x + y，并将两串交换，变为s' = y + x，称为一次“乱序”。乱序操作可以<b>对子串递归执行</b>。当对一个字符串s递归执行<b>任意次乱序操作</b>后，能否将其变为字符串t？

难度：hard

解法：第一念头当然是DP或者搜索，但既然是hard难度，一定要在效率上有所考虑。其实DP还是搜索没有本质区别，都是对<b>子问题</b>的表达方法。搜索如果效率不达标，也需要<b>记忆化</b>的办法去提高效率。最后我还是选了DP，对s和t的不同位置的<b>同长度子串</b>进行匹配。循环层数比较多，注意不要搞晕了。

<hr>

88 Merge Sorted Array

题意：有序数组归并，但这次<b>数组1</b>中留了足够的位置给你。

难度：easy

解法：水题。

<hr>

89 Gray Code

题意：格雷码，一种很神奇的编码方式。任意相邻的两个代码（包括第一和最后）之间都只有1位不同。给定长度n，请生成一种合法的n位格雷码编码。

难度：medium

解法：<b>递归</b>的完美例子，你用脑子硬想格雷码，肯定想不明白。但想一想n和n-1之间的关系，代码就很容易写出来。递归是一种非常<b>反直觉</b>的思维方式，但又极其优雅，很能体现数学的魅力。你把n-1位格雷码反转过来，开头都加个“1”，再拼起来不就是n位格雷码。

<hr>

90 Subsets II

题意：还是求集合的幂集，但这次元素可能有重复，相当于数学上的multiset。

难度：medium

解法：依然是搜索，这次有重复元素，改用map代替set来进行计数。

<hr>

91 Decode Ways

题意：按照1-26对应A-Z的编码方式，给定一个<b>数字串</b>，请求出有多少种不同的翻译方式来<b>翻译成字母</b>。

难度：medium

解法：线性DP，无序使用数组，只记录最近两三个位置的结果即可。

<hr>

92 Reverse Linked List II

题意：给定单链表和left、right位置，将[left, right]位置内的部分链表反转，并返回表头。

难度：medium

解法：注意处理各种<b>边界case</b>即可，只求仔细。

<hr>

93 Restore IP Addresses

题意：给定一个数字串，允许在其中插入“.”，请返回能得到的所有<b>有效IP地址</b>。

难度：medium

解法：一边搜一边插入点，检查有效性即可。

<hr>

94 Binary Tree Inorder Traversal

题意：给定二叉树，求中序遍历。

难度：easy

解法：这是必知必会了，<b>前中后序遍历</b>。用栈来<b>模拟递归</b>，也属于不算很难的东西。但我记得还有个非常诡异且偏难怪的<b>O(1)空间遍历</b>，那个我至今也没学会。好像和教材里讲过的“线索树”有关。

<hr>

95 Unique Binary Search Trees II

题意：给定值1-n，请问可以组成多少种不同结构的n节点二叉搜索树。返回所有树。

难度：medium

解法：其实这和括号匹配一样，都是卡塔兰数的例子。搜索记录即可，这个规模是<b>阶乘级</b>的，n不可能给到很大，C(n) = (2n)! / ((n + 1)! n!)。

<hr>

96 Unique Binary Search Trees

题意：给定值1-n，请问可以组成多少种不同结构的n节点二叉搜索树。只需要返回个数。

难度：medium

解法：就是<b>卡塔兰数</b>，标准的，原封不动的，C(n) = (2n)! / ((n + 1)! n!)。

<hr>

97 Interleaving String

题意：给定字符串s1、s2、s3，判断s3是否可以由s1、s2的字符<b>按次序穿插组成</b>。

难度：medium

解法：穿插，也就是把s2的字符<b>依次分散插入</b>s1，或者s1分散插入s2（同理）。使用两个指针逐个判断s3的当前字符是否和其中一方匹配，一步步往前。但是，<b>这个思路是错的</b>。虽然很直观，但行不通。需要用DP解决，贪心策略不对。从这点看，这题其实挺hard，属于medium里比较坑人的。

<hr>

98 Validate Binary Search Tree

题意：给定一个二叉树，判断它是不是一个二叉搜索树。

难度：medium

解法：按定义来即可，对<b>每个位置</b>，判断<b>左子树最右</b>和<b>右子树最左</b>是不是分别小于、大于根节点。

<hr>

99 Recover Binary Search Tree

题意：给定一个二叉搜索树，有两个节点的位置被交换了，请在不改变节点指向的情况下，找到两个值并换回来。

难度：medium

解法：挺巧妙且有点难的一题。利用<b>BST的中序遍历结果有序</b>这个特点，如果乱序了，这个地方一定有节点被换了。记录下<b>发现乱序</b>的位置，做交换。要注意两个点<b>恰好相邻</b>和<b>不相邻</b>两种情况

<hr>

100 Same Tree

题意：给定两个二叉树，判断它们是否完全相同。

难度：easy

解法：递归比较即可。
