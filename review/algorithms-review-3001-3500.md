# LeetCode 一句话题解 - 3001-3500

[返回目录](./README.md)

- [LeetCode 一句话题解 - 3001-3500](#leetcode-一句话题解---3001-3500)
  - [3001 - 3100](#3001---3100)
  - [3101 - 3200](#3101---3200)
  - [3201 - 3300](#3201---3300)
  - [3301 - 3400](#3301---3400)

代码库地址：  
[https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/3001-3500](https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/3001-3500)

## 3001 - 3100

3005 Count Elements With Maximum Frequency

题意：给定数组nums，求出<b>频率最大</b>的元素的<b>频率之和</b>。

难度：easy

解法：水题。

<hr>

3010 Divide an Array Into Subarrays With Minimum Cost I

题意：给定数组nums，将其划分为3个子数组。每个数组的代价是<b>第1个元素</b>的值。请求出<b>最小总代价</b>。

难度：easy

解法：`nums[0]`必选，然后从`nums[1:n]`中找出<b>最小的两个值</b>。加起来就是答案。

<hr>

3011 Find if Array Can Be Sorted

题意：给定数组nums，如果两个相邻元素`(nums[i],nums[i+1])`二进制有<b>相同的1个数</b>，则允许交换它们。请问能否经过任意次交换，使得nums变成升序？

难度：medium

解法：先写一个`countOnes()`函数，统计1的个数。相邻交换，那么交换完了<b>还是相邻</b>。也就是说，不论你怎么交换，都是在一个<b>连续的局部范围内</b>。因此，我们可以按照相同的1个数，把nums分成多个<b>连续小组</b>。每个小组内，你都可以<b>升序排列</b>。如果<b>每个小组</b>排序完了之后，<b>整个数组也有序</b>，那就true；否则，false。这题算<b>半个智力题</b>，半个算法题。

<hr>

3014 Minimum Number of Pushes to Type Word I

题意：老式的9键手机键盘，见过吧？类似那种`2->abc`的映射。现在允许你把`a~z`自由分配到`2~9`上，得到一个<b>多对一映射</b>。请设计一个映射，使得输入单词word的<b>按键次数</b>最少。

难度：easy

解法：题目讲得挺啰嗦，但用过<b>九键键盘</b>的人，很容易想明白。比如`2->abc`，那么输入a按1次`2`，输入c则按3次`222`。因此，我把word里的字符尽量<b>分散放在第一位</b>，这就是最优的。如果还有多的，就分散放到第二位，依此类推。这题算是<b>模拟题</b>。

<hr>

3015 Count the Number of Houses at a Certain Distance I

题意：给定n个房子，顺着排成一排，编号`1~n`。每个`[i,i+1]`之间有一条<b>双向边</b>。除此之外，还有一条`[x,y]`双向边。给定`k=[1,n]`，请求出<b>两点最短距离等于k</b>的`(x,y)`的对数。

难度：medium

解法：直接按<b>全最短路径</b>处理就行，跑一个<b>Floyd算法</b>。不过，既然在链式的基础上，只额外添加了<b>一条边</b>，这题肯定有什么<b>巧妙解法</b>。反正我没想出来。看了评论区，好像也没有。

<hr>

3016 Minimum Number of Pushes to Type Word II

题意：3014的变体。题目<b>完全一样</b>，只有数据量不同。

难度：medium

解法：又是<b>改个数据量</b>就算两题的情况。好吧，题目虽然照抄，解法<b>并不完全一样</b>。我们按照字符频率，做个<b>倒序排列</b>。剩下就和3014一样。

<hr>

3019 Number of Changing Keys

题意：给定字符串s，统计`s.lower()`中，字符发生变化的次数。

难度：easy

解法：水题，注意理解题目。比如`abBDdaa`，变化了3次。

<hr>

3024 Type of Triangle

题意：给定三条边长，请判断<b>等边、等腰</b>还是普通三角形。

难度：easy

解法：水题。

<hr>

3028 Ant on the Boundary

题意：一只蚂蚁从0点出发，给定数组nums，每次移动`nums[i]`单位。请求出蚂蚁返回0点的次数，<b>路过不算</b>。

难度：easy

解法：水题，啰嗦且充满迷惑性。

<hr>

3033 Modify the Matrix

题意：给定m x n矩阵mat，把所有-1值的位置，替换为<b>本列的最大值</b>。

难度：easy

解法：水题，不过我读了两遍才搞明白<b>到底在问什么</b>。

<hr>

3034 Number of Subarrays That Match a Pattern I

题意：给定数组nums和一个模式数组pattern。pattern的元素按照`-1、0、+1`表示`降、等、升`。请找出nums中，符合pattern对应模式的子数组的个数。

难度：medium

解法：这题有点意思，既然我们关心的是<b>相邻元素</b>的比较，那我们先进行比较，得到一个`n-1`长的比较数组diff，其中也按照`-1、0、+1`这样取值。然后我们对diff和pattern做字符串匹配即可。没错，就是<b>KMP</b>那样的匹配。显然，与其手写KMP，不如用<b>正则</b>直接搞定。你可以把diff和pattern数组都转为<b>字符串格式</b>，这样就方便调用re模块了。这题出得很好，好在既有<b>算法难度</b>，又考察做事的<b>灵活性</b>。总代价`O(n+np)`。<b>重叠匹配</b>的写法可以记一下，有点巧妙，`re.findall(r'(?=(p))', s)`。

<hr>

3038 Maximum Number of Operations With the Same Score I

题意：给定数组nums，每次删除<b>开头两个元素</b>，并求和作为<b>分数</b>。持续删除，但是要求每次得到的<b>分数必须相同</b>。请求出能执行<b>几次操作</b>。

难度：easy

解法：水题。

<hr>

3039 Apply Operations to Make String Empty

题意：给定`a~z`组成的字符串s，每一轮，我们都找出`a~z`字符的<b>第一个出现位置</b>并删除。经过若干次，可以把s删光。请求出<b>最后一次</b>删除之前，s的值。

难度：medium

解法：这题很简单，你既然每次都是<b>删除“第一个”</b>，那么最后一个自然就是<b>最后删的</b>。我们找出`a~z`每个字符的<b>最后出现位置</b>，按次序拼起来。注意，只保留`频率==max(频率)`的字符。因为频率更小的字符，之前已经删光了，<b>不会留到最后</b>。

<hr>

3042 Count Prefix and Suffix Pairs I

题意：给定词表words，请求出`i<j`的对数，使得`words[i]`同时是`words[j]`的<b>前缀和后缀</b>。

难度：easy

解法：数据量很小，直接`O(n^2)`枚举即可。

<hr>

3043 Find the Length of the Longest Common Prefix

题意：给定两个整数数组arr1、arr2，请找<b>按数位算</b>，所有`(arr1[i],arr2[j])`的<b>最长公共前缀</b>。返回<b>长度</b>。

难度：medium

解法：这题直白的思路就是<b>枚举ij</b>，复杂度是`O(n1*n2)`。数据量告诉你太慢了。怎么优化呢？可以把所有整数都转为字符串，然后<b>存入字典树</b>中。再给字典树加一个arr1、arr2的<b>访问标记</b>。如果某个节点同时具有两个标记，则是一个有效的公共前缀。我们遍历字典树的所有节点，找出<b>具有两个标记</b>的<b>最深节点</b>，就等于找到最大长度了。这样的处理代价，对于<b>时间空间</b>，都是`O(nlogn)`。<b>实现麻烦</b>，但思路还比较容易。还有一种<b>更巧妙的办法</b>，我们把arr1和arr2的值都转为字符串，然后<b>混在一起</b>。按字典序<b>排序</b>，那么如果存在某个最长前缀，一定会发生在两个<b>字典序最接近</b>的<b>相邻元素</b>中。如此，我们只需要把排序后的所有相邻元素`(a[i],a[i+1])`进行比较，而且只比较其中<b>来源不同</b>的相邻元素。这个思路比字典树简单得多，总代价也是`O(nlogn)`。

<hr>

3046 Split the Array

题意：给定数组nums，请将其分为等长的两个数组nums1、nums2，要求两数组都没有<b>重复值</b>。请判断<b>能否做到</b>。

难度：easy

解法：水题，如果有一个值<b>出现超过2次</b>，就做不到。

<hr>

3065 Minimum Operations to Exceed Threshold Value I

题意：给定数组nums，每次你可以删除一个<b>最小值</b>。请问经过多少次，所有值都<b>不小于k</b>？

难度：easy

解法：水题，统计`<=k`的值的个数即可。

<hr>

3067 Count Pairs of Connectable Servers in a Weighted Tree Network

题意：有一个<b>树形的无向图</b>，表示服务器网络。n个点编号`0~n-1`，边的格式为`[x,y,w]`，表示<b>双向带权</b>的一条边。给定整数k，如果`a-c`的距离、`b-c`的距离都是<b>k的倍数</b>，且两<b>路径（可以由多条边构成）</b>没有共同的边，则称为<b>a和b通过c连通</b>。对于每个点`i=[0,n-1]`，请求出<b>通过i连通</b>的`(a,b)`对数。

难度：medium

解法：这是个<b>树形结构</b>，因此我们从某点i出发（作为根节点），通往任意j点的路径都是<b>唯一</b>的。那么，我们可以O(n)代价做一次遍历，统计出距离`dist%k==0`的个数。比如有`cc`个，那么对数就是`C(cc,2)=cc*(cc-1)/2`。对于每个点`i=[0,n-1]`，执行n次这样的遍历，总代价`O(n^2)`。这个思路不算复杂，但实现已经<b>挺麻烦了</b>。就这样吧，我想不出更好的办法了。

<hr>

3068 Find the Maximum Sum of Node Values

题意：有一个<b>树形的无向图</b>，n个点编号`0~n-1`，边的格式为`[x,y]`。每个点有分值`nums[i]`。现在你可以对任意边`[x,y]`执行一个操作，同时把`nums[x]`和`nums[y]`异或一个k值，也就是`^=k`。你可以执行<b>任意次操作</b>，请求出`max(sum(nums))`。

难度：hard

解法：这题其实是个<b>智力题</b>，而且需要按<b>图论的思维</b>先想一下才能发现。比如我对`[x,y]`执行操作，又对`[y,z]`执行操作，是不是<b>等价于</b>对`[x,z]`执行操作？发现了吗，这是<b>传递性</b>。因为一棵树，所有点都是连通的，因此我可以<b>随便传递</b>。也就是可以<b>任选两个元素</b>`(nums[i],nums[j])`，执行`^=k`的操作。那么我检查所有`nums[i]`，统计`nums[i]^k>nums[i]`的个数。如果偶数个，则<b>全部执行</b>；如果奇数个，则最后会<b>多余一个</b>。对多余的这个，还要和其他元素<b>尝试做一次</b>。如果结果变大了，那就做。这题属于中规中矩的hard，<b>脑力+体力并用</b>的一题。总代价`O(n)`。不得不说，这题的出题者，脑洞还是挺大的。

<hr>

3069 Distribute Elements Into Two Arrays I

题意：给定数组nums，你需要把它分成两个数组arr1、arr2。先把0和1元素分到arr1、arr2中。对于之后每个元素`nums[i]`，都把它分到<b>末尾元素更大</b>的那个数组中。最后返回`arr1+arr2`。

难度：easy

解法：水题。

<hr>

3070 Count Submatrices with Top-Left Element and Sum Less Than k

题意：给定m x n矩阵grid，所有元素<b>非负</b>。请求出左上是`(0,0)`，子矩阵和<b>不超过k</b>的所有<b>子矩阵个数</b>。

难度：medium

解法：直接用<b>二维前缀和</b>的思路，可以求出每个右下角为`(i,j)`的子矩阵和。`sm[i][j]=sm[i][j-1]+sm[i-1][j]+grid[i][j]-sm[i-1][j-1]`，总代价`O(mn)`。

<hr>

3071 Minimum Operations to Write the Letter Y on a Grid

题意：有一个n x n矩阵，n是奇数，表示一个<b>像素屏幕</b>。现在你需要画出一个<b>“Y”图案</b>。也就是右下、左下、下这三笔，而且<b>不能旋转</b>。已知屏幕上的像素点有0、1、2三种值。要求Y部分的像素必须取<b>同一值x</b>，非Y部分的像素必须取<b>同一值y</b>，且`x!=y`。每次你可以<b>修改一个像素</b>，请求出最小的修改次数。

难度：medium

解法：很麻烦的一道<b>模拟题</b>。统计<b>Y部分</b>的012个数，再统计<b>非Y部分</b>的012个数。然后选一个<b>修改总和最小</b>的`(x,y)`组合。没有难度，单纯就是麻烦，总代价`O(n^2)`。

<hr>

3074 Apple Redistribution into Boxes

题意：有n包苹果，每包有`apple[i]`个。有m个箱子，每个容量为`capacity[j]`。你需要把苹果撞到箱子里，用尽可能少的箱子。如果苹果包<b>可以拆开</b>，请求出最少的箱子个数。

难度：easy

解法：水题。`sum(apple)`，`capacity.sort(reverse=True)`，然后看看几个箱子能<b>装完</b>。

<hr>

3075 Maximize Happiness of Selected Children

题意：给定n个小朋友，每个的快乐值是`happines[i]`。你需要选k个，每次选择，所有未被选中的小朋友，<b>快乐值`-1`，至多减到0</b>。请求出k人的<b>最大快乐值总和</b>。

难度：medium

解法：显然，按`happiness`<b>降序排列</b>，答案就是最优的。我不知道这题为什么是medium，这个贪心思路<b>100%符合直觉</b>，很容易想到。总代价`O(nlogn)`。

<hr>

3079 Find the Sum of Encrypted Integers

题意：给定nums，把每个元素`nums[i]`的每一位，都换成它的最大位。返回<b>总和</b>。

难度：easy

解法：水题。

<hr>

3083 Existence of a Substring in a String and Its Reverse

题意：给定字符串s，请找出在`s、reverse(s)`中都存在的<b>长度为2</b>的子串。只判断<b>是否存在</b>即可。

难度：easy

解法：水题。

<hr>

3090 Maximum Length Substring With Two Occurrences

题意：给定字符串s，请求出<b>每种字符不超过2个</b>的最长子串的长度。

难度：easy

解法：滑动窗口+双指针，这都<b>贬值到easy难度</b>了？厉害。

<hr>

3095 Shortest Subarray With OR at Least K I

题意：给定数组nums，请找出其中<b>最短的</b>，异或结果`>=k`的子数组的长度。不存在则返回-1。

难度：easy

解法：数据很小，直接`O(n^2)`枚举即可。

<hr>

3097 Shortest Subarray With OR at Least K II

题意：3095的变体。和3095完全一样，就是<b>数据量不同</b>。

难度：medium

解法：我们需要一个`O(n)`的解法。想到一个<b>滑动窗口+双指针</b>的思路，但<b>有点巧妙</b>，因为你<b>不能直接用</b>滑动窗口。为什么？因为<b>按位或</b>这个操作是没有<b>直接逆运算</b>的。没有逆运算，你怎么<b>缩小窗口</b>。那怎么处理？我们可以<b>按位进行计数</b>，每当`0->1`时，则`^`异或一下；每当`1->0`时，也`^`异或一下。这个操作，就<b>等价于</b>给按位或执行了<b>逆运算</b>。这样，总体代价不再是`O(n)`，而是`O(nlog(int))`。至于双指针怎么滑动，很简单。我用i在前、j在后。i扩大窗口，使得`按位或>=k`；j缩小窗口，使得`按位或`<b>恰好</b>`>=k`。这样，得到的窗口就是<b>最小的</b>。这题确实<b>挺难</b>，我也不知道，我以前怎么想到这种<b>诡异思路</b>的。

<hr>

3099 Harshad Number

题意：给定整数x，如果`x%sumDigits(x)==0`，则称为<b>Harshad数</b>。如果是Harshad数，则返回<b>数位和</b>；否则返回-1。

难度：easy

解法：按定义，求<b>数位和</b>，看是否整除即可。

<hr>

3100 Water Bottles II

题意：1518的变体。你有nb瓶汽水，每次你可以用ne个空瓶子换1瓶汽水。但<b>每换1次</b>，则`ne+=1`。如果你可以自由安排<b>喝水、换瓶子的策略</b>，请求出能喝到的<b>最大瓶数</b>。

难度：medium

解法：还是<b>喝汽水、换瓶子</b>的问题。第一念头肯定是<b>模拟</b>，这题的数据量<b>确实很小</b>，直接模拟吧。纯模拟的总代价是`O(sqrt(nb))`。其实<b>数学解法</b>也不难，我们考虑nb和ne，那么我换瓶子的策略总是<b>攒够了就换</b>。于是，我按照`ne,ne+1,ne+2,...`这样求和，直到超过nb为止。等差数列求和，求个数，相当于<b>解一元二次方程</b>，代价为`O(1)`。持续模拟，至多`O(log(nb))`次就能完成。对于很大的`nb、ne`值，也能轻松解决。

## 3101 - 3200

3101 Count Alternating Subarrays

题意：给定01数组nums，对于一个子数组，如果没有相邻元素相等，则称为<b>交替子数组</b>。请求出交替子数组的个数。

难度：medium

解法：扫一次就行了，对于长度为cc的交替子数组，其中包含了`cc*(cc+1)/2`个。找出每段<b>最长的交替长度</b>，求和就是最终答案。总代价`O(n)`。

<hr>

3105 Longest Strictly Increasing or Strictly Decreasing Subarray

题意：给定数组nums，找出最长的<b>单调递增或单调递减</b>子数组的长度。

难度：easy

解法：扫一次就行了。总代价`O(n)`。可以针对递增、递减分别扫，也可以按照当前`(nums[i],nums[i+1])`的大小来决定<b>是递增还是递减</b>。总代价`O(n)`。

<hr>

3106 Lexicographically Smallest String After Operations With Constraint

题意：给定等长的字符串s和t，定义`dist(s,t)=sum(dist(s[i],t[i]))`。单个字符的距离，按照`a~z`的<b>循环最短距离</b>为准。比如`(a,b)`和`(a,z)`的距离都是1。现在给定s，请找出符合`dist(s,t)<=k`的<b>字典序最小</b>的t。

难度：medium

解法：字典序最小，显然你应该从<b>前面</b>开始变，而且要把字符<b>尽量变小</b>。这个可以按<b>贪心原则</b>处理。对于每个位置`s[i]`，如果<b>当前剩余距离</b>是cc，则考虑cc是否<b>足够</b>把`s[i]`变成`a`。如果够，就继续处理<b>下一个字符</b>；如果不够，那么这就是<b>最后一个变化</b>了。总代价`O(n)`。

<hr>

3110 Score of a String

题意：给定字符串s，请求出`sum(|s[i]-s[i+1]|)`。

难度：easy

解法：水题。

<hr>

3111 Minimum Rectangles to Cover Points

题意：给定一些点`[xi,yi]`，你需要用一些矩形来覆盖它们。每个矩形<b>左下角是都在x轴上</b>，右上角任意，但要求`宽度<=w`。点落在内部或者边缘，都算覆盖。请求出覆盖所有点，<b>最少</b>需要的矩形个数。

难度：medium

解法：其实这题是迷惑你的，y坐标根本无所谓，因为题目没有<b>对y做任何限制</b>，你可以认为`y=+inf`。我们只需要考虑<b>所有x坐标</b>，用多少个<b>不超过w宽度的区间</b>，可以包含进去。那么，首先对x坐标<b>升序排列</b>。对于每个起点`x[i]`，我都二分搜索`j=bisect_right(ax,x[i]+w)`。一直这样搜，搜到末尾为止。看总共搜了几段，就需要几个矩形。总代价`O(nlogn)`。<b>ij二分搜索</b>也可以改为<b>ij双指针</b>，结果是一样的，大同小异。

<hr>

3114 Latest Time You Can Obtain After Replacing Characters

题意：给定`HH:MM`格式的时间，<b>12小时制</b>。你需要把其中的`?`换成数字，请求可能得到的最晚时间。

难度：easy

解法：水题。

<hr>

3115 Maximum Prime Difference

题意：给定数组nums，请求出其中两个<b>质数元素</b>的<b>下标之差</b>的最大值。

难度：medium

解法：找出其中<b>所有质数</b>，记录下标。把`最后位置-最前位置`就是答案。其实，找出<b>第一个和最后一个</b>质数就行了。总代价`O(n*sqrt(max(nums)))`。

<hr>

3120 Count the Number of Special Characters I

题意：给定字符串word，如果某字母的大小写都出现了，则称为<b>特别字母</b>。请统计特别字母的个数。

难度：easy

解法：水题。

<hr>

3127 Make a Square with the Same Color

题意：给定一个3 x 3的BW方阵，B黑W白。你可以改变至多1个点的颜色，请问能否得到一个2 x 2的同色方阵？

难度：easy

解法：水题。

<hr>

3131 Find the Integer Added to Array I

题意：给定数组nums1、nums2，已知`sorted(nums1)`和`sorted(nums2)`对应元素都相差同一个值x，请求出x。

难度：easy

解法：水题。排序之后，`sorted_nums2[0]-sorted_nums1[0]`即可。

<hr>

3133 Minimum Array End

题意：给定整数n和x，你需要构造一个严格递增的数组nums。nums的长度为n，且`and(nums)==x`。请求出`nums[n-1]`的最小值。

难度：medium

解法：所有元素的<b>按位与</b>等于x，那么比如x是一个<b>二进制p位数</b>，其中有<b>q个0</b>。我为什么关心这个？因为我知道这些元素在`p-q`位上，必须全取1，在剩下的q位上，则<b>可0可1</b>。q位0，总共有`2**q`种组合。那么如果`n>2**q`，就<b>无解</b>了，因为这<b>不够用</b>。如果`n<=2**q`，我可以`0`枚举到`n-1`。但是我要做个<b>奇怪的事情</b>，就是把这q位数，<b>穿插</b>到<b>对应的位置</b>上去。比如举例子`1001100`，我把`1011`穿插到0位置上去，结果就是`1101111`。这样得到的`nums[n-1]`一定是<b>最小的</b>。总代价`O(logn)`。

<hr>

3136 Valid Word

题意：给定字符串word，请判断是否满足以下条件：至少3字符，只包含数字或字母，有至少一个元音和辅音。

难度：easy

解法：水题。

<hr>

3137 Minimum Number of Operations to Make Word K-Periodic

题意：给定字符串word，长度为n。给定整数k，且`n%k==0`，每次你可以位置`(i,j)`，执行`word[i:i+k]=word[j:j+k]`，也就是替换k长度的一个子串。请问至少多少次操作，能让word变为k周期串，也就是以k长度的子串<b>重复而成</b>。

难度：medium

解法：这题的题目描述很费劲，但读懂题目后会发现<b>其实很简单</b>。我们只要把k长度的子串，视为一个<b>“单值”</b>即可。那么，总共有`n/k`个这样的值，做<b>哈希计数</b>，找出最大频率`max_cc`。为了使所有`n/k`个值相同，我需要改变其他`n/k-max_cc`个值，这就是答案。总代价`O(n)`。

<hr>

3142 Check if Grid Satisfies Conditions

题意：给定m x n矩阵，请检查每一格`grid[i][j]`是否等于<b>下方一格</b>，是否不等于<b>右边一格</b>。请判断是否<b>每格</b>都满足这个条件。

难度：easy

解法：水题。

<hr>

3146 Permutation Difference between Two Strings

题意：给定<b>同一组字符集</b>的两个排列s和t。我们定义<b>排列差值</b>为每个字符在两串中<b>出现位置的差值</b>之和。请求出排列差值。

难度：easy

解法：按题目定义，用<b>哈希表</b>记录字符的<b>出现位置</b>，求差值并求和`sum(abs(ms[c]-mt[c]))`。总代价`O(n)`。

<hr>

3151 Special Array I

题意：给定数组nums，请判断所有<b>相邻元素对</b>，是否<b>奇偶性都不同</b>。

难度：easy

解法：水题。

<hr>

3158 Find the XOR of Numbers Which Appear Twice

题意：给定数组nums，请求出其中<b>出现了2次</b>的元素的<b>异或</b>。

难度：easy

解法：水题。

<hr>

3159 Find Occurrences of an Element in an Array

题意：给定数组nums和整数x，你需要执行m次查询，每次查询给出x值在nums中的第`queries[i]`次出现下标。次数<b>从1算起</b>。如果超出最大次数，则返回-1。

难度：medium

解法：把x的所有出现位置<b>记下来</b>就行了。这题定级medium不合适，思路过于简单了。总代价`O(n+nq)`。

<hr>

3162 Find the Number of Good Pairs I

题意：给定数组nums1、nums2，整数k。请找出符合`nums1[i]%(nums2[j]*k)==0`的`(i,j)`对数。

难度：easy

解法：水题，直接枚举即可。

<hr>

3163 String Compression III

题意：443的变体。还是做类似<b>游程码</b>的压缩，但这次格式为`aaa->3a`，且每次个数<b>至多是9</b>。给定字符串s，请返回压缩结果。

难度：medium

解法：既然还是游程码，只是<b>规则稍微改动</b>，那依然简单。按规则处理即可。总代价`O(n)`。

<hr>

3168 Minimum Number of Chairs in a Waiting Room

题意：给定字符串s，由`EL`组成。`E`表示来人，需要板凳；`L`表示离开，让出板凳。请求出<b>最少需要的</b>板凳数量，保证每个人都<b>有地方坐</b>。

难度：easy

解法：其实就是类似<b>进栈出栈</b>的思维，E进L出，用一个计数`cc`表示就够了。答案就是`max(cc)`。总代价`O(n)`。

<hr>

3174 Clear Digits

题意：给定字符串s，每次你可以删除<b>最左的数字</b>，同时删除它<b>左边最接近</b>的<b>非数字字符</b>。如果找不到这样的组合，则停止。请返回最终结果。

难度：easy

解法：用栈处理，如果`st[-2]`是<b>字母</b>且`st[-1]`是<b>数字</b>，则一起`pop()`。总代价`O(n)`。题目<b>保证</b>可以删光所有数字，因此我们可以不考虑<b>很多边界case</b>。

<hr>

3178 Find the Child Who Has the Ball After K Seconds

题意：n个小朋友，编号`0~n-1`，按照`0->1->...->n-1->n-2->...->0`这样往复传球。请问<b>k步之后</b>，谁拿到球？

难度：easy

解法：水题。这题和2582<b>完全相同</b>，这么<b>抄袭</b>难道不违规吗？

<hr>

3179 Find the N-th Value After K Seconds

题意：给定数组a，初始状态是<b>n个1</b>，`[1,1,...,1]`。每次操作，你把`a[i]`<b>同时变为</b>`sum(a[0:i+1])`，也就是<b>前缀和</b>。经过k步后，请求出`a[n-1]`，结果模`1e9+7`返回。

难度：medium

解法：显然这是个<b>数学题</b>。你看例子，就容易<b>找到规律</b>。结果就是`C(n+k-1,k)=(n+k-1)/((n-1)!(k!)!)`。这个要<b>取模</b>，还得做<b>除法</b>。为计算结果，你至少需要求出`k!`对于`1e9+7`的<b>逆元</b>。如果你不想处理<b>欧几里得算法</b>（很多人会写gcd()，但不会写扩展`gcd()`算法），也可以用常规的<b>递推求和</b>。递推解法，总代价`O(nk)`；数学解法，总代价`O(n+k)`。

<hr>

3184 Count Pairs That Form a Complete Day I

题意：给定数组hours，请找出`(hours[i]+hours[j])%24==0, i<j`的`(i,j)`对数。

难度：easy

解法：水题。

<hr>

3190 Find Minimum Operations to Make All Elements Divisible by Three

题意：给定数组nums，每次你可以任选一个元素，+1或-1。请问多少次操作可以使所有元素都是3的倍数？

难度：easy

解法：水题。余数只能是<b>1或2</b>，对应<b>-1或者+1</b>就可以变成余数0。因此，次数就等于<b>余数不为0的个数</b>。总代价`O(n)`。

<hr>

3191 Minimum Operations to Make Binary Array Elements Equal to One I

题意：给定01数组nums，每次你可以选<b>连续3个值反转</b>。请问至少多少次，能把所有值变成1？如果不可能，则返回-1。

难度：medium

解法：<b>从左到右</b>，按<b>贪心原则</b>处理即可。比如遇到<b>第一个</b>`nums[i]==0`，则反转`(i,i+1,i+2)`。如果反转到最后，恰好变成了<b>全1</b>，则返回<b>反转次数</b>；否则，返回-1。

<hr>

3192 Minimum Operations to Make Binary Array Elements Equal to One II

题意：3191的变体。依然是反转，但这次操作是反转`nums[i:n]`<b>整个后缀</b>。请求出把nums变成全1的最小次数。

难度：medium

解法：其实这题比3191<b>更简单</b>，我只需要从后往前，考虑连续的<b>0段、1段、0段、1段</b>这样交替。而且我不关心<b>每段有多少个0或1</b>，因为不论多少个，都是<b>1次翻转</b>搞定。比如我有`10101`这样5段，除了最左的`1`段，后面4段都要反转，共4次。比如我有`010`这样3段，则<b>从右往左</b>3段都要反转，共3次。反转过程是`010->011->000->111`。总代价`O(n)`。

<hr>

3194 Minimum Average of Smallest and Largest Elements

题意：给定数组nums，长度n为偶数。每次从nums中取出min和max，并把`(min+max)/2`加入结果`res`中。请求出`max(res)`。

难度：easy

解法：水题，对nums<b>排序</b>，从两边向中间靠拢。

<hr>

3195 Find the Minimum Area to Cover All Ones I

题意：给定m x n的01矩阵grid，请找出一个最小的子矩阵，使得子矩阵包含了<b>所有1值</b>。

难度：medium

解法：记录所有<b>1值出现位置`(i,j)`</b>的`min_i、max_i、min_j、max_j`即可。这就是边界，<b>计算面积</b>并返回。

<hr>

3200 Maximum Height of a Triangle

题意：你有red个红球，blue个蓝球。你需要堆一个金字塔，按照每层`1,2,3,...`这样递增。要求<b>单层</b>颜色相同，且<b>相邻层</b>颜色不同。请求出<b>最大层数</b>。

难度：easy

解法：数据量很小，<b>直接模拟</b>即可。按照<b>红蓝红</b>或者<b>蓝红蓝</b>都处理一遍。总代价`O(sqrt(n))`。

## 3201 - 3300

3206 Alternating Groups I

题意：有一个长度为n的<b>环形01数组</b>。请求出其中`010`或`101`的个数。

难度：easy

解法：水题。

<hr>

3210 Find the Encrypted String

题意：给定字符串s，请<b>循环左移</b>k位。

难度：easy

解法：水题。

<hr>

3211 Generate Binary Strings Without Adjacent Zeros

题意：请生成长度为n的01串s，要求所有相邻的`(s[i],s[i+1])`都至少包含1个`1`。请求出<b>所有可能结果</b>。

难度：medium

解法：题目要求<b>穷举</b>，而不是求出个数，那就穷举吧。显然个数是`O(2^n)`量级的，n必然非常小。总代价`O(2^n)`。

<hr>

3212 Count Submatrices With Equal Frequency of X and Y

题意：给定m x n的字符矩阵，其中包含值`XY.`三种。请求出左上角是`(0,0)`，包含至少一个`XY`且`X`和`Y`<b>个数相同</b>的<b>子矩阵的个数</b>。

难度：medium

解法：这题的关键信息，是<b>左上角`(0,0)`</b>。如果没有这条，枚举就变成`O(n^4)`了。既然左上角固定了，<b>右下角枚举</b>就是`O(n^2)`。我们用二维前缀和的方式，<b>分别统计</b>`X`个数个`Y`个数。枚举<b>每个右下角</b>，判断`XY`<b>个数是否相等</b>即可。总代价`O(n^2)`。

<hr>

3216 Lexicographically Smallest String After a Swap

题意：给定数字串s，你可以选<b>相邻且相同奇偶性</b>的两位，交换<b>至多一次</b>。请求出<b>字典序最小</b>的结果。

难度：easy

解法：水题。

<hr>

3217 Delete Nodes From Linked List Present in Array

题意：给定数组nums和链表，请删除链表中，值<b>存在于nums里</b>的节点。

难度：medium

解法：把nums<b>转为集合</b>，然后判断并删除即可。总代价`O(n)`。

<hr>

3218 Minimum Cost for Cutting Cake I

题意：给定一个m x n蛋糕，你需要切成1 x 1的小块。现在定义一个规则，如果你沿着i行切，则代价为`h[i]`；如果你沿着j列切，则代价为`v[j]`。请设计合理的切蛋糕策略，使得总代价最小。求出这个<b>最小值</b>。

难度：medium

解法：非常非常典型的<b>DP思路</b>，一眼能看出<b>子问题</b>。我们定义`(i1,j1)`左上，`(i2,j2)`右下的<b>矩形</b>的最优解为`dp[(i1,j1)][(i2,j2)]`。那么你考虑在其中<b>横切还是竖切</b>，就可以划分出更小的子问题。也就是`ki=(i1,i2), kj=(j1,j2)`。然后写一个类似`dp[...][...]=min(dp[...][...], dp[...][...]+dp[...][...]+(h[i] or v[i]))`的递推公式，就搞定了。这题的难点在于<b>下标很多</b>，写代码<b>容易出bug</b>。需要小心处理。最终答案就是`dp[(0,0)][(m-1,n-1)]`，总代价`O(m^2n^2)`。

<hr>

3222 Find the Winning Player in Coin Game

题意：有面值75和10的两种硬币，各x、y个。AB两人轮流拿硬币，每次都需要拿<b>总和115</b>的硬币，如果做不到则输掉游戏。请问谁赢？

难度：easy

解法：就是`75+10*4`，<b>唯一的固定组合</b>。

<hr>

3223 Minimum Length of String After Operations

题意：给定字符串s，对于一个字符c，如果左边、右边还存在<b>相同的字符c</b>，则删除左边、右边各一个。请求出<b>最终结果的长度</b>。

难度：medium

解法：对于字符c，统计个数，<b>不断`-2`，直到个数小于3为止</b>。对所有不同字符，都按这个逻辑处理。<b>把剩余个数求和</b>就是答案。

<hr>

3226 Number of Bit Changes to Make Two Integers Equal

题意：给定整数n和k，每次你可以把n的任意二进制`1`位改为`0`。请求出把n变成k的最小次数。如果做不到则返回-1。

难度：easy

解法：基础的<b>位操作</b>考察。首先必须满足`n&k==k`，如果不满足则返回-1。答案是`countOnes(n^k)`。

<hr>

3227 Vowels Game in a String

题意：给定字符串s，AB两人轮流做游戏。A需要删除一个<b>元音个数奇数</b>的子串；B需要删除一个<b>元音个数偶数</b>的子串。如果无法删除，则输掉游戏。请问谁赢？

难度：medium

解法：首先，既然只关心元音，那么`aeiou`以外的字符可以直接去掉。或者说我们只关心<b>元音的个数</b>。比如个数是cc，因为每次都是按`奇偶奇偶...`这样取。比如`cc`是<b>奇数</b>，则A一口气拿完，没得选了；比如`cc`是<b>偶数</b>，则A拿掉`cc-1`个，剩1个给B。B只能拿0个，剩下的A还是一口气拿完。两种情况，<b>A都是必胜</b>。只有`cc==0`时，B才能赢。因此，这题就是<b>扯淡的智力题</b>。

<hr>

3228 Maximum Number of Operations to Move Ones to the End

题意：给定01串s，你可以选择一个`1`，把它向右移，直到被后面的`1`挡住为止。请问至多可以执行几次这样的操作？

难度：medium

解法：注意读题，是<b>最大次数</b>，不是最小次数。最小次数很容易做到，我从右往左移动，次数就是最小的。最大次数，那就应该<b>从左往右移动</b>。比如看例子`11010`，`110->011`需要移动2次，变成`01110`。`1110->0111`需要移动3次，变成`0111`。因此，我们总是考虑当前位置累计了几个`1`，<b>累计几个，就要移动几次</b>。每当我遇到`0`时，就执行一次<b>统计`1`个数并累加</b>的操作。总代价`O(n)`。再看一遍<b>移动过程</b>，`11010->2次->01110->3次->00111`，共5次。

<hr>

3232 Find if Digit Game Can Be Won

题意：给定数组nums，元素都在`[1,99]`范围。A可以选择所有1位数或者2位数，剩下的给B。<b>谁的总和大</b>，谁赢。请问谁赢？

难度：easy

解法：水题。除非<b>两部分的和相等</b>，否则肯定A赢。

<hr>

3238 Find the Number of Winning Players

题意：n个玩家，编号`0~n-1`。有一些拿球记录，格式为`[x,y]`，表示x玩家拿了y色的球。按规则，i号玩家如果拿到<b>`>i`个同色的球</b>，则胜利。请求出胜利的玩家个数。

难度：easy

解法：按规则，<b>哈希计数</b>即可。对于`i`玩家，如果`max(mm[i].values())>i`，则胜利。

<hr>

3239 Minimum Number of Flips to Make Binary Grid Palindromic I

题意：给定m x n的01矩阵grid，你可以反转任意`grid[i][j]`。请求出最小的反转次数，使得<b>所有行或者所有列</b>都是<b>回文串</b>。

难度：medium

解法：<b>按行、按列</b>分别统计一下diff个数，取<b>较小的一个</b>即可。

<hr>

3242 Design Neighbor Sum Service

题意：给定n x n矩阵，包含了`0~n^2-1`的<b>不同值</b>。请实现函数`adjacentSum(val)`，求出val值所在位置的<b>上下左右四边</b>的求和；函数`diagonalSum(val)`，求出val值所在位置的<b>相邻四个角</b>的求和。

难度：easy

解法：对`值->位置`做出<b>映射</b>，先找到位置，然后求和即可。

<hr>

3243 Shortest Distance After Road Addition Queries I

题意：有n个点，编号`0~n-1`。开始时有`n-1`条有向边，把`[i,i+1]`连起来。你需要执行<b>m次查询</b>，每次先添加一条边`[x,y]`，你需要查询添加边之后，从`0`到`n-1`的<b>最短距离</b>。

难度：medium

解法：因为边没有权重，等价于<b>距离1</b>。按照给定数据量，我们在每次添加边之后，执行执行BFS，效率也能接受。这样的总代价就是`O(mn)`。可以优化吗？当然可以。因为我添加了边`[x,y]`，那么我从<b>y作为起点</b>，执行BFS，有没有可能得到<b>更小的总距离</b>？如果`距离>=原值`，则停止搜索；如果`距离<原值`，则继续搜索。从之前解法<b>稍微改动</b>，就搞定了。理论复杂度依然是`O(n^2)`，但实际运行很接近`O(n)`。

<hr>

3248 Snake in Matrix

题意：给定n x n方阵，坐标位置`(i,j)`用`i*n+j`表示。机器人从0位置出发，按照给定的<b>上下左右指令</b>移动。请求出最终位置。

难度：easy

解法：水题。

<hr>

3249 Count the Number of Good Nodes

题意：给定一个树形的无向图，n个点编号`0~n-1`，根节点是0。如果某个节点的所有<b>子树的节点数</b>都相同，则称为<b>好点</b>。请求出好点的个数。

难度：medium

解法：如果根节点可以任意指定（一棵无根树），那么这题还要难一点。现在<b>根节点固定是0</b>，这就简单了。直接递归检查即可，总代价`O(n)`。

<hr>

3254 Find the Power of K-Size Subarrays I

题意：给定数组，如果<b>所有元素</b>是<b>按+1递增</b>的等差数列，则定义数组的<b>“力量”</b>等于`max`，否则力量等于-1。现在给定数组nums，请求出它的所有<b>长度k的子数组</b>的力量。

难度：medium

解法：`+1`递增是个<b>很严格的条件</b>，也很容易判断，比如可以统计<b>连续递增的个数</b>。检查代价是`O(1)`，因此总代价`O(n)`可以求出所有的力量值。

<hr>

3258 Count Substrings That Satisfy K-Constraint I

题意：给定01串s，请求出<b>s的子串</b>中，满足<b>0个数或者1个数</b>`<=k`的个数。

难度：easy

解法：数据量很小，直接枚举即可。也可以用<b>滑动窗口+双指针解法</b>，但没必要。

<hr>

3264 Final Array State After K Multiplication Operations I

题意：给定数组nums，请执行k次操作。每次操作，找出其中第一个min值，并把它乘以`mult`。返回操作后的结果。

难度：easy

解法：直接按题意处理即可。如果要更<b>高效</b>，可以使用<b>最小堆</b>。用最小堆的代价是`O(klogn)`，直接枚举则是`O(kn)`。

<hr>

3270 Find the Key of the Numbers

题意：有3个整数xyz，把3个整数都补足4位数。然后按<b>每一位取min值</b>，得到一个4位数。去掉多余的前置0，返回整数结果。

难度：easy

解法：水题。

<hr>

3271 Hash Divided String

题意：给定字符串s，长度n，且`n%k==0`，你需要把它分成`n/k`个子串，每个长度k。<b>对于每个子串</b>，执行一种变换，按照`a~z<->0~25`的双向映射，转为<b>整数</b>，求和，模26，把结果再转为<b>字符</b>。这样，就从`n`长度变为`n/k`长度。请返回变换后的结果。

难度：medium

解法：题目描述<b>很具体</b>，照做即可。总代价`O(n)`。

<hr>

3274 Check if Two Chessboard Squares Have the Same Color

题意：给定8 x 8国际象棋棋盘的两个坐标，请判断<b>颜色</b>是否相同。

难度：easy

解法：水题，判断`x+y`的奇偶性是否相同。

<hr>

3280 Convert Date to Binary

题意：给定`YYYY-MM-DD`格式的日期，把YMD都转为<b>二进制串</b>。

难度：easy

解法：水题。

<hr>

3285 Find Indices of Stable Mountains

题意：给定数组height，如果`height[i-1]>threshold`，则称i位置<b>稳定</b>。请求出所有稳定的位置。

难度：easy

解法：水题。

<hr>

3289 The Two Sneaky Numbers of Digitville

题意：给定数组nums，请找出<b>出现超过1次</b>的值。

难度：easy

解法：水题。

<hr>

3300 Minimum Element After Replacement With Digit Sum

题意：给定数组nums，请把每个`nums[i]`替换为`sumDigits(nums[i])`，然后返回最小值。

难度：easy

解法：水题。

## 3301 - 3400

3304 Find the K-th Character in String Game I

题意：给定字符串s，初始状态是`a`。每次，都把所有`s[i]`<b>循环右移</b>一位，然后加到之前的s末尾。一直执行这个操作，请求出`s[k-1]`的值。

难度：easy

解法：显然，每次长度都是<b>翻倍</b>。因此，我们按照<b>长度`/2`，循环左移一位</b>的思路，往回递推。总代价`O(logk)`。对于小数据量，<b>直接模拟</b>也可以。

<hr>

3309 Maximum Possible Number by Binary Concatenation

题意：给定数组nums，长度为3。请求出把所有`nums[i]`的二进制值用某种顺序连起来，能得到的<b>最大值</b>。

难度：medium

解法：其实类似的问题，以前处理过。比如对于两个字符串s1、s2，你可以比较<b>`s1+s2`和`s2+s1`哪个大</b>。按这个逻辑作为排序依据，进行排序即可。同样解法也适用这题。需要一次排序，总代价`O(nlogn)`。

<hr>

3310 Remove Methods From Project

题意：有一些方法，存在`x->y`的<b>单向调用关系</b>。如果某个方法k有bug，则它<b>直接/间接调用</b>的方法都可能有bug，处于<b>可疑状态</b>。如果一组可疑函数，没有被其他外部函数调用，则可以<b>全部移除</b>。否则，<b>全部保留</b>。请返回<b>尝试移除后</b>的函数列表。

难度：medium

解法：这题的主要难点在于<b>读题</b>，看了两遍才勉强看懂。首先，<b>“可疑”</b>的传递是<b>向下</b>的，而判断是否能移除，则来自<b>上游</b>。那么，我们可以先以`k`为起点，执行遍历，得到可疑列表`sp`。对于`sp`中的每个点`y`，我们检查所有边`x->y`。如果存在`sp`<b>列表以外</b>的点`x`，则表示存在<b>外部调用</b>。有外部调用，就不能删任何函数；如果没有，那就可以把`sp`删光。总代价`O(E+V)`。这题真的太晕了，<b>很容易理解错</b>。

<hr>

3314 Construct the Minimum Bitwise Array I

题意：给定长度n的数组`nums`，你需要构造一个长度n的数组`ans`。要求`ans[i]`的值尽量小，且`ans[i]|(ans[i]+1)==nums[i]`。如果无解，则把对应`ans[i]`设为-1。

难度：easy

解法：一看就是个装神弄鬼的<b>智力题</b>。`x|x+1`，显然结果是个奇数。那么如果`nums[i]`是偶数，就无解。是奇数，则需要考虑一下。看一个例子，`1111==111|(111+1)`。发现了吗？我们要看末尾<b>有多少个连续的1</b>，比如有k个。则我需要设法得到`k-1`个1。也就是把第k位变为0。写成奇怪的<b>位操作</b>，就是`(x & x + 1) | (((x ^ x + 1) + 1) >> 2) - 1`。仔细想想<b>每一部分</b>，还是能想明白的。总代价`O(n)`。虽然不算很难，但对于easy难度，这题<b>属实离谱</b>。

<hr>

3318 Find X-Sum of All K-Long Subarrays I

题意：给定数组nums，对于每个<b>k长度窗口</b>，都求出所有<b>频率在前x大</b>的元素之和。

难度：easy

解法：<b>滑动窗口</b>，一边移动一边更新统计。每次都求出<b>前k大频率</b>对应的值。这么复杂的题，哪里easy了？总代价`O(nklogk)`。

<hr>

3319 K-th Largest Perfect Subtree Size in Binary Tree

题意：给定二叉树，请求出按<b>节点个数</b>，第k大的<b>满二叉子树</b>。返回节点个数。如果不足k个，则返回-1。

难度：medium

解法：这题目有点迷惑，没说<b>节点值</b>到底有没有用。看了例子，应该是<b>没用的</b>。后续遍历，递归检查<b>满二叉树</b>并返回<b>节点数</b>。统计出所有满二叉树后，按个数<b>倒序</b>，取第`k-1`个即可。满二叉树的定义就是，<b>所有非叶节点</b>都有2个子节点。总代价`O(n)`。

<hr>

3324 Find the Sequence of Strings Appeared on the Screen

题意：你有两个键，第一个输出`a`，第二个把<b>最后一个字符</b>循环变为`a~z`的下一个。给定字符串t，请求出输入这个字符串的过程中，得到的<b>所有中间结果</b>。

难度：medium

解法：题意倒是很明确，对于每个`t[i]`，我们都从`a`开始，一直`+1`到等于`t[i]`位置。按规则<b>模拟</b>即可。总代价`O(n)`。

<hr>

3325 Count Substrings With K-Frequency Characters I

题意：给定字符串s，请求出任意字符<b>频率至少k</b>的子串个数。

难度：medium

解法：滑动窗口+双指针。其实你可以把问题<b>反过来想</b>，我求出<b>所有频率都小于k</b>的个数，然后用总数一减，这样更容易。总代价`O(n)`。

<hr>

3330 Find the Original Typed String I

题意：给定字符串word，已知其中<b>某个字符</b>可能被<b>连续多按了几次</b>。请求出原本字符串的所有可能值的<b>个数</b>。

难度：easy

解法：对于每段<b>连续的相同字符</b>，个数为cc，那么答案就是`sum(cc-1)+1`。总代价`O(n)`。

<hr>

3331 Find Subtree Sizes After Changes

题意：给定n个点组成的一棵树，编号`0~n-1`，根节点是0。每个节点的<b>父节点</b>是`parent[i]`。每个点对应一个字符`s[i]`，同字符表示<b>同类节点</b>。现在对所有点<b>同时</b>执行一个操作，比如节点x，找出x的<b>同类的、最近祖先节点y</b>，添加边`[y,x]`，同时删除边`[parent[x],x]`。执行完成后，统计每个点`i`的<b>子树的节点个数</b>`answer[i]`。

难度：medium

解法：<b>非常难懂</b>，而且也<b>比较难</b>的一题。其实你想想并查集就明白了，这就是<b>路径压缩</b>。我们先构造<b>从上到下的树</b>，从0开始做<b>后序遍历</b>。比如我用一个`字符->[节点集]`来表示后序遍历时，<b>按字符分类的子节点</b>。比如说个例子`{'a':{1,6}, `b`:{4,5,7}}`，那么<b>当向上返回</b>时，我遇到一个`'a'`类的节点`x`，我就把`{1,6}`两个节点指向x，也就是添加`x->1 x->6`两条边。同时从集合里删除`{1,6}`，再把`x`<b>放进集合</b>。完成了<b>树的更新</b>后，再遍历一次，统计每个点的<b>子树节点个数</b>，作为最终答案。这题<b>其实就是hard</b>，不论思路难度，还是麻烦程度，远超过了常规medium难度。总代价`O(n)`。

<hr>

3340 Check Balanced String

题意：给定数字串num，请判断<b>奇数位置</b>的数位和，是否等于<b>偶数位置</b>的数位和。

难度：easy

解法：水题。

<hr>

3345 Smallest Divisible Digit Product I

题意：给定整数n和t，请求出`>=n`的最小整数x，使得x的<b>数位乘积</b>是t的倍数。

难度：easy

解法：n和t都非常小，直接枚举即可。

<hr>

3349 Adjacent Increasing Subarrays Detection I

题意：给定数组nums，请判断是否存在两个<b>相邻的长度为k的子数组</b>，两数组都<b>严格递增</b>。

难度：easy

解法：可以换个思路，对于每个位置i，我都考虑<b>向左向右</b>的<b>严格递增长度</b>。如果长度都`>=k`，则i符合条件。因此，可以用`O(n)`的<b>DP思路</b>解决。总代价`O(n)`。

<hr>

3354 Make Array Elements Equal to Zero

题意：给定数组nums，你可以从某个0值出发，<b>像弹球一样移动</b>。每次碰到非0值，就`-1`并<b>转向</b>。如果<b>跑出边界</b>，则结束。请求出能把nums变为全0的`(起始位置,方向)`组合个数。

难度：easy

解法：这哪里easy了？光题目就够复杂的。我们可以按每个位置，左右走，做`2n`次模拟。但按照网友的说法，这样直接<b>超时了</b>。那怎么处理呢？比如左x右y，那么其中较小值变为0的时候，较大值则变为`|x-y|`。但你还要考虑开始时的方向，<b>是左还是右</b>。因此，<b>边界case</b>也比较多。<b>核心思路</b>就一条，对于我出发的位置`i`，我考虑<b>左边的非零总和</b>，是否等于<b>右边的非零总和</b>。如果<b>相等</b>，则左右走都成功；如果<b>相差1</b>，则只有一边可以成功；均不满足，则必定失败。对每个`i`都进行判断，移动`i`的代价是`O(1)`，因此总代价`O(n)`。

<hr>

3360 Stone Removal Game

题意：有n个石头，两人按照`10,9,8,...,1`这样拿石头，A先手。谁无法按要求拿石头，则失败。请问谁赢？

难度：easy

解法：幸亏这题没说<b>“play optimally”</b>，否则真的难绷。<b>直接模拟</b>即可。

<hr>

3361 Shift Distance Between Two Strings

题意：给定等长的字符串s和t，你需要把s变成t。对于每个字符s[i]，你可以<b>循环+1或者循环-1</b>，代价分别是`nextCost[j]`和`previousCost[j]`。j是s[i]在`a~z`中的`0~25`序号。请求出<b>最小总代价</b>。

难度：medium

解法：对于任何`s[i]`到`t[i]`的变化，只有<b>两条路</b>可选，正转或者反转。计算两者中的<b>较小代价</b>并<b>求和</b>，就是最小总代价。总代价`O(n)`。

<hr>

3364 Minimum Positive Sum Subarray 

题意：给定数组num，请求出长度在[l,r]，总和大于0的子数组的<b>最小子数组和</b>。

难度：easy

解法：没想出很巧妙的思路，直接`O(n^2)`枚举吧。如果想`O(n)`，应该怎么做？

<hr>

3365 Rearrange K Substrings to Form Target String

题意：给定等长字符串s和t。请判断能否将s等分成多个<b>k长度子串</b>，进行排序，使得拼接结果恰好等于t？

难度：medium

解法：其实很简单，你不需要确定这个排列顺序，只需要确定能不能做到。那只要把s分成k长度的子串，<b>t也分成k长度的子串</b>，然后<b>都排序</b>。排序结果如果完全一样，那就<b>可以把s变成t</b>。这其实就是<b>anagram</b>。总代价`O(n/k*(log(n)-log(k)))`。

<hr>

3370 Smallest Number With All Set Bits

题意：给定整数n，请找出不小于n的最小整数x，使得x的<b>二进制都是1</b>。

难度：easy

解法：答案就是把n的<b>二进制里的0</b>全部改成1，但用位操作怎么<b>快速求出</b>，还是<b>有点技巧</b>的。可以这么做，`while (n&n+1)!=0: n|=n+1;`。总代价`O(logn)`。

<hr>

3387 Maximize Amount After Two Days of Conversions

题意：货币转换，<b>套汇</b>。开始时，你有<b>某种货币</b>1.0单位，给定一些转换规则，按照`[start,target,rate]`进行，从1单位`start`货币，兑换`rate`单位`target`货币。现在给定两天时间，汇率分别是`rate1、rate2`，请你设计策略，把1.0原货币转进转出，得到最大的原货币。返回<b>最大值</b>。已知任意两种货币的<b>转换路径都是唯一</b>的。

难度：medium

解法：<b>复杂无比</b>的一题，光读懂题目就要五分钟。从模型上，是个<b>有向图</b>问题。两天的汇率不同，可以认为是<b>两个权重不同的图</b>。因为<b>数据规模很小</b>，我们直接<b>执行BFS</b>，就可以了。总代价`O(E1+V1+E2+V2)`。这题的最关键信息，在于规定了转换路径是<b>唯一的</b>，这样就不用处理<b>最短路径、最长路径</b>之类的问题了，一切都是<b>确定的</b>。实际的套汇，<b>怎么可能唯一</b>。如果唯一，那就没钱可赚了。
