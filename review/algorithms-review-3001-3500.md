# LeetCode 一句话题解 - 3001-3500

[返回目录](./README.md)

- [LeetCode 一句话题解 - 3001-3500](#leetcode-一句话题解---3001-3500)
  - [3001 - 3100](#3001---3100)

代码库地址：  
[https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/3001-3500](https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/3001-3500)

## 3001 - 3100

3005 Count Elements With Maximum Frequency

题意：给定数组nums，求出<b>频率最大</b>的元素的<b>频率之和</b>。

难度：easy

解法：水题。

<hr>

3010 Divide an Array Into Subarrays With Minimum Cost I

题意：给定数组nums，将其划分为3个子数组。每个数组的代价是<b>第1个元素</b>的值。请求出<b>最小总代价</b>。

难度：easy

解法：`nums[0]`必选，然后从`nums[1:n]`中找出<b>最小的两个值</b>。加起来就是答案。

<hr>

3011 Find if Array Can Be Sorted

题意：给定数组nums，如果两个相邻元素`(nums[i],nums[i+1])`二进制有<b>相同的1个数</b>，则允许交换它们。请问能否经过任意次交换，使得nums变成升序？

难度：medium

解法：先写一个`countOnes()`函数，统计1的个数。相邻交换，那么交换完了<b>还是相邻</b>。也就是说，不论你怎么交换，都是在一个<b>连续的局部范围内</b>。因此，我们可以按照相同的1个数，把nums分成多个<b>连续小组</b>。每个小组内，你都可以<b>升序排列</b>。如果<b>每个小组</b>排序完了之后，<b>整个数组也有序</b>，那就true；否则，false。这题算<b>半个智力题</b>，半个算法题。

<hr>

3014 Minimum Number of Pushes to Type Word I

题意：老式的9键手机键盘，见过吧？类似那种`2->abc`的映射。现在允许你把`a~z`自由分配到`2~9`上，得到一个<b>多对一映射</b>。请设计一个映射，使得输入单词word的<b>按键次数</b>最少。

难度：easy

解法：题目讲得挺啰嗦，但用过<b>九键键盘</b>的人，很容易想明白。比如`2->abc`，那么输入a按1次`2`，输入c则按3次`222`。因此，我把word里的字符尽量<b>分散放在第一位</b>，这就是最优的。如果还有多的，就分散放到第二位，依此类推。这题算是<b>模拟题</b>。

<hr>

3015 Count the Number of Houses at a Certain Distance I

题意：给定n个房子，顺着排成一排，编号`1~n`。每个`[i,i+1]`之间有一条<b>双向边</b>。除此之外，还有一条`[x,y]`双向边。给定`k=[1,n]`，请求出<b>两点最短距离等于k</b>的`(x,y)`的对数。

难度：medium

解法：直接按<b>全最短路径</b>处理就行，跑一个<b>Floyd算法</b>。不过，既然在链式的基础上，只额外添加了<b>一条边</b>，这题肯定有什么<b>巧妙解法</b>。反正我没想出来。看了评论区，好像也没有。

<hr>

3016 Minimum Number of Pushes to Type Word II

题意：3014的变体。题目<b>完全一样</b>，只有数据量不同。

难度：medium

解法：又是<b>改个数据量</b>就算两题的情况。好吧，题目虽然照抄，解法<b>并不完全一样</b>。我们按照字符频率，做个<b>倒序排列</b>。剩下就和3014一样。

<hr>

3019 Number of Changing Keys

题意：给定字符串s，统计`s.lower()`中，字符发生变化的次数。

难度：easy

解法：水题，注意理解题目。比如`abBDdaa`，变化了3次。

<hr>

3024 Type of Triangle

题意：给定三条边长，请判断<b>等边、等腰</b>还是普通三角形。

难度：easy

解法：水题。

<hr>

3028 Ant on the Boundary

题意：一只蚂蚁从0点出发，给定数组nums，每次移动`nums[i]`单位。请求出蚂蚁返回0点的次数，<b>路过不算</b>。

难度：easy

解法：水题，啰嗦且充满迷惑性。

<hr>

3033 Modify the Matrix

题意：给定m x n矩阵mat，把所有-1值的位置，替换为<b>本列的最大值</b>。

难度：easy

解法：水题，不过我读了两遍才搞明白<b>到底在问什么</b>。

<hr>

3034 Number of Subarrays That Match a Pattern I

题意：给定数组nums和一个模式数组pattern。pattern的元素按照`-1、0、+1`表示`降、等、升`。请找出nums中，符合pattern对应模式的子数组的个数。

难度：medium

解法：这题有点意思，既然我们关心的是<b>相邻元素</b>的比较，那我们先进行比较，得到一个`n-1`长的比较数组diff，其中也按照`-1、0、+1`这样取值。然后我们对diff和pattern做字符串匹配即可。没错，就是<b>KMP</b>那样的匹配。显然，与其手写KMP，不如用<b>正则</b>直接搞定。你可以把diff和pattern数组都转为<b>字符串格式</b>，这样就方便调用re模块了。这题出得很好，好在既有<b>算法难度</b>，又考察做事的<b>灵活性</b>。总代价`O(n+np)`。<b>重叠匹配</b>的写法可以记一下，有点巧妙，`re.findall(r'(?=(p))', s)`。

<hr>

3038 Maximum Number of Operations With the Same Score I

题意：给定数组nums，每次删除<b>开头两个元素</b>，并求和作为<b>分数</b>。持续删除，但是要求每次得到的<b>分数必须相同</b>。请求出能执行<b>几次操作</b>。

难度：easy

解法：水题。

<hr>

3039 Apply Operations to Make String Empty

题意：给定`a~z`组成的字符串s，每一轮，我们都找出`a~z`字符的<b>第一个出现位置</b>并删除。经过若干次，可以把s删光。请求出<b>最后一次</b>删除之前，s的值。

难度：medium

解法：这题很简单，你既然每次都是<b>删除“第一个”</b>，那么最后一个自然就是<b>最后删的</b>。我们找出`a~z`每个字符的<b>最后出现位置</b>，按次序拼起来。注意，只保留`频率==max(频率)`的字符。因为频率更小的字符，之前已经删光了，<b>不会留到最后</b>。

<hr>

3042 Count Prefix and Suffix Pairs I

题意：给定词表words，请求出`i<j`的对数，使得`words[i]`同时是`words[j]`的<b>前缀和后缀</b>。

难度：easy

解法：数据量很小，直接`O(n^2)`枚举即可。

<hr>

3043 Find the Length of the Longest Common Prefix

题意：给定两个整数数组arr1、arr2，请找<b>按数位算</b>，所有`(arr1[i],arr2[j])`的<b>最长公共前缀</b>。返回<b>长度</b>。

难度：medium

解法：这题直白的思路就是<b>枚举ij</b>，复杂度是`O(n1*n2)`。数据量告诉你太慢了。怎么优化呢？可以把所有整数都转为字符串，然后<b>存入字典树</b>中。再给字典树加一个arr1、arr2的<b>访问标记</b>。如果某个节点同时具有两个标记，则是一个有效的公共前缀。我们遍历字典树的所有节点，找出<b>具有两个标记</b>的<b>最深节点</b>，就等于找到最大长度了。这样的处理代价，对于<b>时间空间</b>，都是`O(nlogn)`。<b>实现麻烦</b>，但思路还比较容易。还有一种<b>更巧妙的办法</b>，我们把arr1和arr2的值都转为字符串，然后<b>混在一起</b>。按字典序<b>排序</b>，那么如果存在某个最长前缀，一定会发生在两个<b>字典序最接近</b>的<b>相邻元素</b>中。如此，我们只需要把排序后的所有相邻元素`(a[i],a[i+1])`进行比较，而且只比较其中<b>来源不同</b>的相邻元素。这个思路比字典树简单得多，总代价也是`O(nlogn)`。

<hr>

3046 Split the Array

题意：给定数组nums，请将其分为等长的两个数组nums1、nums2，要求两数组都没有<b>重复值</b>。请判断<b>能否做到</b>。

难度：easy

解法：水题，如果有一个值<b>出现超过2次</b>，就做不到。

<hr>

3065 Minimum Operations to Exceed Threshold Value I

题意：给定数组nums，每次你可以删除一个<b>最小值</b>。请问经过多少次，所有值都<b>不小于k</b>？

难度：easy

解法：水题，统计`<=k`的值的个数即可。

<hr>

3067 Count Pairs of Connectable Servers in a Weighted Tree Network

题意：有一个<b>树形的无向图</b>，表示服务器网络。n个点编号`0~n-1`，边的格式为`[x,y,w]`，表示<b>双向带权</b>的一条边。给定整数k，如果`a-c`的距离、`b-c`的距离都是<b>k的倍数</b>，且两<b>路径（可以由多条边构成）</b>没有共同的边，则称为<b>a和b通过c连通</b>。对于每个点`i=[0,n-1]`，请求出<b>通过i连通</b>的`(a,b)`对数。

难度：medium

解法：这是个<b>树形结构</b>，因此我们从某点i出发（作为根节点），通往任意j点的路径都是<b>唯一</b>的。那么，我们可以O(n)代价做一次遍历，统计出距离`dist%k==0`的个数。比如有`cc`个，那么对数就是`C(cc,2)=cc*(cc-1)/2`。对于每个点`i=[0,n-1]`，执行n次这样的遍历，总代价`O(n^2)`。这个思路不算复杂，但实现已经<b>挺麻烦了</b>。就这样吧，我想不出更好的办法了。

<hr>

3068 Find the Maximum Sum of Node Values

题意：有一个<b>树形的无向图</b>，n个点编号`0~n-1`，边的格式为`[x,y]`。每个点有分值`nums[i]`。现在你可以对任意边`[x,y]`执行一个操作，同时把`nums[x]`和`nums[y]`异或一个k值，也就是`^=k`。你可以执行<b>任意次操作</b>，请求出`max(sum(nums))`。

难度：hard

解法：这题其实是个<b>智力题</b>，而且需要按<b>图论的思维</b>先想一下才能发现。比如我对`[x,y]`执行操作，又对`[y,z]`执行操作，是不是<b>等价于</b>对`[x,z]`执行操作？发现了吗，这是<b>传递性</b>。因为一棵树，所有点都是连通的，因此我可以<b>随便传递</b>。也就是可以<b>任选两个元素</b>`(nums[i],nums[j])`，执行`^=k`的操作。那么我检查所有`nums[i]`，统计`nums[i]^k>nums[i]`的个数。如果偶数个，则<b>全部执行</b>；如果奇数个，则最后会<b>多余一个</b>。对多余的这个，还要和其他元素<b>尝试做一次</b>。如果结果变大了，那就做。这题属于中规中矩的hard，<b>脑力+体力并用</b>的一题。总代价`O(n)`。不得不说，这题的出题者，脑洞还是挺大的。

<hr>

3069 Distribute Elements Into Two Arrays I

题意：给定数组nums，你需要把它分成两个数组arr1、arr2。先把0和1元素分到arr1、arr2中。对于之后每个元素`nums[i]`，都把它分到<b>末尾元素更大</b>的那个数组中。最后返回`arr1+arr2`。

难度：easy

解法：水题。

<hr>

3070 Count Submatrices with Top-Left Element and Sum Less Than k

题意：给定m x n矩阵grid，所有元素<b>非负</b>。请求出左上是`(0,0)`，子矩阵和<b>不超过k</b>的所有<b>子矩阵个数</b>。

难度：medium

解法：直接用<b>二维前缀和</b>的思路，可以求出每个右下角为`(i,j)`的子矩阵和。`sm[i][j]=sm[i][j-1]+sm[i-1][j]+grid[i][j]-sm[i-1][j-1]`，总代价`O(mn)`。

<hr>

3071 Minimum Operations to Write the Letter Y on a Grid

题意：有一个n x n矩阵，n是奇数，表示一个<b>像素屏幕</b>。现在你需要画出一个<b>“Y”图案</b>。也就是右下、左下、下这三笔，而且<b>不能旋转</b>。已知屏幕上的像素点有0、1、2三种值。要求Y部分的像素必须取<b>同一值x</b>，非Y部分的像素必须取<b>同一值y</b>，且`x!=y`。每次你可以<b>修改一个像素</b>，请求出最小的修改次数。

难度：medium

解法：很麻烦的一道<b>模拟题</b>。统计<b>Y部分</b>的012个数，再统计<b>非Y部分</b>的012个数。然后选一个<b>修改总和最小</b>的`(x,y)`组合。没有难度，单纯就是麻烦，总代价`O(n^2)`。

<hr>

3074 Apple Redistribution into Boxes

题意：有n包苹果，每包有`apple[i]`个。有m个箱子，每个容量为`capacity[j]`。你需要把苹果撞到箱子里，用尽可能少的箱子。如果苹果包<b>可以拆开</b>，请求出最少的箱子个数。

难度：easy

解法：水题。`sum(apple)`，`capacity.sort(reverse=True)`，然后看看几个箱子能<b>装完</b>。

<hr>

3075 Maximize Happiness of Selected Children

题意：给定n个小朋友，每个的快乐值是`happines[i]`。你需要选k个，每次选择，所有未被选中的小朋友，<b>快乐值`-1`，至多减到0</b>。请求出k人的<b>最大快乐值总和</b>。

难度：medium

解法：显然，按`happiness`<b>降序排列</b>，答案就是最优的。我不知道这题为什么是medium，这个贪心思路<b>100%符合直觉</b>，很容易想到。总代价`O(nlogn)`。

<hr>

3079 Find the Sum of Encrypted Integers

题意：给定nums，把每个元素`nums[i]`的每一位，都换成它的最大位。返回<b>总和</b>。

难度：easy

解法：水题。

<hr>

3083 Existence of a Substring in a String and Its Reverse

题意：给定字符串s，请找出在`s、reverse(s)`中都存在的<b>长度为2</b>的子串。只判断<b>是否存在</b>即可。

难度：easy

解法：水题。

<hr>

3090 Maximum Length Substring With Two Occurrences

题意：给定字符串s，请求出<b>每种字符不超过2个</b>的最长子串的长度。

难度：easy

解法：滑动窗口+双指针，这都<b>贬值到easy难度</b>了？厉害。

<hr>

3095 Shortest Subarray With OR at Least K I

题意：给定数组nums，请找出其中<b>最短的</b>，异或结果`>=k`的子数组的长度。不存在则返回-1。

难度：easy

解法：数据很小，直接`O(n^2)`枚举即可。

<hr>

3097 Shortest Subarray With OR at Least K II

题意：3095的变体。和3095完全一样，就是<b>数据量不同</b>。

难度：medium

解法：我们需要一个`O(n)`的解法。想到一个<b>滑动窗口+双指针</b>的思路，但<b>有点巧妙</b>，因为你<b>不能直接用</b>滑动窗口。为什么？因为<b>按位或</b>这个操作是没有<b>直接逆运算</b>的。没有逆运算，你怎么<b>缩小窗口</b>。那怎么处理？我们可以<b>按位进行计数</b>，每当`0->1`时，则`^`异或一下；每当`1->0`时，也`^`异或一下。这个操作，就<b>等价于</b>给按位或执行了<b>逆运算</b>。这样，总体代价不再是`O(n)`，而是`O(nlog(int))`。至于双指针怎么滑动，很简单。我用i在前、j在后。i扩大窗口，使得`按位或>=k`；j缩小窗口，使得`按位或`<b>恰好</b>`>=k`。这样，得到的窗口就是<b>最小的</b>。这题确实<b>挺难</b>，我也不知道，我以前怎么想到这种<b>诡异思路</b>的。

<hr>

3099 Harshad Number

题意：给定整数x，如果`x%sumDigits(x)==0`，则称为<b>Harshad数</b>。如果是Harshad数，则返回<b>数位和</b>；否则返回-1。

难度：easy

解法：按定义，求<b>数位和</b>，看是否整除即可。

<hr>

3100 Water Bottles II

题意：1518的变体。你有nb瓶汽水，每次你可以用ne个空瓶子换1瓶汽水。但<b>每换1次</b>，则`ne+=1`。如果你可以自由安排<b>喝水、换瓶子的策略</b>，请求出能喝到的<b>最大瓶数</b>。

难度：medium

解法：还是<b>喝汽水、换瓶子</b>的问题。第一念头肯定是<b>模拟</b>，这题的数据量<b>确实很小</b>，直接模拟吧。纯模拟的总代价是`O(sqrt(nb))`。其实<b>数学解法</b>也不难，我们考虑nb和ne，那么我换瓶子的策略总是<b>攒够了就换</b>。于是，我按照`ne,ne+1,ne+2,...`这样求和，直到超过nb为止。等差数列求和，求个数，相当于<b>解一元二次方程</b>，代价为`O(1)`。持续模拟，至多`O(log(nb))`次就能完成。对于很大的`nb、ne`值，也能轻松解决。
