# LeetCode 一句话题解 - 0501-1000

[返回目录](./README.md)

- [LeetCode 一句话题解 - 0501-1000](#leetcode-一句话题解---0501-1000)
  - [0501 - 0600](#0501---0600)

代码库地址：  
[https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/0501-1000](https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/0501-1000)

## 0501 - 0600

501 Find Mode in Binary Search Tree

题意：给定二叉树，返回其中的<b>众数</b>。如果有多个众数，则按任意顺序返回全部值。

难度：easy

解法：统计并返回即可。众数的意思是，出现频率最大。

<hr>

502 IPO

题意：给定n个项目，你最多可以做k个。如果每个项目需要一定的投资capital，完成后得到一定净利润profit。初始你有启动资本w，请问完成这些项目后，最大的累积资本是多少？

难度：hard

解法：数据规模暗示你，不能O(n^2)枚举。既然每次做项目需要足够资本，那思路就是，在<b>当前资本支持</b>的情况下，总是选<b>净利润最多</b>的项目。因此可以以w为起点，把资本要求低于w的，都放入一个最大堆中。因为我的资本是越来越多的。不存在之后<b>资本反而不够</b>的情况。之后资本更多了，就<b>继续</b>把capital值达到要求的项目放入堆中。每次<b>都取堆顶</b>，也就是净利润最大的项目做。注意，先对所有项目<b>按capital升序排列</b>。总代价是O(nlogn+klogn)，总计<b>O(nlogn)</b>。这个标位hard有点过了，属于比较标准的medium。

<hr>

503 Next Greater Element II

题意：496的变体。和496唯一的区别，就是这次是<b>循环数组</b>

难度：medium

解法：可以用<b>a+a</b>的方式处理循环数组问题，也可以给数组下标<b>取个模</b>。其余思路完全一样。

<hr>

504 Base 7

题意：给定整数，转为7进制。

难度：easy

解法：水题。

<hr>

505 The Maze II

题意：490的变体。和499是同一问题，求<b>最短路径</b>，这次要求输出<b>最短距离</b>，不用给出完整路径。

难度：medium

解法：付费题。既然和499是完全相同的问题，改一下<b>返回参数</b>就行了。

<hr>

506 Relative Ranks

题意：给定n个分数score各不相同。请输出名次，前三名用金银铜牌代替。

难度：easy

解法：水题。

<hr>

507 Perfect Number

题意：给定正整数n，如果n等于它的所有小于自身的约数之和，则n称为<b>完数</b>。请判断n是否为完数。

难度：easy

解法：水题。从2遍历到根号n即可。更高效的话，用<b>素数筛法</b>。但并没有这个必要。

<hr>

508 Most Frequent Subtree Sum

题意：给定二叉树，请求出所有出现频率最高的<b>子树和</b>。如果有多个结果，顺序可以任意。

难度：medium

解法：统计所有子树和，然后找出众数即可。

<hr>

509 Fibonacci Number

题意：斐波那契数，求第n个。已知`F(0)=0,F(1)=1`。

难度：easy

解法：水题。

<hr>

510 Inorder Successor in BST II

题意：285的变体。还是BST的<b>中序后继结点</b>，但这次你<b>没有根节点</b>的位置。但是你有每个节点的<b>parent指针</b>。

难度：medium

解法：付费题。有parent指针，那问题就更简单了。比如当<b>前节点是cur</b>。如果有right孩子，那就right然后一直left；如果没有，那就parent。parent也分两种情况，如果<b>没有parent或者parent的right是cur</b>，那结果就是null；否则，结果就是parent。

<hr>

513 Find Bottom Left Tree Value

题意：给定二叉树，请返回<b>最下一行的最左节点</b>的值。

难度：medium

解法：遍历方式很多，前序比较直观。总之，递归时<b>记录好深度</b>，前序只要找到第一个节点，就是<b>最靠左</b>的。

<hr>

514 Freedom Trail

题意：给定一个字符串<b>圆环</b>ring和一个密码key。你需要正反旋转圆环，把字符<b>对准输入位置</b>，并按键。已知旋转1格算1步，按键也算1步。请问输入密码最少要多少步。

难度：hard

解法：难绷，辐射4是真玩过，这个Freedom Trail就是引你加入Railroad组织的一个秘密任务。这个方式其实就和几十年前的<b>老式旋转拨号的电话</b>一样。<b>第一念头是贪心</b>，第二念头是<b>贪心不对</b>。可以设想一些反例来证明。因为你必须<b>按key中字符的顺序</b>逐个完成，这个问题就可以转化为很规则的DP，那种<b>“只依赖上一步”的DP</b>。剩下不多讲了。

<hr>

515 Find Largest Value in Each Tree Row

题意：给定二叉树，返回每一行的最大值。

难度：medium

解法：还是遍历，<b>按深度</b>记录好每行最大值即可。

<hr>

516 Longest Palindromic Subsequence

题意：给定字符串s，求出最长回文子序列长度。

难度：medium

解法：给定n的规模，<b>O(n^2)的DP解法</b>非常容易想，不详细讲了。那么<b>O(n)的做法有吗</b>？想了五分钟，没什么好思路。罢了。

<hr>

517 Super Washing Machines

题意：给定n元素的数组，在每次操作，你可以选任意多个元素，并<b>同时</b>从每个元素-1，并给它的<b>某个相邻元素</b>+1。这些在一次操作内，同时完成。请问至少多少次操作，能让<b>所有元素相等</b>？如果做不到，返回-1。

难度：hard

解法：首先是求和，除以n。如果有余数，当然返回-1。然后就是考虑<b>高于平均值ave</b>的元素，这些元素需要进行-1，并把+1给那些低于平均值ave的元素。如果你<b>具体去想</b>应该怎么移动，那就想不出来了，因为<b>太复杂</b>。有一定思维比较简单，考虑<b>对称性</b>。你把(a,b)变成(a+d,b-d)，要耗费d次操作。但你选择变a还是变b，则无所谓，因为最终结果相同。因此，从第一个开始，每个元素都必须变成ave，不论大还是小。因此，考虑`abs(nums[i]-ave)`。然后，当你连续遇到几个大于ave的元素，那么这些差值是要<b>累加</b>的；但如果你恰好遇到一大一小，这两个差值则可以<b>抵消</b>。因此，这时的计算则不能用abs()了。总体思路和代码非常简洁。<b>我当年没想出来</b>，现在读了代码，尝试再理解一遍。这种hard题，难度全在于灵机一动，<b>想不到就是0分</b>。没意思。

<hr>

518 Coin Change II

题意：322的变体。给定n种硬币和对应面值。如果每种硬币有无限枚，请问组成amount金额有多少种方法？

难度：medium

解法：硬币数量无限，标准的<b>完全背包问题</b>。循环时，从前往后扫即可。

<hr>

519 Random Flip Matrix

题意：有一个m x n的01矩阵。请设计数据结构，实现reset()，重置所有元素为0；实现flip()，随机反转一个<b>值为0的元素</b>。尽可能减少对随机函数的调用，并保证机会均等。

难度：medium

解法：既然要求找到值为0的元素，并以<b>等概率</b>反转。那就需要把所有值为0的元素位置记下来。用`i*m+j`这种形式记，然后均匀抽样即可。之前有过类似的随机取数的题目，用一个list，<b>随机取样并交换到末尾</b>，然后pop的方式进行删除。看了下我当年的代码，完全不知道在讲什么。又看了下题目的<b>数据规模</b>，明白了。用O(n^2)的空间直接记录位置，是不允许的，会<b>爆内存</b>。难怪当年查资料用了一个叫<b>线性同余生成器</b>，LCG。这个是一种经典的伪随机数生成算法，因为是<b>生成器</b>，结果自然是<b>不断迭代产生</b>的。这也就避免了全量计算+存储的开销。所以这题的考点就是这个，这有点<b>过于刁钻+专业</b>了。当然，其实基于我上面给的乱序+交换做法，也可以做。还是用<b>生成器思路</b>，先把<b>行顺序随机</b>，再把每行之内的<b>列顺序随机</b>这样也是可以的。这个做法也有学名，叫<b>Fisher-Yates乱序</b>。

<hr>

520 Detect Capital

题意：给定英文单词，检验大写字母用得是否正确。

难度：easy

解法：水题，英语语法。

<hr>

521 Longest Uncommon Subsequence I

题意：给定两个字符串，返回<b>最长不公共子序列</b>的长度。意思是，只是其中一个字符串的子序列。

难度：easy

解法：<b>脑筋急转弯</b>。两者之中<b>更长的</b>一个就是，如果两者完全相同，那就-1。

<hr>

522 Longest Uncommon Subsequence II

题意：521的变体。

难度：medium

解法：521是闹着玩，这题是认真的。对于两个串，只要<b>不完全相同</b>，就有答案。现在有n个串，则条件是某串ss是<b>其中1个</b>的子序列，对<b>其他n-1个</b>，则均不是子序列。首先考虑特殊情况，如果存在两个串s和t完全相同，即s==t，那么s的任何子序列，都是t的子序列。因此这时<b>把s和t都排除</b>。所以数组中，只剩下互不重复的元素，从中选一个最长的就行了。它的长度就是答案。因此，这题还是超级简单，只不过要<b>多想一点点</b>。

<hr>

523 Continuous Subarray Sum

题意：给定一个数组nums和整数k，<b>好数组</b>的定义是，长度至少为2且和为k的倍数。请判断nums是否存在一个<b>好子数组</b>。

难度：medium

解法：思路很容易。因为要确定子数组和为k的倍数，因此在记录子数组和的时候，只用<b>模k记录</b>即可。还是用前缀和的方式，如果前缀和%k=r，那只用判断r是否为0，或者r是否已存在于记录中。为0则为k的倍数；已存在记录中，则表示<b>之前某个前缀和</b>与当前前缀<b>同余</b>，两者相减是k的倍数。这两种情况都是true。如果始终不满足，则false。

<hr>

524 Longest Word in Dictionary through Deleting

题意：给定字符串s和一个词典dictionary。请判断s删去一些字符后，能否得到dictionary中的词，并找出<b>最长的的一个</b>。如果存在多个答案，返回<b>字典序最小</b>的。

难度：medium

解法：以数据规模来看，似乎能很快得到<b>直白解法</b>，但又想不出更高效的。对词典按(-长度,+字典序)二维进行排序，这样<b>最长且字典序最小</b>的就在前面。然后逐个匹配，匹配的就是子序列。判断每个单词是否为s的<b>子序列</b>即可。找到了就返回。这样总体代价是<b>O(nw*ns)</b>，nw和ns分别为单词个数和字符串长度。暂时想不出能优于这个复杂度的解法。

<hr>

525 Contiguous Array

题意：给定一个01数组，请求出<b>0个数等于1个数</b>的最长子数组的长度。

难度：medium

解法：这种题目大多是<b>前缀和统计</b>或者<b>滑动窗口</b>。如果是前缀和统计，那个比如前i位总共p个1，前j位总共q个1。要求`i==2*p`，或者`i-j=2*(p-q)`。这个好像不太方便确定j的位置。其实<b>稍微变一下</b>，这方法就行得通了。<b>遇到1就+1，遇到0就-1</b>即可。这样，我们要找的情况，其实<b>“子数组和”恰好是0</b>。还是用<b>前缀和统计</b>，搞定了。如果你是从滑动窗口入手的话，会发现很难走通。这题看似有点<b>取巧</b>，其实也用到了一个物理思维，就是<b>坐标系变换</b>。如果坐标系没用对，那<b>所有东西都在变</b>，你找不到锚定位置。但如果设对了，你有一个<b>不动点</b>作为参照，问题就简单了。本来是统计(0,1)，却改成了统计(-1,+1)对吧？

<hr>

526 Beautiful Arrangement

题意：给定一个1-n的排列。我们以1为下标起点，定义<b>漂亮排列</b>。如果第i位元素是a[i]，每个位置i都满足<b>i整除a[i]或者a[i]整除i</b>，则称这个排列a是漂亮排列。给定整数n，请返回长度1-n组成的漂亮排列个数。

难度：medium

解法：<b>n很小</b>，只到15。不过15!也不小了。这就是明示你，直接搜。考虑一下漂亮排列的定义，涉及到<b>a|b或者b|a这种约数、倍数关系</b>，这个是很<b>苛刻</b>的，因此满足条件的排列个数<b>肯定不多</b>。这也给你做暴力搜索提供了保障。<b>做好剪枝</b>即可。

<hr>

527 Word Abbreviation

题意：320的变体。还是单词缩写问题，缩写规则就不重复了。给定一个词表，给每个单词生成一个<b>不会和其他单词冲突</b>的缩写。要求缩写长度最短，如果缩写长度<b>不短于</b>原单词长度，则<b>不做处理</b>。做缩写时，以<b>保留最短的唯一前缀</b>为原则。

难度：hard

解法：付费题。以数据范围来看，单词个数在几百，<b>单词长度也可以达到几百</b>。因此<b>单词比较长</b>是主要的难点。题目中最重要的条件是，<b>保留前缀</b>。比如<b>abcde和abcdx</b>，如果缩写为4e、4x显然更短。但按题目要求，你<b>不能直接在开头用缩写</b>，所以结果应该是保留abcde和abcdx，不缩写。有这个条件就简单多了。先按`(长度,字典序)`二维进行排序。<b>同长度之间</b>才可能产生冲突。然后，对相邻两个词做前缀判断即可。

<hr>

528 Random Pick with Weight

题意：给定一个带权重的数组，权重为w[i]。请随机返回下标[0,n-1]，返回概率<b>按照权重的比例分配</b>。

难度：medium

解法：权重的所有元素总和为<b>sum</b>。首先这些权重是非负的（如果是负数就有点离谱），求前缀和。从0开始，依次是w[0]、w[0]+w[1]、...、w[0]+...+w[n-1]，<b>总共n+1个值</b>。每次取[0,sum)的一个<b>随机数</b>，按照这个随机数落在<b>n个区间中的哪一个</b>，来确定下标应该取几。这个确定区间的代价是O(logn)，用<b>二分查找</b>得到。

<hr>

529 Minesweeper

题意：扫雷游戏，规则就不细讲了。现在给定一个游戏状态，并给出点击的位置。请计算点击后的游戏状态。

难度：medium

解法：如果点开了雷，游戏结束。如果点开空地且<b>周围没有雷</b>，则进行搜索并打开附近的格子。如果点开了雷且<b>周围有雷</b>，则只打开当前格子。很纯粹的<b>搜索+模拟题</b>，按要求完成即可。

<hr>

530 Minimum Absolute Difference in BST

题意：给定一个二叉搜索树，返回两个节点的最大差值。

难度：easy

解法：既然是BST，那<b>最大值-最小值</b>就是答案了。一个最左一个最右。

<hr>

531 Lonely Pixel I

题意：给定一个黑白矩阵，B黑W白。如果一个黑点所在的<b>行和列</b>没有其他黑点，则称这个黑点是<b>孤独黑点</b>。请求出孤独黑点的个数。

难度：medium

解法：付费题。对<b>所有行、所有列</b>都统计黑点个数。然后再扫一遍所有点，如果是黑点，就看看<b>本行本列</b>的黑点个数即可。复杂度O(nm)。

<hr>

532 K-diff Pairs in an Array

题意：给定数组nums，求出所有<b>`i!=j`</b>且<b>`nums[j]-nums[i]=k`</b>的(nums[i],nums[j])对的个数。结果要求对值去重，只统计<b>唯一值</b>的个数。

难度：medium

解法：用哈希表统计值的个数。对于当前值x，在哈希表中寻找x+k<b>是否存在</b>（因为只统计唯一值个数）。如果你同时找x+k和x-k，结果就要除以2。对于k=0的情况，可以特殊处理一下。

<hr>

533 Lonely Pixel II

题意：531的变体。请找出<b>n行</b>，使得这n行恰好每行<b>长得完全一样</b>，且都有<b>n列</b>是<b>黑点</b>。返回<b>n的最大值</b>。

难度：medium

解法：付费题。题目神一般的拗口，<b>看不懂</b>。带着例子又看了好几遍，终于明白了。关键在于n行n列，且<b>这n行完全一样</b>。行列数的返回都在200内，因此可以勉强接受O(n^3)的解法。看了下，我当年确实写了个<b>三层循环</b>的做法，不过稍微优化了一下。对一整行，采取8元素一个byte，用byte表示字符，存为字符串的方式。这样就方便比较两行是不是完全相同了。如此的话，复杂度其实还是O(n^3)，但形式上优化到O(n^2)了。<b>最终效率可接受。</b>

<hr>

535 Encode and Decode TinyURL

题意：短网址设计，请实现编码、解码算法。

难度：medium

解法：这题是<b>最经典的系统设计题</b>之一。我之前还在某次没准备好的面试上，因为这题挂过。如果你去搜技术博客，会发现有人为这题写了<b>万字长文</b>，那个篇幅和图文并茂程度，堪称<b>卷中卷</b>。其中<b>可以涉及</b>字符串编码、压缩率、哈希冲突、签名算法的安全性、微服务的性能调优、数据库的分库分表设计、KV存储vs关系数据库等等各种话题。也是因为这个，这题也从一道经典的面试题，逐渐成了一种<b>魔怔八股文</b>的代表。现在面试的话，这题已经是<b>必背八股文</b>了，讲不出个几百上千字，面试官就断定你没背过。当然你也可以三五句话就完事，无非是<b>当场淘汰</b>而已。当年我没做这题，直接return完事了。现在想想，我觉得面对这种题的<b>正确心态</b>，应该是“我应该多学，而且要<b>学明白</b>。然后保持一个好心态，把<b>想说的说清楚</b>。”而不是玩儿命地<b>背</b>，或者刻意<b>说一大堆</b>，显得自己准备过很多。话说回来，也不能因为它是八股，就反感。要是<b>连八股都不会</b>，那只能叫<b>懒</b>。

<hr>

536 Construct Binary Tree from String

题意：给定一种特定格式的<b>二叉树前序遍历结果</b>，请重建这个二叉树。

难度：medium

解法：付费题。这个格式，其实不做说明，你也看得出是<b>前序遍历</b>。“根(左子树)(右子树)”，<b>递归解析</b>，并建立整棵树即可。

<hr>

537 Complex Number Multiplication

题意：给定两个用字符串表示的<b>复数</b>，请做乘法。

难度：medium

解法：<b>复数</b>的应用非常广泛，尤其是<b>物理和一些工程领域</b>（当然也源于物理）。因此很多编程语言直接在<b>基础库</b>里就支持复数运算了。按运算规则，解析、相乘即可。`(a+bi)*(c+di)=(ac-bd)+(ad+bc)i`。

<hr>

538 Convert BST to Greater Tree

题意：给定一个二叉搜索树，请将其转换为<b>“较大树”</b>。意思是，每个节点的值，都额外加上<b>所有大于它的节点的值之和</b>。

难度：medium

解法：这个可以用<b>后序遍历</b>来处理。递归时，返回当前子树的总和，但在返回后，<b>只使用右子树之和</b>。让<b>当前根节点</b>加上右子树总和</b>。看了下以前的代码，<b>思路</b>和这个一样，<b>写法</b>稍有不同。这个不重要。

<hr>

539 Minimum Time Difference

题意：给定一些HH:MM格式的时间，请找出其中两个时间差的最小值。

难度：medium

解法：都转换为整数，<b>排序、找最小差值</b>即可。注意，<b>第一个和最后一个</b>也要算，考虑23:59到00:00的情况。

<hr>

540 Single Element in a Sorted Array

题意：一个<b>有序</b>数组，所有其他元素都出现2次，只有1个元素出现1次。请找出这个单独元素，要求O(logn)时间O(1)空间完成。

难度：medium

解法：之前用<b>异或</b>的做法已经处理过了，时间是O(n)。这次要求<b>O(logn)</b>？关键在于有序。因为是有序的，那比如112234455。你看某个位置i，如果`a[i]==a[i+1]`，<b>这是前半</b>；如果`a[i]==a[i-1]`，<b>这是后半</b>。两半的中间那个值，就是单独的值。所以<b>用二分来夹这个范围</b>，直到定为到它为止。注意<b>边界case</b>，比如答案在最左或者最右的情况。

<hr>

541 Reverse String II

题意：344的变体。给定字符串s，对<b>每2k个字符</b>，反转<b>前k个</b>。如果尾部不足k个，则反转剩余的。如果尾部够k个，则照例反转。

难度：easy

解法：水题。

<hr>

542 01 Matrix

题意：给定一个01矩阵，请求出每个位置到<b>最近的0</b>的距离。距离计算按照<b>行+列</b>（即曼哈顿距离）为准。

难度：medium

解法：把所有0位置作为起点，进行<b>一次BFS</b>即可。奇怪的是，我以前写的BFS代码怎么没用队列？

<hr>

543 Diameter of Binary Tree

题意：给定一个二叉树，定义它的直径为树中<b>任意两点</b>能得到的<b>最长路径</b>的长度。

难度：easy

解法：既然是选任意两点，也就<b>不一定经过根节点</b>了。所以<b>在每层都递归</b>，然后拼出<b>左右最长路径之和</b>。注意，<b>单边的情况</b>也适用这种解法，另一边路径为0就是单边的。这题接近medium了，不太easy。

<hr>

544 Output Contest Matches

题意：给定n支队伍，你需要进行n//2组配对。给定1-n的排名，按照<b>强对弱</b>的原则匹配n//2组。并

难度：medium

解法：付费题。读了两遍才明白题目<b>到底在问什么</b>。名次1-n，按照(1,n)、(2,n-1)...之类进行<b>强弱配对</b>。然后按照一种递归嵌套的形式输出。实际的难点在于<b>拼凑这个字符串</b>，递归做吧。仔细观察<b>“(((1,8),(4,5)),((2,7),(3,6)))”</b>这个例子，找出规律。

<hr>

545 Boundary of Binary Tree

题意：给定二叉树，请按逆时针方向，返回所有<b>边界节点</b>。边界包括根节点、最左、最下、最右所有节点，注意去重。

难度：medium

解法：付费题。题目给的示例有点奇怪，为什么是`[1,3,4,2]`而不是`[1,2,3,4]`？这题的麻烦之处在于理解，有的情况就很迷惑。比如<b>“最下”</b>，是不是只有<b>深度最大的叶节点</b>才算最下？考虑到这几种情况的处理逻辑都不太一样，还是<b>各自写代码处理</b>好了。最后<b>统一做去重</b>，并拼装出完整结果。看了下以前的代码，看来我当年<b>没写出来</b>，或者说写得太难看了。这题可以说很考验<b>写递归的技巧</b>了，有难度。
<hr>

546 Remove Boxes

题意：有n个盒子，每个都有颜色，用一个整数表示。每次你可以选一些连续的同色盒子并拿走。如果总共有k个，则得分k*k。请问拿走所有箱子，你能得到的<b>最大分数</b>是多少？

难度：hard

解法：这题和之前的<b>312爆气球</b>非常像，也是<b>从中间消除</b>，然后<b>让两边拼到一起</b>。既然如此，那DP的思路也可以类似了。做DP之前，先要想清楚一个原则。如果有连续10个同色盒子，那我必然要消除10个，而不会选9个。因为10*10得到100分，做任何拆分都只会得到更少分数。所以对连续的同色盒子，是<b>不能做拆分的</b>。把数组按连续同色的方式进行<b>统计</b>，得到<b>统计数组a</b>。比如`[3,3,3,2,2,4,4,4,4,3,3]`，对应统计数组就是[(3,3),(2,2),(4,3),(3,2)]再对统计数组做<b>DP</b>。以本题的数据规模，O(n^3)的解法不难想到。用dp[i][j]表示第i-j断的最大得分。如果`a[i][0]==a[j][0]`，<b>两端颜色相同</b>，可以拼起来，则考察`dp[i+1][j-1]+(a[i][1]+a[j][1])^2`是否是更优解。除此之外，枚举ij之间的每个k，看看<b>两段拆分</b>的结果，也就是`dp[i][k]+dp[k+1][j]`。看了下当年写的代码，我开了个三维数组，这是没必要的。二维足够了。

<hr>

547 Number of Provinces

题意：给定一个<b>邻接矩阵</b>表示的<b>无向图</b>，求<b>连通分量</b>个数。

难度：medium

解法：把题目原话<b>翻译过来</b>就是这个。<b>并查集</b>解决。

<hr>

548 Split Array with Equal Sum

题意：给定一个n元素数组，请问是否存在下标`i<j<k`，使得<b>去掉对应三个元素</b>后，得到的<b>四个子数组的和都相等</b>。

难度：medium

解法：付费题。注意，要<b>去掉</b>ijk三个位置的元素。以n的规模，暗示你解法应该是<b>O(n^2)代价</b>的。那就这么做。<b>第一维i</b>，枚举。<b>第三维k</b>，枚举，但是要做检查。第二维j，需要夹在ik中间，而且我<b>只判断是否存在</b>，而不用找出它。怎么找j呢？用哈希表记录前缀和，看看你要找的某个前缀和是否存在即可。比如nums[0:i]这个前缀和是sm，那么我要找的值，就是`sm+nums[i]+sm`。j前面有<b>两段子数组+一个nums[i]</b>。看了下我以前的代码，不是这么做的。而是<b>从j开始枚举</b>，然后两边查找<b>ik</b>。确实<b>以前的做法更好</b>，因为思路是<b>对称的</b>。

<hr>

549 Binary Tree Longest Consecutive Sequence II

题意：298的变体。给定一个二叉树，你可以选任意两点作为端点，得到一个节点序列。请返回能得到的节点序列是连续序列的最大长度。连续序列指<b>公差为1的等差数列</b>。

难度：medium

解法：付费题。公差是+1或者-1其实无所谓，因为你总是<b>可以反着走的</b>。就用+1为准吧。那么对于二叉树，你毕竟<b>不能向上走</b>，所以还是采取<b>左右搜，然后拼接起来</b>的思路。比如，当前根节点的值为3，那我向左向右，都搜以3为起点，<b>能延伸多少步</b>等差数列。然后<b>用左+1拼右-1，或者左-1拼右+1</b>。比如左边是1-2-3，右边是3-4-5-6，那拼起来就是<b>1-2-3-4-5-6</b>。方向反过来，道理还是相同。对于<b>单边</b>的情况，这种解法也适用，相当于另一边的路径为0。

<hr>

551 Student Attendance Record I

题意：给定一个学生的出勤记录，P到A缺L迟。如果学生没有<b>2天以上缺席</b>，没有<b>连续3天迟到</b>，则可以得<b>出勤奖</b>。请判断是否能得奖。

难度：easy

解法：水题。

<hr>

552 Student Attendance Record II

题意：551的变体。规则就不重复了。现在给定长度n，请求出所有<b>可以得奖的</b>长度为n的记录个数。结果<b>模1e9+7</b>。

难度：hard

解法：很显然，这是个DP题。但怎么设计递推关系呢？<b>缺席</b>是个数，<b>迟到</b>是连续个数。缺席只能是0或1，迟到最多是连续2个，那么一天内的状态记录应该是2*3的，2表示A取值{0,1}，3表示L取值{0,1,2}。因为每天的记录只依赖<b>前一天</b>，则O(n)空间可以优化为O(1)。总体实现，还是老老实实用一个`dp[2][2][3]`的数组，把所有递推式子都写下来，这样<b>不容易出错</b>。我当年的代码很奇怪，现在<b>无论如何看不懂了</b>。这就是<b>关键思路不写注释</b>的恶果。现在让我重做这题，我会选择开个`dp[2][2][3]`数组。

<hr>

553 Optimal Division

题意：给定一个数组nums，表示一个除法式子`nums[0]/nums[1]/.../nums[n-1]`。你可以在其中任意添加括号来改变运算顺序。请求出能得到的<b>最大结果</b>。

难度：medium

解法：当然是<b>DP</b>了。按照被`除数/除数`考虑，那么为了结果最大，被除数应该大，除数应该小。所以问题就转化成了<b>同时求</b>某个子问题的<b>最大值和最小值</b>。对于dp_max[i][j]，枚举dp_max[i][k]/dp_min[k+1][j]的最大值。<b>反之亦然。</b>

<hr>

554 Brick Wall

题意：给定一面砖墙，由很多行组成，每行都有一些<b>长长短短</b>的砖头，每行的<b>总长度加起来相同</b>。现在从上到下画一条线，请找到一条线，使其<b>穿过最少的砖头数</b>。如果从砖头<b>边界</b>经过，则不算穿过。

难度：medium

解法：首先，你当然不会真的去划线，比如找个2.5、3.7之类的中间位置。而是会考虑一段区间被<b>几个叠起来的砖头</b>覆盖了。没错，<b>区间覆盖</b>。所以，其实可以所有值做一下统计，然后用区间覆盖的方式，统计一下哪个区间的覆盖次数最少，这个最少的次数就是答案。题目还告诉你，墙的总长度不超过20000，那就可以直接开这个数组来做<b>覆盖统计</b>了。因为是批处理，可以直接用<b>后缀和</b>的方式。当然，熟练的话，用<b>树状数组</b>完成也可以。还有一种<b>更简洁</b>的思路，一条线从上往下，总是要穿过一些砖头边界的。那么，不是穿过边界的，就一定是<b>穿过砖头中间</b>了。所以，对每个边界值，数一下<b>个数</b>，用<b>`高度-个数`</b>就是穿过的砖头数了。

<hr>

555 Split Concatenated Strings

题意：给定一组字符串，允许你<b>反转</b>其中的任意串。把处理完之后的串，<b>连成一个环</b>，再从环的任意一个字符处切开，变成一个长字符串。请返回能得到的<b>字典序最大</b>的字符串。

难度：medium

解法：付费题。首先反转好理解，如果反了之后<b>字典序更大</b>，那就反。连接好之后，对长字符串的移位比较，好像也没什么特别高效（其实肯定有的）的做法。直接逐个比较好了。题目限定的<b>字符串长度之和是1000</b>，就是告诉你，就算是<b>暴力比较</b>也让你过了吧。

<hr>

556 Next Greater Element III

题意：496的变体。给定一个整数n，请返回大于n，且数位组成和n相同（但顺序不同）的最小整数。且这个数必须在int32范围内，如果不存在或者超出范围，则返回-1。

难度：medium

解法：这个题目要求<b>有点呆板</b>了。int32毕竟是某些语言限制的，并非所有。有的语言<b>int是64位</b>，有的甚至可以自动转为<b>大数</b>的。回到问题本身，这个其实就是next permutation，<b>把n转成一个字符串</b>，找出这些数位的<b>下一个排列</b>，再转回整数。对结果检验一下，是否<b>>n且<INT_MAX</b>。比如132，之后是231、312、321，再之后就没了。

<hr>

557 Reverse Words in a String III

题意：151的变体。给定英文句子，只反转单词内的字母，不反转单词顺序。

难度：easy

解法：水题。

<hr>

558 Logical OR of Two Binary Grids Represented as Quad-Trees

题意：<b>四叉树</b>，定义就不讲了。现在给定两个四叉树q1和q2，都代表n*n的01矩阵。请求出它们的<b>逻辑或</b>，并用四叉树表示。

难度：medium

解法：`0|x=x,1|x=1`，按这两条规则就行了。递归时，在每一层对<b>2*2四个子问题</b>进行处理。对于整整、整分、分分三种情况，各自处理好就行了。<b>整</b>表示到达了<b>叶节点</b>，<b>分</b>表示下面<b>还有分叉</b>。这题的代码，其实比用嘴说还简单。看了下我以前的代码，明显<b>写复杂了</b>。用python的话，应该能在20行左右写完。

<hr>

559 Maximum Depth of N-ary Tree

题意：求N叉树的最大深度。

难度：easy

解法：和二叉树没什么不同的，递归即可。

<hr>

560 Subarray Sum Equals K

题意：给定数组nums和整数k，请返回其中子数组和为k的个数。

难度：medium

解法：子数组题，用哈希表统计<b>前缀和</b>即可。比如当前前缀和是x，那就找x-k的个数。

<hr>

561 Array Partition

题意：给定一个2n长度的数组nums，请分出n个数对`(a_i,b_i)`，使得这n对的最小值之和`sum(min(a_i,b_i))`最大。请返回这个<b>最大和</b>。

难度：easy

解法：easy？？？这肯定是脑筋急转弯，坑人的。既然条件讲的这么拗口，那我们仔细理解一下。要<b>最小值，求和，最大</b>。比如`[1,2,3,4,5,6]`，那应该取`1+3+5=9`，分组应该是`(1,2),(3,4),(5,6)`。可以用反证法论证，如果你做任何交换，要么<b>不影响结果</b>，要么<b>会让小值更小</b>，而大值不影响结果，从而得到<b>更小的和</b>。因此，这种选法是<b>最优的</b>，所得之和最大。所以，思路就是<b>排好序</b>，按<b>13579</b>这样选。具体证明过程就不写了，脑子里跑一下就行了。

<hr>

562 Longest Line of Consecutive One in Matrix

题意：给定一个01矩阵，请找出<b>连续1</b>的最大长度。方向可以是横、竖、正反对角线。

难度：medium

解法：付费题。没什么技巧，就是从这四个方向<b>都扫一下</b>就行了。注意<b>对角线</b>方向处理好下标边界，别弄错了。

<hr>

563 Binary Tree Tilt

题意：给定二叉树，返回每个节点的<b>倾斜值</b>之和。倾斜值的定义是<b>左右子树节点和</b>的<b>差值的绝对值</b>。

难度：easy

解法：虽然描述的挺复杂，不过还是递归处理就好了。<b>求子树和，算差值，向上返回，再求和</b>。对于easy难度，这个要求确实挺麻烦的。不过代码确实很短，用python如果写得极简的话，3-5行代码应该足够了。

<hr>

564 Find the Closest Palindrome

题意：给定一个字符串表示的整数n，请找出<b>不等于它</b>，且<b>和它最接近</b>的回文数。

难度：hard

解法：限定了n的长度不超过18位，这其实是在64位整数范围内，因此可以用长整型来表示数据。当然，用字符串也可以。因为是回文数，那么我考虑<b>从中间位开始变</b>，这个变化是<b>最小的</b>。因为两边必须对称，变动<b>最低位</b>也等于变动<b>最高位</b>。举例子，比如<b>13579</b>。让它变小，那就是13531，中间的5不动，下面变小即可。让它变大，那就是13631。对于偶数位的情况，123456。变小，就是123321。变大，就是124421。那么129934呢？变小，是129921。变大，是130031。所以你可以只考虑一半，让这一半“+1”。思路不算很复杂，不过代码写得挺复杂。还是<b>实现得不太好</b>。注意一些<b>边界case</b>，比如99999，下一个是100001，上一个是99899。

<hr>

565 Array Nesting

题意：给定数组nums，nums是`0~n-1`的一个排列。选定一个起始下标k，依次生成<b>有限集合</b>`s(k)={nums[k],nums[nums[k]],...}`。给定k的所有取值，请求出s(k)的<b>最大大小</b>。

难度：medium

解法：这个就是非常经典的<b>置换群</b>（permutation group）。<b>群论</b>并不在基础的工科课表里，没学过很正常。但置换群属于其中一种挺有意思的组合数学结构。回到问题本身，这样不断取nums[]运算，总会形成一个环。比如排列`[1,3,2,0]`，用置换群可以写作`(0,1,3)(2)`，表示013构成一个循环，2构成一个循环。<b>计算置换群的总代价是O(n)</b>，因为你在算出所有循环时，每个值<b>只访问一次</b>，不会重复的。

<hr>

566 Reshape the Matrix

题意：实现类似MATLAB（或者numpy）里的reshape功能，将<b>二维矩阵</b>打成<b>一维数组</b>。

难度：easy

解法：多维数据的存储方式，默认是<b>行优先（row-major）</b>的。或者对于n维数据，总是<b>第i维优先于第i+1维</b>。n行m列，`i*m+j`。在做矩阵运算、缓存命中等<b>特定场景</b>下，<b>列优先（column-major）</b>也是有应用的。

<hr>

567 Permutation in String

题意：给定字符串s1和s2，判断s2的某个子串是否是s1的排列。

难度：medium

解法：s2的子串，是，s1的排列。所以，不能把s1、s2直接排个序。得用字符统计的办法。s1、s2都比较长，O(n^2)的匹配也不可接受。还是滑动窗口吧。所幸，这题的滑动窗口很简单，因为<b>窗口大小是固定的</b>。这样就非常简单了，每次<b>移动一位，调整窗口</b>，<b>判断字符统计</b>是否相同。搞定了。

<hr>

568 Maximum Vacation Days

题意：给定n个城市的有向图，标号`0~n-1`。你<b>从0点出发</b>，每周可以<b>在一个城市度假</b>或者<b>在周一</b>飞去<b>另一个城市度假</b>。第j周在第i城市的假期数是days[i][j]。请安排行程，以获得最长的假期天数。

难度：hard

解法：付费题。题目又长又复杂，读完都费老劲。图论题，可又像是DP题。应该是<b>图论+DP题</b>。所以，可以采取dp[i][j]表示<b>第j周在第i城</b>能得到的<b>最大假期之和</b>，然后以此进行<b>BFS</b>。BFS起点当然是从0城出发。讲道理，这个hard也不能说思维特别难，但<b>图论+DP</b>这个组合也<b>够麻烦了</b>，hard确实合理。看了下我的老代码，没用队列，<b>换了种方式做BFS</b>。思维是一样的。

<hr>

572 Subtree of Another Tree

题意：给定两个二叉树t1和t2，判断t2是否和t1的某个子树（包括自身）完全一样。

难度：easy

解法：递归暴力匹配的解法就不说了。重点说一下问题转化的思维。如果用什么奇怪的办法，直接做到<b>线性匹配两棵树</b>，肯定很难想。但<b>字符串匹配</b>的O(n+m)解法，你知道。<b>二叉树序列化为字符串</b>的O(n)解法，你也知道。两者结合起来，不就是线性的解法了？<b>问题转化</b>，这个思维非常重要。不只是做这些应试题，是整个人生的思维。

<hr>

573 Squirrel Simulation

题意：在一个二维n x m矩阵上，给定<b>松鼠、树、一些松子</b>的位置。松鼠每次能<b>拿一个松子放到树下</b>，直到拿完。请求出松鼠移动的<b>最小总距离</b>。

难度：medium

解法：付费题。除了一开始松鼠拿松子之外，之后每次松鼠都是<b>从树的位置出发</b>，所以对于这些松子，顺序都无所谓了。因此，我要找一个<b>松鼠相对于树</b>离得最近的松子作为<b>第一颗</b>。后面的每颗，就<b>无所谓顺序</b>了。

<hr>

575 Distribute Candies

题意：给定n个糖果，每个的种类用一个整数表示。如果n是偶数，从中选出一半糖果，最多能得到多少不同种类？

难度：easy

解法：用哈希表对数组的值进行<b>计数</b>。然后<b>按key不断轮询</b>，每轮询一个，计数-1。减到0了，则删除对应key。这样能保证每次取的元素都<b>尽量不相同</b>。取到了n/2个元素时，结束轮询。取到的元素都放入<b>集合</b>中，<b>统计个数</b>即可。当然，这题其实是<b>脑筋急转弯</b>。直接`min(len(nums)//2,len(set(nums)))`就搞定了，想想为什么？很无聊，对吧。

<hr>

576 Out of Boundary Paths

题意：给定一个m x n矩阵，有个球，每次可以上下左右移动一格。给定<b>初始位置、最多移动步数</b>。请问有多少种办法可以<b>让球出界</b>？对结果<b>模1e9+7</b>。

难度：medium

解法：数据规模并不大，<b>不用想得太复杂</b>。从起点开始，执行BFS。对于BFS到边界时，如果还有步数，就可以让球出界。这个BFS最好<b>不用队列</b>，而是用<b>两个交替的哈希表</b>来做。看了下我以前的代码，比想象中的复杂。现在让我写，应该比这个短得多了。

<hr>

581 Shortest Unsorted Continuous Subarray

题意：给定一个数组nums，如果存在一个子数组nums[i:j+1]，对应这个子数组排序，就能使整个数组都有序。请找出符合条件的<b>最短子数组</b>的长度。

难度：medium

解法：题目是真拗口，但要问的东西其实不难。如果中间某段nums[i:j+1]有序了，能让整个数组都有序，那说明两点：`nums[i-1]<=min(nums[i:j+1])`，`nums[j+1]>=max(nums[i:j+1])`。因此，你可以从两边逐渐确定这个边界。比如<b>左边</b>，从0开始，看看nums[i]是否<=右边nums[i+1:n]的最小值，是的话就右移，<b>直到不满足为止</b>。右边的情况，<b>反之亦然</b>。因为<b>后缀最小</b>和<b>前缀最大</b>都是O(n)代价可以得到的。因此这个边界可以在<b>O(n)代价</b>确定下来。如果最后发现边界是`i=0,j=n-1`，说明要<b>排序整个数组</b>；如果发现边界是`i>j`，则说明数组已经有序了，<b>不用排序</b>。

<hr>

582 Kill Process

题意：给定一些id用整数表示的进程，除了<b>根进程</b>外，其他进程都有1个父进程，0-多个子进程。整个结构是<b>一棵进程树</b>。给定一个你<b>要终止的进程id</b>，返回所有被终止的<b>进程id列表</b>。

难度：medium

解法：付费题。既然是树，那就<b>建立这棵树</b>，然后<b>遍历并删除</b>对应的终止进程<b>所在的子树</b>。只为了完成这题的话，用<b>并查集</b>处理也很方便。直接把kill的根节点指向自己，这样<b>这棵子树就孤立了</b>。再遍历进行<b>find操作</b>，就能得到<b>所有属于这个子树</b>的进程。

<hr>

583 Delete Operation for Two Strings

题意：给定字符串s1和s2，每次允许你从其中一个串删除1个字符。请问至少多少次操作，可以让两串相同？

难度：medium

解法：按<b>子序列</b>的逻辑判断。为什么是子序列？因为<b>删字符</b>，子序列就是这么得到的。比如s1和s2目前的最长公共子序列是ss。那么子序列是对称的。s2和s1，子序列也是ss。我能不能得到比ss这个更长的结果？肯定不能啊。所以，转化为<b>LCS问题</b>了。教科书级的<b>DP问题</b>，O(n^2)时间O(n)空间解决。

<hr>

587 Erect the Fence

题意：给定二维平面上，一些树的坐标。请用一个篱笆把所有树围起来。为了尽可能省材料，篱笆要<b>贴着一些树</b>。请返回所有篱笆贴着的树的坐标。

难度：hard

解法：这下好了，<b>凸包</b>都出来了。除了搞竞赛的人必须会，一般人不一定学过。<b>没学过，肯定写不出这算法。</b>凸包是什么呢？凸包就是一个<b>最小的凸多边形</b>，能把点集都围进去。凸多边形是什么呢？就是每个角都<b>不超过180度</b>的多边形。这个算法是<b>用叉积的符号</b>来判断一个点是否应该被包含在<b>凸包的点集</b>里。脑子里想象一下，<b>左转右转</b>。之前已经有一题<b>469</b>，用叉积来判断<b>凸多边形</b>了，是同一个原理。具体实现凸包计算，还有<b>好几个细节</b>，代码也不短。搜两个关键词<b>“convex hull”和“Graham scan”</b>。凸包还有很多种算法，当然每个的<b>核心思想</b>都差不多。

<hr>

588 Design In-Memory File System

题意：设计一个<b>简单的文件系统</b>，能查看、创建目录，能读写文件。

难度：hard

解法：付费题。做的事情很具体，算是一个<b>系统设计题</b>了。既然有目录，有文件，你会如何组织？最直接的方式，是直接<b>一层哈希表映射</b>。稍微好点的方式，是建立目录树，并提供目录、文件两种类型。对文件，则提供读写API。这样的话，起码从功能上，它有<b>文件系统</b>最基本的样子了。看了下我的代码，写了两百多行，也算是<b>没偷懒</b>了。除了对基本功能的实现，<b>OOP</b>的一些知识也是应该体现的。

<hr>

589 N-ary Tree Preorder Traversal

题意：N叉树前序遍历。

难度：easy

解法：和二叉树没有什么不同。

<hr>

590 N-ary Tree Postorder Traversal

题意：N叉树后序遍历。

难度：easy

解法：同589。

<hr>

591 Tag Validator

题意：给定一段HTML代码，请检查其中的所有`<xxx></xxx>`<b>标签开闭是否匹配</b>。另有`<![CDATA[xxx]]>`作为特殊标签，其中的内容即使包含了标签，也要<b>解释为普通字符</b>。

难度：hard

解法：这题作为这么早的题，<b>点赞数低得出奇</b>，显然是<b>恶评如潮</b>。原因无非是<b>过多的边界case</b>，冗长而无聊的解法，基本不用动脑，只需要<b>无限的耐心</b>。因此，作者出这个题就是用来<b>折磨人</b>的。

<hr>

592 Fraction Addition and Subtraction

题意：给定一个字符串表示的<b>分数加减法算式</b>，请求出结果。用<b>最简分数</b>形式返回。

难度：medium

解法：分数本身的运算就不说了，<b>通分</b>之后加减即可，结果要<b>约分</b>。除此之外，要做的就是<b>字符串解析</b>了，这个小心处理即可。

<hr>

593 Valid Square

题意：给定二维平面4个点，判断能否构成一个正方形。

难度：medium

解法：正方形的条件很严格，计算<b>6对距离的平方</b>。如果满足`1:1:1:1:2:2`，就是正方形。对这个判定，我想不出反例。

<hr>

594 Longest Harmonious Subsequence

题意：定义<b>最大值最小值相差1</b>的数组为<b>和谐数组</b>。给定一个数组nums，请求出<b>最长和谐子序列</b>的长度。

难度：easy

解法：毕竟元素时整数，两个不同值最小差也是1。因此要满足<b>和谐子序列</b>的话，你<b>必须选</b>两个相邻的不同值。对数组的元素<b>计数</b>，并对key排序。找<b>key相邻且值相差为1</b>的情况，答案就在这里面。

<hr>

598 Range Addition II

题意：370的变体。给定m x n矩阵，初始全为0。每次执行一个操作(x,y)，表示把<b>[0,x)行、[0,y)列</b>所有元素都+1。执行完所有操作后，返回矩阵中<b>值为最大值的个数</b>。

难度：easy

解法：矩阵前缀和，这种都有一个通用技巧。<b>用后缀方式，反着来。</b>比如在(x,y)执行操作，那就只给a[x][y]加1。等所有操作完了之后，<b>统一进行累加</b>。累加的时候，按后缀方式，<b>从下往上加，从右往左加</b>。不知道<b>这个技巧</b>的话，这题可就不easy了。

<hr>

599 Minimum Index Sum of Two Lists

题意：给定两个字符串数组l1和l2。找出所有<b>下标和最小的公共串</b>。如果存在多个，返回顺序任意。

难度：easy

解法：描述的挺复杂，不过，<b>一步步来就行了</b>。判断交集，检查下标位置，求和，判断和是否最小。<b>作为easy题，这题倒是挺麻烦的。</b>

<hr>

600 Non-negative Integers without Consecutive Ones

题意：给定正整数n，请返回[0,n]中，二进制表示里<b>没有连续的1</b>的整数个数。

难度：hard

解法：<b>数位DP题</b>。比如我们考虑<b>可以有前置0的k位的二进制数</b>，如果最高位是1，则下一位必须是0，变成dp[k-2]；如果最高位是0，变成dp[k-1]，所以`dp[k]=dp[k-1]+dp[k-2]`，就是<b>斐波那契数</b>。<b>再往下就讲不清楚了</b>，主要是我当年写的代码，现在看不明白了。
