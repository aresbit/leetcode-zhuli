# LeetCode 一句话题解 - 0501-1000

[返回目录](./README.md)

- [LeetCode 一句话题解 - 0501-1000](#leetcode-一句话题解---0501-1000)
  - [0501 - 0600](#0501---0600)
  - [0601 - 0700](#0601---0700)

代码库地址：  
[https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/0501-1000](https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/0501-1000)

## 0501 - 0600

501 Find Mode in Binary Search Tree

题意：给定二叉树，返回其中的<b>众数</b>。如果有多个众数，则按任意顺序返回全部值。

难度：easy

解法：统计并返回即可。众数的意思是，出现频率最大。

<hr>

502 IPO

题意：给定n个项目，你最多可以做k个。如果每个项目需要一定的投资capital，完成后得到一定净利润profit。初始你有启动资本w，请问完成这些项目后，最大的累积资本是多少？

难度：hard

解法：数据规模暗示你，不能O(n^2)枚举。既然每次做项目需要足够资本，那思路就是，在<b>当前资本支持</b>的情况下，总是选<b>净利润最多</b>的项目。因此可以以w为起点，把资本要求低于w的，都放入一个最大堆中。因为我的资本是越来越多的。不存在之后<b>资本反而不够</b>的情况。之后资本更多了，就<b>继续</b>把capital值达到要求的项目放入堆中。每次<b>都取堆顶</b>，也就是净利润最大的项目做。注意，先对所有项目<b>按capital升序排列</b>。总代价是O(nlogn+klogn)，总计<b>O(nlogn)</b>。这个标位hard有点过了，属于比较标准的medium。

<hr>

503 Next Greater Element II

题意：496的变体。和496唯一的区别，就是这次是<b>循环数组</b>

难度：medium

解法：可以用<b>a+a</b>的方式处理循环数组问题，也可以给数组下标<b>取个模</b>。其余思路完全一样。

<hr>

504 Base 7

题意：给定整数，转为7进制。

难度：easy

解法：水题。

<hr>

505 The Maze II

题意：490的变体。和499是同一问题，求<b>最短路径</b>，这次要求输出<b>最短距离</b>，不用给出完整路径。

难度：medium

解法：付费题。既然和499是完全相同的问题，改一下<b>返回参数</b>就行了。

<hr>

506 Relative Ranks

题意：给定n个分数score各不相同。请输出名次，前三名用金银铜牌代替。

难度：easy

解法：水题。

<hr>

507 Perfect Number

题意：给定正整数n，如果n等于它的所有小于自身的约数之和，则n称为<b>完数</b>。请判断n是否为完数。

难度：easy

解法：水题。从2遍历到根号n即可。更高效的话，用<b>素数筛法</b>。但并没有这个必要。

<hr>

508 Most Frequent Subtree Sum

题意：给定二叉树，请求出所有出现频率最高的<b>子树和</b>。如果有多个结果，顺序可以任意。

难度：medium

解法：统计所有子树和，然后找出众数即可。

<hr>

509 Fibonacci Number

题意：斐波那契数，求第n个。已知`F(0)=0,F(1)=1`。

难度：easy

解法：水题。

<hr>

510 Inorder Successor in BST II

题意：285的变体。还是BST的<b>中序后继结点</b>，但这次你<b>没有根节点</b>的位置。但是你有每个节点的<b>parent指针</b>。

难度：medium

解法：付费题。有parent指针，那问题就更简单了。比如当<b>前节点是cur</b>。如果有right孩子，那就right然后一直left；如果没有，那就parent。parent也分两种情况，如果<b>没有parent或者parent的right是cur</b>，那结果就是null；否则，结果就是parent。

<hr>

513 Find Bottom Left Tree Value

题意：给定二叉树，请返回<b>最下一行的最左节点</b>的值。

难度：medium

解法：遍历方式很多，前序比较直观。总之，递归时<b>记录好深度</b>，前序只要找到第一个节点，就是<b>最靠左</b>的。

<hr>

514 Freedom Trail

题意：给定一个字符串<b>圆环</b>ring和一个密码key。你需要正反旋转圆环，把字符<b>对准输入位置</b>，并按键。已知旋转1格算1步，按键也算1步。请问输入密码最少要多少步。

难度：hard

解法：难绷，辐射4是真玩过，这个Freedom Trail就是引你加入Railroad组织的一个秘密任务。这个方式其实就和几十年前的<b>老式旋转拨号的电话</b>一样。<b>第一念头是贪心</b>，第二念头是<b>贪心不对</b>。可以设想一些反例来证明。因为你必须<b>按key中字符的顺序</b>逐个完成，这个问题就可以转化为很规则的DP，那种<b>“只依赖上一步”的DP</b>。剩下不多讲了。

<hr>

515 Find Largest Value in Each Tree Row

题意：给定二叉树，返回每一行的最大值。

难度：medium

解法：还是遍历，<b>按深度</b>记录好每行最大值即可。

<hr>

516 Longest Palindromic Subsequence

题意：给定字符串s，求出最长回文子序列长度。

难度：medium

解法：给定n的规模，<b>O(n^2)的DP解法</b>非常容易想，不详细讲了。那么<b>O(n)的做法有吗</b>？想了五分钟，没什么好思路。罢了。

<hr>

517 Super Washing Machines

题意：给定n元素的数组，在每次操作，你可以选任意多个元素，并<b>同时</b>从每个元素-1，并给它的<b>某个相邻元素</b>+1。这些在一次操作内，同时完成。请问至少多少次操作，能让<b>所有元素相等</b>？如果做不到，返回-1。

难度：hard

解法：首先是求和，除以n。如果有余数，当然返回-1。然后就是考虑<b>高于平均值ave</b>的元素，这些元素需要进行-1，并把+1给那些低于平均值ave的元素。如果你<b>具体去想</b>应该怎么移动，那就想不出来了，因为<b>太复杂</b>。有一定思维比较简单，考虑<b>对称性</b>。你把(a,b)变成(a+d,b-d)，要耗费d次操作。但你选择变a还是变b，则无所谓，因为最终结果相同。因此，从第一个开始，每个元素都必须变成ave，不论大还是小。因此，考虑`abs(nums[i]-ave)`。然后，当你连续遇到几个大于ave的元素，那么这些差值是要<b>累加</b>的；但如果你恰好遇到一大一小，这两个差值则可以<b>抵消</b>。因此，这时的计算则不能用abs()了。总体思路和代码非常简洁。<b>我当年没想出来</b>，现在读了代码，尝试再理解一遍。这种hard题，难度全在于灵机一动，<b>想不到就是0分</b>。没意思。

<hr>

518 Coin Change II

题意：322的变体。给定n种硬币和对应面值。如果每种硬币有无限枚，请问组成amount金额有多少种方法？

难度：medium

解法：硬币数量无限，标准的<b>完全背包问题</b>。循环时，从前往后扫即可。

<hr>

519 Random Flip Matrix

题意：有一个m x n的01矩阵。请设计数据结构，实现reset()，重置所有元素为0；实现flip()，随机反转一个<b>值为0的元素</b>。尽可能减少对随机函数的调用，并保证机会均等。

难度：medium

解法：既然要求找到值为0的元素，并以<b>等概率</b>反转。那就需要把所有值为0的元素位置记下来。用`i*m+j`这种形式记，然后均匀抽样即可。之前有过类似的随机取数的题目，用一个list，<b>随机取样并交换到末尾</b>，然后pop的方式进行删除。看了下我当年的代码，完全不知道在讲什么。又看了下题目的<b>数据规模</b>，明白了。用O(n^2)的空间直接记录位置，是不允许的，会<b>爆内存</b>。难怪当年查资料用了一个叫<b>线性同余生成器</b>，LCG。这个是一种经典的伪随机数生成算法，因为是<b>生成器</b>，结果自然是<b>不断迭代产生</b>的。这也就避免了全量计算+存储的开销。所以这题的考点就是这个，这有点<b>过于刁钻+专业</b>了。当然，其实基于我上面给的乱序+交换做法，也可以做。还是用<b>生成器思路</b>，先把<b>行顺序随机</b>，再把每行之内的<b>列顺序随机</b>这样也是可以的。这个做法也有学名，叫<b>Fisher-Yates乱序</b>。

<hr>

520 Detect Capital

题意：给定英文单词，检验大写字母用得是否正确。

难度：easy

解法：水题，英语语法。

<hr>

521 Longest Uncommon Subsequence I

题意：给定两个字符串，返回<b>最长不公共子序列</b>的长度。意思是，只是其中一个字符串的子序列。

难度：easy

解法：<b>脑筋急转弯</b>。两者之中<b>更长的</b>一个就是，如果两者完全相同，那就-1。

<hr>

522 Longest Uncommon Subsequence II

题意：521的变体。

难度：medium

解法：521是闹着玩，这题是认真的。对于两个串，只要<b>不完全相同</b>，就有答案。现在有n个串，则条件是某串ss是<b>其中1个</b>的子序列，对<b>其他n-1个</b>，则均不是子序列。首先考虑特殊情况，如果存在两个串s和t完全相同，即s==t，那么s的任何子序列，都是t的子序列。因此这时<b>把s和t都排除</b>。所以数组中，只剩下互不重复的元素，从中选一个最长的就行了。它的长度就是答案。因此，这题还是超级简单，只不过要<b>多想一点点</b>。

<hr>

523 Continuous Subarray Sum

题意：给定一个数组nums和整数k，<b>好数组</b>的定义是，长度至少为2且和为k的倍数。请判断nums是否存在一个<b>好子数组</b>。

难度：medium

解法：思路很容易。因为要确定子数组和为k的倍数，因此在记录子数组和的时候，只用<b>模k记录</b>即可。还是用前缀和的方式，如果前缀和%k=r，那只用判断r是否为0，或者r是否已存在于记录中。为0则为k的倍数；已存在记录中，则表示<b>之前某个前缀和</b>与当前前缀<b>同余</b>，两者相减是k的倍数。这两种情况都是true。如果始终不满足，则false。

<hr>

524 Longest Word in Dictionary through Deleting

题意：给定字符串s和一个词典dictionary。请判断s删去一些字符后，能否得到dictionary中的词，并找出<b>最长的的一个</b>。如果存在多个答案，返回<b>字典序最小</b>的。

难度：medium

解法：以数据规模来看，似乎能很快得到<b>直白解法</b>，但又想不出更高效的。对词典按(-长度,+字典序)二维进行排序，这样<b>最长且字典序最小</b>的就在前面。然后逐个匹配，匹配的就是子序列。判断每个单词是否为s的<b>子序列</b>即可。找到了就返回。这样总体代价是<b>O(nw*ns)</b>，nw和ns分别为单词个数和字符串长度。暂时想不出能优于这个复杂度的解法。

<hr>

525 Contiguous Array

题意：给定一个01数组，请求出<b>0个数等于1个数</b>的最长子数组的长度。

难度：medium

解法：这种题目大多是<b>前缀和统计</b>或者<b>滑动窗口</b>。如果是前缀和统计，那个比如前i位总共p个1，前j位总共q个1。要求`i==2*p`，或者`i-j=2*(p-q)`。这个好像不太方便确定j的位置。其实<b>稍微变一下</b>，这方法就行得通了。<b>遇到1就+1，遇到0就-1</b>即可。这样，我们要找的情况，其实<b>“子数组和”恰好是0</b>。还是用<b>前缀和统计</b>，搞定了。如果你是从滑动窗口入手的话，会发现很难走通。这题看似有点<b>取巧</b>，其实也用到了一个物理思维，就是<b>坐标系变换</b>。如果坐标系没用对，那<b>所有东西都在变</b>，你找不到锚定位置。但如果设对了，你有一个<b>不动点</b>作为参照，问题就简单了。本来是统计(0,1)，却改成了统计(-1,+1)对吧？

<hr>

526 Beautiful Arrangement

题意：给定一个1-n的排列。我们以1为下标起点，定义<b>漂亮排列</b>。如果第i位元素是a[i]，每个位置i都满足<b>i整除a[i]或者a[i]整除i</b>，则称这个排列a是漂亮排列。给定整数n，请返回长度1-n组成的漂亮排列个数。

难度：medium

解法：<b>n很小</b>，只到15。不过15!也不小了。这就是明示你，直接搜。考虑一下漂亮排列的定义，涉及到<b>a|b或者b|a这种约数、倍数关系</b>，这个是很<b>苛刻</b>的，因此满足条件的排列个数<b>肯定不多</b>。这也给你做暴力搜索提供了保障。<b>做好剪枝</b>即可。

<hr>

527 Word Abbreviation

题意：320的变体。还是单词缩写问题，缩写规则就不重复了。给定一个词表，给每个单词生成一个<b>不会和其他单词冲突</b>的缩写。要求缩写长度最短，如果缩写长度<b>不短于</b>原单词长度，则<b>不做处理</b>。做缩写时，以<b>保留最短的唯一前缀</b>为原则。

难度：hard

解法：付费题。以数据范围来看，单词个数在几百，<b>单词长度也可以达到几百</b>。因此<b>单词比较长</b>是主要的难点。题目中最重要的条件是，<b>保留前缀</b>。比如<b>abcde和abcdx</b>，如果缩写为4e、4x显然更短。但按题目要求，你<b>不能直接在开头用缩写</b>，所以结果应该是保留abcde和abcdx，不缩写。有这个条件就简单多了。先按`(长度,字典序)`二维进行排序。<b>同长度之间</b>才可能产生冲突。然后，对相邻两个词做前缀判断即可。

<hr>

528 Random Pick with Weight

题意：给定一个带权重的数组，权重为w[i]。请随机返回下标[0,n-1]，返回概率<b>按照权重的比例分配</b>。

难度：medium

解法：权重的所有元素总和为<b>sum</b>。首先这些权重是非负的（如果是负数就有点离谱），求前缀和。从0开始，依次是w[0]、w[0]+w[1]、...、w[0]+...+w[n-1]，<b>总共n+1个值</b>。每次取[0,sum)的一个<b>随机数</b>，按照这个随机数落在<b>n个区间中的哪一个</b>，来确定下标应该取几。这个确定区间的代价是O(logn)，用<b>二分查找</b>得到。

<hr>

529 Minesweeper

题意：扫雷游戏，规则就不细讲了。现在给定一个游戏状态，并给出点击的位置。请计算点击后的游戏状态。

难度：medium

解法：如果点开了雷，游戏结束。如果点开空地且<b>周围没有雷</b>，则进行搜索并打开附近的格子。如果点开了雷且<b>周围有雷</b>，则只打开当前格子。很纯粹的<b>搜索+模拟题</b>，按要求完成即可。

<hr>

530 Minimum Absolute Difference in BST

题意：给定一个二叉搜索树，返回两个节点的最大差值。

难度：easy

解法：既然是BST，那<b>最大值-最小值</b>就是答案了。一个最左一个最右。

<hr>

531 Lonely Pixel I

题意：给定一个黑白矩阵，B黑W白。如果一个黑点所在的<b>行和列</b>没有其他黑点，则称这个黑点是<b>孤独黑点</b>。请求出孤独黑点的个数。

难度：medium

解法：付费题。对<b>所有行、所有列</b>都统计黑点个数。然后再扫一遍所有点，如果是黑点，就看看<b>本行本列</b>的黑点个数即可。复杂度O(nm)。

<hr>

532 K-diff Pairs in an Array

题意：给定数组nums，求出所有<b>`i!=j`</b>且<b>`nums[j]-nums[i]=k`</b>的(nums[i],nums[j])对的个数。结果要求对值去重，只统计<b>唯一值</b>的个数。

难度：medium

解法：用哈希表统计值的个数。对于当前值x，在哈希表中寻找x+k<b>是否存在</b>（因为只统计唯一值个数）。如果你同时找x+k和x-k，结果就要除以2。对于k=0的情况，可以特殊处理一下。

<hr>

533 Lonely Pixel II

题意：531的变体。请找出<b>n行</b>，使得这n行恰好每行<b>长得完全一样</b>，且都有<b>n列</b>是<b>黑点</b>。返回<b>n的最大值</b>。

难度：medium

解法：付费题。题目神一般的拗口，<b>看不懂</b>。带着例子又看了好几遍，终于明白了。关键在于n行n列，且<b>这n行完全一样</b>。行列数的返回都在200内，因此可以勉强接受O(n^3)的解法。看了下，我当年确实写了个<b>三层循环</b>的做法，不过稍微优化了一下。对一整行，采取8元素一个byte，用byte表示字符，存为字符串的方式。这样就方便比较两行是不是完全相同了。如此的话，复杂度其实还是O(n^3)，但形式上优化到O(n^2)了。<b>最终效率可接受。</b>

<hr>

535 Encode and Decode TinyURL

题意：短网址设计，请实现编码、解码算法。

难度：medium

解法：这题是<b>最经典的系统设计题</b>之一。我之前还在某次没准备好的面试上，因为这题挂过。如果你去搜技术博客，会发现有人为这题写了<b>万字长文</b>，那个篇幅和图文并茂程度，堪称<b>卷中卷</b>。其中<b>可以涉及</b>字符串编码、压缩率、哈希冲突、签名算法的安全性、微服务的性能调优、数据库的分库分表设计、KV存储vs关系数据库等等各种话题。也是因为这个，这题也从一道经典的面试题，逐渐成了一种<b>魔怔八股文</b>的代表。现在面试的话，这题已经是<b>必背八股文</b>了，讲不出个几百上千字，面试官就断定你没背过。当然你也可以三五句话就完事，无非是<b>当场淘汰</b>而已。当年我没做这题，直接return完事了。现在想想，我觉得面对这种题的<b>正确心态</b>，应该是“我应该多学，而且要<b>学明白</b>。然后保持一个好心态，把<b>想说的说清楚</b>。”而不是玩儿命地<b>背</b>，或者刻意<b>说一大堆</b>，显得自己准备过很多。话说回来，也不能因为它是八股，就反感。要是<b>连八股都不会</b>，那只能叫<b>懒</b>。

<hr>

536 Construct Binary Tree from String

题意：给定一种特定格式的<b>二叉树前序遍历结果</b>，请重建这个二叉树。

难度：medium

解法：付费题。这个格式，其实不做说明，你也看得出是<b>前序遍历</b>。“根(左子树)(右子树)”，<b>递归解析</b>，并建立整棵树即可。

<hr>

537 Complex Number Multiplication

题意：给定两个用字符串表示的<b>复数</b>，请做乘法。

难度：medium

解法：<b>复数</b>的应用非常广泛，尤其是<b>物理和一些工程领域</b>（当然也源于物理）。因此很多编程语言直接在<b>基础库</b>里就支持复数运算了。按运算规则，解析、相乘即可。`(a+bi)*(c+di)=(ac-bd)+(ad+bc)i`。

<hr>

538 Convert BST to Greater Tree

题意：给定一个二叉搜索树，请将其转换为<b>“较大树”</b>。意思是，每个节点的值，都额外加上<b>所有大于它的节点的值之和</b>。

难度：medium

解法：这个可以用<b>后序遍历</b>来处理。递归时，返回当前子树的总和，但在返回后，<b>只使用右子树之和</b>。让<b>当前根节点</b>加上右子树总和</b>。看了下以前的代码，<b>思路</b>和这个一样，<b>写法</b>稍有不同。这个不重要。

<hr>

539 Minimum Time Difference

题意：给定一些HH:MM格式的时间，请找出其中两个时间差的最小值。

难度：medium

解法：都转换为整数，<b>排序、找最小差值</b>即可。注意，<b>第一个和最后一个</b>也要算，考虑23:59到00:00的情况。

<hr>

540 Single Element in a Sorted Array

题意：一个<b>有序</b>数组，所有其他元素都出现2次，只有1个元素出现1次。请找出这个单独元素，要求O(logn)时间O(1)空间完成。

难度：medium

解法：之前用<b>异或</b>的做法已经处理过了，时间是O(n)。这次要求<b>O(logn)</b>？关键在于有序。因为是有序的，那比如112234455。你看某个位置i，如果`a[i]==a[i+1]`，<b>这是前半</b>；如果`a[i]==a[i-1]`，<b>这是后半</b>。两半的中间那个值，就是单独的值。所以<b>用二分来夹这个范围</b>，直到定为到它为止。注意<b>边界case</b>，比如答案在最左或者最右的情况。

<hr>

541 Reverse String II

题意：344的变体。给定字符串s，对<b>每2k个字符</b>，反转<b>前k个</b>。如果尾部不足k个，则反转剩余的。如果尾部够k个，则照例反转。

难度：easy

解法：水题。

<hr>

542 01 Matrix

题意：给定一个01矩阵，请求出每个位置到<b>最近的0</b>的距离。距离计算按照<b>行+列</b>（即曼哈顿距离）为准。

难度：medium

解法：把所有0位置作为起点，进行<b>一次BFS</b>即可。奇怪的是，我以前写的BFS代码怎么没用队列？

<hr>

543 Diameter of Binary Tree

题意：给定一个二叉树，定义它的直径为树中<b>任意两点</b>能得到的<b>最长路径</b>的长度。

难度：easy

解法：既然是选任意两点，也就<b>不一定经过根节点</b>了。所以<b>在每层都递归</b>，然后拼出<b>左右最长路径之和</b>。注意，<b>单边的情况</b>也适用这种解法，另一边路径为0就是单边的。这题接近medium了，不太easy。

<hr>

544 Output Contest Matches

题意：给定n支队伍，你需要进行n//2组配对。给定1-n的排名，按照<b>强对弱</b>的原则匹配n//2组。并

难度：medium

解法：付费题。读了两遍才明白题目<b>到底在问什么</b>。名次1-n，按照(1,n)、(2,n-1)...之类进行<b>强弱配对</b>。然后按照一种递归嵌套的形式输出。实际的难点在于<b>拼凑这个字符串</b>，递归做吧。仔细观察<b>“(((1,8),(4,5)),((2,7),(3,6)))”</b>这个例子，找出规律。

<hr>

545 Boundary of Binary Tree

题意：给定二叉树，请按逆时针方向，返回所有<b>边界节点</b>。边界包括根节点、最左、最下、最右所有节点，注意去重。

难度：medium

解法：付费题。题目给的示例有点奇怪，为什么是`[1,3,4,2]`而不是`[1,2,3,4]`？这题的麻烦之处在于理解，有的情况就很迷惑。比如<b>“最下”</b>，是不是只有<b>深度最大的叶节点</b>才算最下？考虑到这几种情况的处理逻辑都不太一样，还是<b>各自写代码处理</b>好了。最后<b>统一做去重</b>，并拼装出完整结果。看了下以前的代码，看来我当年<b>没写出来</b>，或者说写得太难看了。这题可以说很考验<b>写递归的技巧</b>了，有难度。
<hr>

546 Remove Boxes

题意：有n个盒子，每个都有颜色，用一个整数表示。每次你可以选一些连续的同色盒子并拿走。如果总共有k个，则得分k*k。请问拿走所有箱子，你能得到的<b>最大分数</b>是多少？

难度：hard

解法：这题和之前的<b>312爆气球</b>非常像，也是<b>从中间消除</b>，然后<b>让两边拼到一起</b>。既然如此，那DP的思路也可以类似了。做DP之前，先要想清楚一个原则。如果有连续10个同色盒子，那我必然要消除10个，而不会选9个。因为10*10得到100分，做任何拆分都只会得到更少分数。所以对连续的同色盒子，是<b>不能做拆分的</b>。把数组按连续同色的方式进行<b>统计</b>，得到<b>统计数组a</b>。比如`[3,3,3,2,2,4,4,4,4,3,3]`，对应统计数组就是[(3,3),(2,2),(4,3),(3,2)]再对统计数组做<b>DP</b>。以本题的数据规模，O(n^3)的解法不难想到。用dp[i][j]表示第i-j断的最大得分。如果`a[i][0]==a[j][0]`，<b>两端颜色相同</b>，可以拼起来，则考察`dp[i+1][j-1]+(a[i][1]+a[j][1])^2`是否是更优解。除此之外，枚举ij之间的每个k，看看<b>两段拆分</b>的结果，也就是`dp[i][k]+dp[k+1][j]`。看了下当年写的代码，我开了个三维数组，这是没必要的。二维足够了。

<hr>

547 Number of Provinces

题意：给定一个<b>邻接矩阵</b>表示的<b>无向图</b>，求<b>连通分量</b>个数。

难度：medium

解法：把题目原话<b>翻译过来</b>就是这个。<b>并查集</b>解决。

<hr>

548 Split Array with Equal Sum

题意：给定一个n元素数组，请问是否存在下标`i<j<k`，使得<b>去掉对应三个元素</b>后，得到的<b>四个子数组的和都相等</b>。

难度：medium

解法：付费题。注意，要<b>去掉</b>ijk三个位置的元素。以n的规模，暗示你解法应该是<b>O(n^2)代价</b>的。那就这么做。<b>第一维i</b>，枚举。<b>第三维k</b>，枚举，但是要做检查。第二维j，需要夹在ik中间，而且我<b>只判断是否存在</b>，而不用找出它。怎么找j呢？用哈希表记录前缀和，看看你要找的某个前缀和是否存在即可。比如nums[0:i]这个前缀和是sm，那么我要找的值，就是`sm+nums[i]+sm`。j前面有<b>两段子数组+一个nums[i]</b>。看了下我以前的代码，不是这么做的。而是<b>从j开始枚举</b>，然后两边查找<b>ik</b>。确实<b>以前的做法更好</b>，因为思路是<b>对称的</b>。

<hr>

549 Binary Tree Longest Consecutive Sequence II

题意：298的变体。给定一个二叉树，你可以选任意两点作为端点，得到一个节点序列。请返回能得到的节点序列是连续序列的最大长度。连续序列指<b>公差为1的等差数列</b>。

难度：medium

解法：付费题。公差是+1或者-1其实无所谓，因为你总是<b>可以反着走的</b>。就用+1为准吧。那么对于二叉树，你毕竟<b>不能向上走</b>，所以还是采取<b>左右搜，然后拼接起来</b>的思路。比如，当前根节点的值为3，那我向左向右，都搜以3为起点，<b>能延伸多少步</b>等差数列。然后<b>用左+1拼右-1，或者左-1拼右+1</b>。比如左边是1-2-3，右边是3-4-5-6，那拼起来就是<b>1-2-3-4-5-6</b>。方向反过来，道理还是相同。对于<b>单边</b>的情况，这种解法也适用，相当于另一边的路径为0。

<hr>

551 Student Attendance Record I

题意：给定一个学生的出勤记录，P到A缺L迟。如果学生没有<b>2天以上缺席</b>，没有<b>连续3天迟到</b>，则可以得<b>出勤奖</b>。请判断是否能得奖。

难度：easy

解法：水题。

<hr>

552 Student Attendance Record II

题意：551的变体。规则就不重复了。现在给定长度n，请求出所有<b>可以得奖的</b>长度为n的记录个数。结果<b>模1e9+7</b>。

难度：hard

解法：很显然，这是个DP题。但怎么设计递推关系呢？<b>缺席</b>是个数，<b>迟到</b>是连续个数。缺席只能是0或1，迟到最多是连续2个，那么一天内的状态记录应该是2*3的，2表示A取值{0,1}，3表示L取值{0,1,2}。因为每天的记录只依赖<b>前一天</b>，则O(n)空间可以优化为O(1)。总体实现，还是老老实实用一个`dp[2][2][3]`的数组，把所有递推式子都写下来，这样<b>不容易出错</b>。我当年的代码很奇怪，现在<b>无论如何看不懂了</b>。这就是<b>关键思路不写注释</b>的恶果。现在让我重做这题，我会选择开个`dp[2][2][3]`数组。

<hr>

553 Optimal Division

题意：给定一个数组nums，表示一个除法式子`nums[0]/nums[1]/.../nums[n-1]`。你可以在其中任意添加括号来改变运算顺序。请求出能得到的<b>最大结果</b>。

难度：medium

解法：当然是<b>DP</b>了。按照被`除数/除数`考虑，那么为了结果最大，被除数应该大，除数应该小。所以问题就转化成了<b>同时求</b>某个子问题的<b>最大值和最小值</b>。对于dp_max[i][j]，枚举dp_max[i][k]/dp_min[k+1][j]的最大值。<b>反之亦然。</b>

<hr>

554 Brick Wall

题意：给定一面砖墙，由很多行组成，每行都有一些<b>长长短短</b>的砖头，每行的<b>总长度加起来相同</b>。现在从上到下画一条线，请找到一条线，使其<b>穿过最少的砖头数</b>。如果从砖头<b>边界</b>经过，则不算穿过。

难度：medium

解法：首先，你当然不会真的去划线，比如找个2.5、3.7之类的中间位置。而是会考虑一段区间被<b>几个叠起来的砖头</b>覆盖了。没错，<b>区间覆盖</b>。所以，其实可以所有值做一下统计，然后用区间覆盖的方式，统计一下哪个区间的覆盖次数最少，这个最少的次数就是答案。题目还告诉你，墙的总长度不超过20000，那就可以直接开这个数组来做<b>覆盖统计</b>了。因为是批处理，可以直接用<b>后缀和</b>的方式。当然，熟练的话，用<b>树状数组</b>完成也可以。还有一种<b>更简洁</b>的思路，一条线从上往下，总是要穿过一些砖头边界的。那么，不是穿过边界的，就一定是<b>穿过砖头中间</b>了。所以，对每个边界值，数一下<b>个数</b>，用<b>`高度-个数`</b>就是穿过的砖头数了。

<hr>

555 Split Concatenated Strings

题意：给定一组字符串，允许你<b>反转</b>其中的任意串。把处理完之后的串，<b>连成一个环</b>，再从环的任意一个字符处切开，变成一个长字符串。请返回能得到的<b>字典序最大</b>的字符串。

难度：medium

解法：付费题。首先反转好理解，如果反了之后<b>字典序更大</b>，那就反。连接好之后，对长字符串的移位比较，好像也没什么特别高效（其实肯定有的）的做法。直接逐个比较好了。题目限定的<b>字符串长度之和是1000</b>，就是告诉你，就算是<b>暴力比较</b>也让你过了吧。

<hr>

556 Next Greater Element III

题意：496的变体。给定一个整数n，请返回大于n，且数位组成和n相同（但顺序不同）的最小整数。且这个数必须在int32范围内，如果不存在或者超出范围，则返回-1。

难度：medium

解法：这个题目要求<b>有点呆板</b>了。int32毕竟是某些语言限制的，并非所有。有的语言<b>int是64位</b>，有的甚至可以自动转为<b>大数</b>的。回到问题本身，这个其实就是next permutation，<b>把n转成一个字符串</b>，找出这些数位的<b>下一个排列</b>，再转回整数。对结果检验一下，是否<b>>n且<INT_MAX</b>。比如132，之后是231、312、321，再之后就没了。

<hr>

557 Reverse Words in a String III

题意：151的变体。给定英文句子，只反转单词内的字母，不反转单词顺序。

难度：easy

解法：水题。

<hr>

558 Logical OR of Two Binary Grids Represented as Quad-Trees

题意：<b>四叉树</b>，定义就不讲了。现在给定两个四叉树q1和q2，都代表n*n的01矩阵。请求出它们的<b>逻辑或</b>，并用四叉树表示。

难度：medium

解法：`0|x=x,1|x=1`，按这两条规则就行了。递归时，在每一层对<b>2*2四个子问题</b>进行处理。对于整整、整分、分分三种情况，各自处理好就行了。<b>整</b>表示到达了<b>叶节点</b>，<b>分</b>表示下面<b>还有分叉</b>。这题的代码，其实比用嘴说还简单。看了下我以前的代码，明显<b>写复杂了</b>。用python的话，应该能在20行左右写完。

<hr>

559 Maximum Depth of N-ary Tree

题意：求N叉树的最大深度。

难度：easy

解法：和二叉树没什么不同的，递归即可。

<hr>

560 Subarray Sum Equals K

题意：给定数组nums和整数k，请返回其中子数组和为k的个数。

难度：medium

解法：子数组题，用哈希表统计<b>前缀和</b>即可。比如当前前缀和是x，那就找x-k的个数。

<hr>

561 Array Partition

题意：给定一个2n长度的数组nums，请分出n个数对`(a_i,b_i)`，使得这n对的最小值之和`sum(min(a_i,b_i))`最大。请返回这个<b>最大和</b>。

难度：easy

解法：easy？？？这肯定是脑筋急转弯，坑人的。既然条件讲的这么拗口，那我们仔细理解一下。要<b>最小值，求和，最大</b>。比如`[1,2,3,4,5,6]`，那应该取`1+3+5=9`，分组应该是`(1,2),(3,4),(5,6)`。可以用反证法论证，如果你做任何交换，要么<b>不影响结果</b>，要么<b>会让小值更小</b>，而大值不影响结果，从而得到<b>更小的和</b>。因此，这种选法是<b>最优的</b>，所得之和最大。所以，思路就是<b>排好序</b>，按<b>13579</b>这样选。具体证明过程就不写了，脑子里跑一下就行了。

<hr>

562 Longest Line of Consecutive One in Matrix

题意：给定一个01矩阵，请找出<b>连续1</b>的最大长度。方向可以是横、竖、正反对角线。

难度：medium

解法：付费题。没什么技巧，就是从这四个方向<b>都扫一下</b>就行了。注意<b>对角线</b>方向处理好下标边界，别弄错了。

<hr>

563 Binary Tree Tilt

题意：给定二叉树，返回每个节点的<b>倾斜值</b>之和。倾斜值的定义是<b>左右子树节点和</b>的<b>差值的绝对值</b>。

难度：easy

解法：虽然描述的挺复杂，不过还是递归处理就好了。<b>求子树和，算差值，向上返回，再求和</b>。对于easy难度，这个要求确实挺麻烦的。不过代码确实很短，用python如果写得极简的话，3-5行代码应该足够了。

<hr>

564 Find the Closest Palindrome

题意：给定一个字符串表示的整数n，请找出<b>不等于它</b>，且<b>和它最接近</b>的回文数。

难度：hard

解法：限定了n的长度不超过18位，这其实是在64位整数范围内，因此可以用长整型来表示数据。当然，用字符串也可以。因为是回文数，那么我考虑<b>从中间位开始变</b>，这个变化是<b>最小的</b>。因为两边必须对称，变动<b>最低位</b>也等于变动<b>最高位</b>。举例子，比如<b>13579</b>。让它变小，那就是13531，中间的5不动，下面变小即可。让它变大，那就是13631。对于偶数位的情况，123456。变小，就是123321。变大，就是124421。那么129934呢？变小，是129921。变大，是130031。所以你可以只考虑一半，让这一半“+1”。思路不算很复杂，不过代码写得挺复杂。还是<b>实现得不太好</b>。注意一些<b>边界case</b>，比如99999，下一个是100001，上一个是99899。

<hr>

565 Array Nesting

题意：给定数组nums，nums是`0~n-1`的一个排列。选定一个起始下标k，依次生成<b>有限集合</b>`s(k)={nums[k],nums[nums[k]],...}`。给定k的所有取值，请求出s(k)的<b>最大大小</b>。

难度：medium

解法：这个就是非常经典的<b>置换群</b>（permutation group）。<b>群论</b>并不在基础的工科课表里，没学过很正常。但置换群属于其中一种挺有意思的组合数学结构。回到问题本身，这样不断取nums[]运算，总会形成一个环。比如排列`[1,3,2,0]`，用置换群可以写作`(0,1,3)(2)`，表示013构成一个循环，2构成一个循环。<b>计算置换群的总代价是O(n)</b>，因为你在算出所有循环时，每个值<b>只访问一次</b>，不会重复的。

<hr>

566 Reshape the Matrix

题意：实现类似MATLAB（或者numpy）里的reshape功能，将<b>二维矩阵</b>打成<b>一维数组</b>。

难度：easy

解法：多维数据的存储方式，默认是<b>行优先（row-major）</b>的。或者对于n维数据，总是<b>第i维优先于第i+1维</b>。n行m列，`i*m+j`。在做矩阵运算、缓存命中等<b>特定场景</b>下，<b>列优先（column-major）</b>也是有应用的。

<hr>

567 Permutation in String

题意：给定字符串s1和s2，判断s2的某个子串是否是s1的排列。

难度：medium

解法：s2的子串，是，s1的排列。所以，不能把s1、s2直接排个序。得用字符统计的办法。s1、s2都比较长，O(n^2)的匹配也不可接受。还是滑动窗口吧。所幸，这题的滑动窗口很简单，因为<b>窗口大小是固定的</b>。这样就非常简单了，每次<b>移动一位，调整窗口</b>，<b>判断字符统计</b>是否相同。搞定了。

<hr>

568 Maximum Vacation Days

题意：给定n个城市的有向图，标号`0~n-1`。你<b>从0点出发</b>，每周可以<b>在一个城市度假</b>或者<b>在周一</b>飞去<b>另一个城市度假</b>。第j周在第i城市的假期数是days[i][j]。请安排行程，以获得最长的假期天数。

难度：hard

解法：付费题。题目又长又复杂，读完都费老劲。图论题，可又像是DP题。应该是<b>图论+DP题</b>。所以，可以采取dp[i][j]表示<b>第j周在第i城</b>能得到的<b>最大假期之和</b>，然后以此进行<b>BFS</b>。BFS起点当然是从0城出发。讲道理，这个hard也不能说思维特别难，但<b>图论+DP</b>这个组合也<b>够麻烦了</b>，hard确实合理。看了下我的老代码，没用队列，<b>换了种方式做BFS</b>。思维是一样的。

<hr>

572 Subtree of Another Tree

题意：给定两个二叉树t1和t2，判断t2是否和t1的某个子树（包括自身）完全一样。

难度：easy

解法：递归暴力匹配的解法就不说了。重点说一下问题转化的思维。如果用什么奇怪的办法，直接做到<b>线性匹配两棵树</b>，肯定很难想。但<b>字符串匹配</b>的O(n+m)解法，你知道。<b>二叉树序列化为字符串</b>的O(n)解法，你也知道。两者结合起来，不就是线性的解法了？<b>问题转化</b>，这个思维非常重要。不只是做这些应试题，是整个人生的思维。

<hr>

573 Squirrel Simulation

题意：在一个二维n x m矩阵上，给定<b>松鼠、树、一些松子</b>的位置。松鼠每次能<b>拿一个松子放到树下</b>，直到拿完。请求出松鼠移动的<b>最小总距离</b>。

难度：medium

解法：付费题。除了一开始松鼠拿松子之外，之后每次松鼠都是<b>从树的位置出发</b>，所以对于这些松子，顺序都无所谓了。因此，我要找一个<b>松鼠相对于树</b>离得最近的松子作为<b>第一颗</b>。后面的每颗，就<b>无所谓顺序</b>了。

<hr>

575 Distribute Candies

题意：给定n个糖果，每个的种类用一个整数表示。如果n是偶数，从中选出一半糖果，最多能得到多少不同种类？

难度：easy

解法：用哈希表对数组的值进行<b>计数</b>。然后<b>按key不断轮询</b>，每轮询一个，计数-1。减到0了，则删除对应key。这样能保证每次取的元素都<b>尽量不相同</b>。取到了n/2个元素时，结束轮询。取到的元素都放入<b>集合</b>中，<b>统计个数</b>即可。当然，这题其实是<b>脑筋急转弯</b>。直接`min(len(nums)//2,len(set(nums)))`就搞定了，想想为什么？很无聊，对吧。

<hr>

576 Out of Boundary Paths

题意：给定一个m x n矩阵，有个球，每次可以上下左右移动一格。给定<b>初始位置、最多移动步数</b>。请问有多少种办法可以<b>让球出界</b>？对结果<b>模1e9+7</b>。

难度：medium

解法：数据规模并不大，<b>不用想得太复杂</b>。从起点开始，执行BFS。对于BFS到边界时，如果还有步数，就可以让球出界。这个BFS最好<b>不用队列</b>，而是用<b>两个交替的哈希表</b>来做。看了下我以前的代码，比想象中的复杂。现在让我写，应该比这个短得多了。

<hr>

581 Shortest Unsorted Continuous Subarray

题意：给定一个数组nums，如果存在一个子数组nums[i:j+1]，对应这个子数组排序，就能使整个数组都有序。请找出符合条件的<b>最短子数组</b>的长度。

难度：medium

解法：题目是真拗口，但要问的东西其实不难。如果中间某段nums[i:j+1]有序了，能让整个数组都有序，那说明两点：`nums[i-1]<=min(nums[i:j+1])`，`nums[j+1]>=max(nums[i:j+1])`。因此，你可以从两边逐渐确定这个边界。比如<b>左边</b>，从0开始，看看nums[i]是否<=右边nums[i+1:n]的最小值，是的话就右移，<b>直到不满足为止</b>。右边的情况，<b>反之亦然</b>。因为<b>后缀最小</b>和<b>前缀最大</b>都是O(n)代价可以得到的。因此这个边界可以在<b>O(n)代价</b>确定下来。如果最后发现边界是`i=0,j=n-1`，说明要<b>排序整个数组</b>；如果发现边界是`i>j`，则说明数组已经有序了，<b>不用排序</b>。

<hr>

582 Kill Process

题意：给定一些id用整数表示的进程，除了<b>根进程</b>外，其他进程都有1个父进程，0-多个子进程。整个结构是<b>一棵进程树</b>。给定一个你<b>要终止的进程id</b>，返回所有被终止的<b>进程id列表</b>。

难度：medium

解法：付费题。既然是树，那就<b>建立这棵树</b>，然后<b>遍历并删除</b>对应的终止进程<b>所在的子树</b>。只为了完成这题的话，用<b>并查集</b>处理也很方便。直接把kill的根节点指向自己，这样<b>这棵子树就孤立了</b>。再遍历进行<b>find操作</b>，就能得到<b>所有属于这个子树</b>的进程。

<hr>

583 Delete Operation for Two Strings

题意：给定字符串s1和s2，每次允许你从其中一个串删除1个字符。请问至少多少次操作，可以让两串相同？

难度：medium

解法：按<b>子序列</b>的逻辑判断。为什么是子序列？因为<b>删字符</b>，子序列就是这么得到的。比如s1和s2目前的最长公共子序列是ss。那么子序列是对称的。s2和s1，子序列也是ss。我能不能得到比ss这个更长的结果？肯定不能啊。所以，转化为<b>LCS问题</b>了。教科书级的<b>DP问题</b>，O(n^2)时间O(n)空间解决。

<hr>

587 Erect the Fence

题意：给定二维平面上，一些树的坐标。请用一个篱笆把所有树围起来。为了尽可能省材料，篱笆要<b>贴着一些树</b>。请返回所有篱笆贴着的树的坐标。

难度：hard

解法：这下好了，<b>凸包</b>都出来了。除了搞竞赛的人必须会，一般人不一定学过。<b>没学过，肯定写不出这算法。</b>凸包是什么呢？凸包就是一个<b>最小的凸多边形</b>，能把点集都围进去。凸多边形是什么呢？就是每个角都<b>不超过180度</b>的多边形。这个算法是<b>用叉积的符号</b>来判断一个点是否应该被包含在<b>凸包的点集</b>里。脑子里想象一下，<b>左转右转</b>。之前已经有一题<b>469</b>，用叉积来判断<b>凸多边形</b>了，是同一个原理。具体实现凸包计算，还有<b>好几个细节</b>，代码也不短。搜两个关键词<b>“convex hull”和“Graham scan”</b>。凸包还有很多种算法，当然每个的<b>核心思想</b>都差不多。

<hr>

588 Design In-Memory File System

题意：设计一个<b>简单的文件系统</b>，能查看、创建目录，能读写文件。

难度：hard

解法：付费题。做的事情很具体，算是一个<b>系统设计题</b>了。既然有目录，有文件，你会如何组织？最直接的方式，是直接<b>一层哈希表映射</b>。稍微好点的方式，是建立目录树，并提供目录、文件两种类型。对文件，则提供读写API。这样的话，起码从功能上，它有<b>文件系统</b>最基本的样子了。看了下我的代码，写了两百多行，也算是<b>没偷懒</b>了。除了对基本功能的实现，<b>OOP</b>的一些知识也是应该体现的。

<hr>

589 N-ary Tree Preorder Traversal

题意：N叉树前序遍历。

难度：easy

解法：和二叉树没有什么不同。

<hr>

590 N-ary Tree Postorder Traversal

题意：N叉树后序遍历。

难度：easy

解法：同589。

<hr>

591 Tag Validator

题意：给定一段HTML代码，请检查其中的所有`<xxx></xxx>`<b>标签开闭是否匹配</b>。另有`<![CDATA[xxx]]>`作为特殊标签，其中的内容即使包含了标签，也要<b>解释为普通字符</b>。

难度：hard

解法：这题作为这么早的题，<b>点赞数低得出奇</b>，显然是<b>恶评如潮</b>。原因无非是<b>过多的边界case</b>，冗长而无聊的解法，基本不用动脑，只需要<b>无限的耐心</b>。因此，作者出这个题就是用来<b>折磨人</b>的。

<hr>

592 Fraction Addition and Subtraction

题意：给定一个字符串表示的<b>分数加减法算式</b>，请求出结果。用<b>最简分数</b>形式返回。

难度：medium

解法：分数本身的运算就不说了，<b>通分</b>之后加减即可，结果要<b>约分</b>。除此之外，要做的就是<b>字符串解析</b>了，这个小心处理即可。

<hr>

593 Valid Square

题意：给定二维平面4个点，判断能否构成一个正方形。

难度：medium

解法：正方形的条件很严格，计算<b>6对距离的平方</b>。如果满足`1:1:1:1:2:2`，就是正方形。对这个判定，我想不出反例。

<hr>

594 Longest Harmonious Subsequence

题意：定义<b>最大值最小值相差1</b>的数组为<b>和谐数组</b>。给定一个数组nums，请求出<b>最长和谐子序列</b>的长度。

难度：easy

解法：毕竟元素时整数，两个不同值最小差也是1。因此要满足<b>和谐子序列</b>的话，你<b>必须选</b>两个相邻的不同值。对数组的元素<b>计数</b>，并对key排序。找<b>key相邻且值相差为1</b>的情况，答案就在这里面。

<hr>

598 Range Addition II

题意：370的变体。给定m x n矩阵，初始全为0。每次执行一个操作(x,y)，表示把<b>[0,x)行、[0,y)列</b>所有元素都+1。执行完所有操作后，返回矩阵中<b>值为最大值的个数</b>。

难度：easy

解法：矩阵前缀和，这种都有一个通用技巧。<b>用后缀方式，反着来。</b>比如在(x,y)执行操作，那就只给a[x][y]加1。等所有操作完了之后，<b>统一进行累加</b>。累加的时候，按后缀方式，<b>从下往上加，从右往左加</b>。不知道<b>这个技巧</b>的话，这题可就不easy了。

<hr>

599 Minimum Index Sum of Two Lists

题意：给定两个字符串数组l1和l2。找出所有<b>下标和最小的公共串</b>。如果存在多个，返回顺序任意。

难度：easy

解法：描述的挺复杂，不过，<b>一步步来就行了</b>。判断交集，检查下标位置，求和，判断和是否最小。<b>作为easy题，这题倒是挺麻烦的。</b>

## 0601 - 0700

600 Non-negative Integers without Consecutive Ones

题意：给定正整数n，请返回[0,n]中，二进制表示里<b>没有连续的1</b>的整数个数。

难度：hard

解法：<b>数位DP题</b>。比如我们考虑<b>可以有前置0的k位的二进制数</b>，如果最高位是1，则下一位必须是0，变成dp[k-2]；如果最高位是0，变成dp[k-1]，所以`dp[k]=dp[k-1]+dp[k-2]`，就是<b>斐波那契数</b>。<b>再往下就讲不清楚了</b>，主要是我当年写的代码，现在看不明白了。

<hr>

604 Design Compressed String Iterator

题意：请设计一个以<b>游程码</b>压缩的字符串<b>作为输入</b>的迭代器。访问时，逐个返回字符。比如`aaacbb`，压缩后的形式为`a3c1b2`。

难度：easy

解法：付费题。水题。

<hr>

605 Can Place Flowers

题意：给定一个长条形的花圃，用一个01数组表示。1表示有花，0表示空位。如果不允许<b>相邻两个位置</b>都种花，请判断能不能<b>再种n朵花</b>？

难度：easy

解法：从左往右扫。按<b>间隔位置</b>，直接种就行了，<b>贪心策略</b>。

<hr>

606 Construct String from Binary Tree

题意：用`root(left)(right)`的形式，<b>递归序列化</b>一棵二叉树，但是对于空的子树，则直接<b>略去空括号</b>。如果左子树空，但<b>右子树非空</b>，则需要保留<b>左边的空括号</b>。

难度：medium

解法：规则定义得很清楚了。<b>递归处理</b>，注意<b>左空右不空</b>的特殊情况即可。

<hr>

609 Find Duplicate File in System

题意：给定一些<b>目录</b>，以及目录中<b>所有文件和对应内容</b>。请输出所有<b>内容重复的文件</b>路径。按<b>重复内容进行分组</b>，相同内容的在一组。

难度：medium

解法：算法上没有难度，所有工作量都在<b>路径解析</b>上。解析好了，按文件内容<b>做一下哈希，归类即可</b>。当然，实际的文件系统，则是计算<b>内容签名</b>，然后<b>对签名做哈希</b>了。

<hr>

611 Valid Triangle Number

题意：给定一个数组nums，请返回其中三元组`(nums[i],nums[j],nums[k])`的个数，使得三个值可以<b>构成三角形的三边</b>。

难度：medium

解法：首先对nums<b>排序</b>，用三指针ijk，<b>ij二维枚举</b>。第三维k从j+1开始。不断往前移动，直到<b>出界或者不满足要求</b>为止。因为已经有序了，要求就是一条：`nums[i]+nums[j]>nums[k]`。前两维的复杂度是O(n^2)，<b>k指针的移动</b>则是<b>均摊O(1)，总代价O(n)</b>的。为什么？因为k虽然要持续进行判断，但它的移动是<b>从不回头</b>的，至多走到出界，就不再变了。解法的总代价来自<b>ij的枚举</b>，复杂度<b>O(n^2)</b>。

<hr>

616 Add Bold Tag in String

题意：给定一个字符串s和一个词表dict。请将s中所有出现在dict里的子串，用`<b></b>`<b>加粗标签</b>括起来。如果多个词表中的词存在<b>重叠情况</b>，则对<b>整个重叠部分</b>用一个`<b></b>`标签括起来。比如`dict={aab,bbc}，s=xyaabbczz`，则加粗结果为`s'=xy<b>aabbc</b>zz`。

难度：medium

解法：付费题。按照单词长度1000，长串s长度1000的范围，似乎暴力匹配也可接受。但这样效率还是太低了。既然是带重叠的多模式匹配，用<b>类似KMP思路</b>，在一个有向图上建立fail指针跳转的的<b>AC自动机</b>最合适。但这个<b>太高端了</b>，我还是怂了吧。最后选择了折中办法，<b>建个字典树，方便匹配</b>就行了。

<hr>

617 Merge Two Binary Trees

题意：给定两个二叉树t1和t2，请按对应位置进行合并。如果该位置两节点都存在，则值进行相加；如果只存在一点，则取值以该节点为准。

难度：easy

解法：<b>递归解决</b>，注意递归写法。

<hr>

621 Task Scheduler

题意：有一个字符数组，每个字符A-Z，表示<b>一种任务</b>。给定这些任务，要求同一类任务两次执行必须间隔n个CPU时间段（叫时钟周期好像不合适）。如果允许你<b>重排任务顺序</b>，请问完成这所有任务，至少需要多少个时间段？

难度：medium

解法：乍一看有点难，仔细想想和之前<b>358题</b>很像。也是同字符必须<b>间隔多少位</b>。这样的话，用<b>队列</b>来处理比较好，并加上一个<b>cd冷却机制</b>。没有<b>冷却足够</b>的，就不能入队。还有一种思路，就是借鉴<b>575题</b>的贪心思路，将数组重排一下，<b>让相邻元素尽可能不相同</b>。具体做法就不说了。还是要检查cd，如果cd不够，就要加上<b>等待时间</b>。

<hr>

622 Design Circular Queue

题意：设计一个<b>循环单向队列</b>，首尾相连的那种。

难度：medium

解法：现在大家都<b>用惯了双向队列deque</b>，所以都不太考虑这些问题了。这题算是复习一下<b>基础数据结构</b>。普通的<b>单向队列</b>，最基本的设计方式是<b>单链表</b>，头尾移动的那种。如果要循环队列，那<b>肯定是个圈圈</b>。这个圈圈还是有头尾，只不过头向前了，尾也向前，中间的部分是数据。都在一个圈圈里绕，但<b>整个环的容量是不能扩大</b>的，不论头尾目前在哪个位置。对于头尾边界，你可以<b>单独留出一个空位</b>，避免<b>头尾碰到一起</b>。也可以用一些下标处理来做到这点，方法不止一种。（其实你要扩容也行，用<b>环形链表，插入节点</b>就可以了。）

<hr>

623 Add One Row to Tree

题意：给定二叉树，请在第n行所有<b>合适位置</b>，插入值为val的节点。对于下移的节点，按照<b>左子树向左，右子树向右</b>的原则进行移动。

难度：medium

解法：这个题主要是得把题目读懂。对于第n-1层，在它下面所有对应位置，也就是<b>每个n-1层节点的左右位置</b>插入。对于之前的第n层已有节点，则按照<b>左的往左，右的往右，下降一层</b>。按这个原则递归往下找就行了。

<hr>

624 Maximum Distance in Arrays

题意：给定m个有序数组，你可以从<b>2个数组</b>各选<b>1一个元素</b>。请找出能得到的<b>差值的最大值</b>。

难度：medium

解法：既然要差值最大，肯定是<b>一个尽量大，一个尽量小</b>。那就首先找出每个数组的最大最小值。然后求出每个数组<b>除自己之外</b>，<b>其他数组</b>的最大最小值。对每个数组，用`自身最大-其他最小`、`其他最大-自身最小`两种情况，对m个数组都判断一遍，可以得到最终结果。总代是`O(sum(len(arrays[i])))`，也就是<b>遍历所有数组所有元素一次</b>。

<hr>

625 Minimum Factorization

题意：给定一个正整数a，请找出最小的正整数b，使得b的<b>各位数相乘</b>恰好等于a。如果不存在答案或者答案超出了int32范围，则返回0。

难度：medium

解法：付费题。标题叫最小因数分解，其实是暗示你，肯定要做一下<b>因数分解</b>。如果一个数的<b>质因数都超过了10</b>，比如13，那你不可能用数位相乘得到了。如果分解得到的，只有<b>2、3、5、7</b>，那就<b>进行组合</b>。33得9、222得8、23得6，这样能拼出尽可能小的数位。再把这些数位按升序排列，就是最小的b了。检查b是否在<b>int32范围内</b>。每一步都不难，不过加起来还是挺麻烦的。

<hr>

628 Maximum Product of Three Numbers

题意：给定一个数组，元素可以是<b>任意整数</b>。请找出三个元素，使得<b>乘积最大</b>。返回最大乘积。

难度：easy

解法：先排个序。如果存在<b>3个最大的正数</b>，则取<b>后3个</b>。如果存在1个最大正数和两个最小负数，则取<b>后1和前2</b>。如此继续写几个<b>if else elif</b>。方法比较笨，所幸情况也没有那么多种。对于easy难度，这个题算比较麻烦了。

<hr>

629 K Inverse Pairs Array

题意：对于数组nums，如果`i<j,nums[i]>nums[j]`，则称为一个<b>逆序对</b>。给定整数n，请返回1~n的排列中，逆序数总和为k的排列的个数。结果可能非常大，模1e9+7返回。

难度：hard

解法：之前有个经典题目，是用O(nlogn)时间，求一个数组的<b>逆序数总和</b>。做法是在<b>归并排序</b>的同时进行统计。这个，则是要算1~n的排列里，逆序为k的有多少个。想了10分钟毫无思路，<b>g了</b>。写了600多题的题解，这是第一道<b>完全没思路</b>的题。看了下当年的代码，用dp[i][j]表示<b>前i个元素，逆序数为j</b>的个数，<b>DP解法</b>。奇怪...怎么如今就一点想不起来了？

<hr>

630 Course Schedule III

题意：207的变体。有标号1-n的课程，每门课有一个<b>时长duration</b>、一个<b>最晚完成时间lastDay</b>。你从<b>第1天</b>开始，不能同时学两门课，请问最多能完成多少门课？

难度：hard

解法：首先，注意理解题目的边界。比如<b>lastDay=10</b>，表示要在第10天结束前，也就是<b>第11天开始前</b>，把课学完。这个题目处理的是区间，有一些区间，你不能让区间重叠。给定一个总区间[0,max(lastDays)]，请问这个区间里<b>最多包含</b>多少个<b>互不重叠的区间</b>？注意，如果你<b>第x天</b>完成了课，必须<b>第x+1天</b>才能学新课。有一种直白的解法，就是O(n^2)的DP，针对每个区间，往前比较是否存在重叠。具体不多讲了，因为<b>数据规模</b>不接受这种效率。用一种更<b>有序</b>的办法。首先对所有区间排序，按照lastDay升序排列，然后用一个<b>最大堆</b>。从<b>now=0开始计时</b>，只要上课时间来得及，就<b>不断往堆里加课</b>，同时更新now。关键在于，如果时间<b>来不及了</b>，就从堆里取出duration最长的课，给它<b>替换掉</b>。因此，才用<b>最大堆</b>。<b>替换完成后</b>，剩下的就是可以上完的课。想不到这个“替换”思路的话，这题就很难搞定了。我当年想出来了，这次没想出。

<hr>

632 Smallest Range Covering Elements from K Lists

题意：你有k个有序数组。请求出最小的区间[a,b]，使得区间包括了至少每个数组的一个元素。

难度：hard

解法：怎么连续几题都是hard...这题乍一看没什么思路，仔细想想，有点像之前<b>k个有序数组做归并</b>的思路。之前是<b>用一个堆</b>，把k个表头放进去，不断拿到最小元素。这次你还是需要把k个表头放进去，并不断前进。但这次你需要找的，是任一时刻，这个结构里的<b>最大值和最小值</b>。因为这个结构总是包含了<b>k个数组的各1个元素</b>。让这个<b>max和min之差尽可能小</b>就是最终目的。所以可以用map来代替heap做同样的事情，因为<b>map</b>可以随时找到<b>最大最小key</b>。让k个指针往前移动，直到某个指针走到头了，就停止。因为这时你<b>凑不够k个元素了</b>。在这个过程中，不断更新结果，最后返回。看了下当年的代码，我没有用map，而是直接每次以<b>O(k)代价</b>找出最大最小值了。看来这种<b>暴力解法</b>，也过了。如果现在重做一次，我肯定用<b>OrderedDict</b>了。

<hr>

633 Sum of Square Numbers

题意：给定整数c，判断是否存在整数a、b，使得`a^2+b^2=c`。

难度：medium

解法：平方嘛，int32范围内的<b>完全平方数</b>，个数自然就是int16这个量级，大概几万个。可以预先计算好，然后<b>a进行遍历，b用O(1)代价查找</b>。总代价是O(sqrt(c))。

<hr>

634 Find the Derangement of An Array

题意：给定1-n的排列，如果每个i位置的元素都不是i，称为一个<b>“错排”</b>。请返回n位错排的个数，结果模1e9+7返回。

难度：medium

解法：付费题。看到这种题就觉得有点难，总是容易晕。比如我们考虑第1位，不能是1，那么可以是2-n。那么2-n的情况是<b>对称</b>的吗？比如我第一位取k，则后面要由`{1,2,3,...,k-1,k+1,...,n}`组成。把所有所有元素都-1，变成了`{0,1,2,...,k-2,k,...,n-1}`。<b>推了十分钟，没推清楚。</b>查了资料，发现竟然有专门的<b>错排公式</b>，`!n=(n-1)(!(n-1)+!(n-2))`。注意这个感叹号在左边，<b>不是阶乘</b>。不知道这个，怎么做得出来？又查了下，这个公式的<b>证明也不简单</b>，有点循环论证的味道。可以用<b>归纳法</b>，对公式进行展开来证明。但显然，我不认为一个普通水平的<b>软件工程师</b>，可以凭一些推导来<b>发现这个公式</b>。网上的推导过程我也看了，没有讲解的话，实在想不出来。有这个公式的话，直接<b>O(n)代价</b>递推就行了。这明显是<b>不讲道理</b>。

<hr>

635 Design Log Storage System

题意：设计一个<b>日志存储和检索</b>系统。日志时间戳格式为`YYYY:MM:DD:hh:mm:ss`，存储的每条日志<b>有一个id、一个时间戳</b>。对于检索，给出一个起始start、终止end时间戳，和一个检索粒度。<b>粒度</b>可以是任意一层。请根据<b>粒度要求</b>，返回`[start,end]`之内的结果，返回结果没有顺序要求。

难度：medium

解法：付费题。不用想得太复杂，首先，做好字符串解析，一律把结果按<b>长整数</b>的<b>时间戳</b>保存，而且插入时始终<b>保持升序</b>。关于粒度，其实可以这么想。与其处理`[start,end]`，不如变为<b>`[start,end+1)`</b>。这样，对于不同的granularity，这个<b>+1操作</b>就加的不同值。比如<b>小时</b>，那我就<b>+3600</b>；比如<b>天</b>，我就<b>+86400</b>。然后，进行<b>二分搜索</b>，确定上下界就行了。

<hr>

636 Exclusive Time of Functions

题意：在一个<b>单线程CPU</b>上执行程序。给定<b>函数调用</b>的时间日志，格式为`函数id:起始或终止:时间戳`，比如`2:start:3`表示<b>函数2在时刻3启动</b>。定义<b>独占时间</b>为一个函数在CPU上执行，且<b>没有递归调用其他函数时</b>的时间。请统计所有函数的独占时间，返回统计结果。

难度：medium

解法：题目讲的很复杂，<b>科普和教育意义</b>为主。函数调用栈，<b>确实是个栈</b>。所以，对logs中的记录先做好解析，按<b>(时间戳,起始终止)</b>优先级进行<b>排序</b>，然后逐条<b>处理日志</b>。函数开始了，就<b>入栈</b>；函数结束了，就<b>出栈</b>。每次出入的时候，记录一下<b>对应函数的独占时间</b>。函数调用，出入平安。

<hr>

637 Average of Levels in Binary Tree

题意：给定一个二叉树，请按行统计<b>每行节点值</b>的<b>平均数</b>。

难度：easy

解法：随便怎么遍历，按行<b>求和+统计个数</b>，然后除一下。

<hr>

638 Shopping Offers

题意：店里有n件商品，各自价格为price[i]。你需要买的各种商品个数为needs[i]。<b>特价组合</b>可以提供打包特价，比如一个n+1元素的数组special，前n个表示商品个数，第n+1个为总价格。给定一些不同的特价组合，请求出你买到所需商品，花的<b>最少价格</b>。要求不能为了凑满减而<b>多买东西</b>。

难度：medium

解法：看着很复杂，但难度不是hard。是在暗示你，<b>别想太多</b>。n很小，special稍大一点。那么，就用<b>比较暴力的DP</b>？或者<b>直接暴力搜索</b>？DP想了下，没想出很好的思路。还是暴力搜吧。看了下之前的代码，用了个稍微取巧的小优化。因为各个值都不超过10，直接当做数位处理，叠成一个十进制数了。这也算是<b>“位压缩”</b>吧，十进制位。然后用背包问题的思路解决。那么这题就是个<b>多维背包</b>问题了。对于<b>单买一件商品</b>，则相当于一个`[0,...,0,1,0,...,price[i]]`的<b>“特价组合”</b>。这么一看，这题确实很复杂，<b>还得想很多</b>。

<hr>

639 Decode Ways II

题意：91的变体。按照`A->1,B->2,...,Z->26`的一一对应，对一个字符序列编码，得到一个数字串。现在给定一个<b>数字串</b>，但其中可能包含<b>代表任何数字的“*”</b>，请问有多少种<b>解码方式</b>？

难度：hard

解法：O(n)代价，<b>DP思路</b>解决。对于当前第i位，我总是考虑<b>当前1位</b>或者<b>当前2位</b>。比如当前位是7，那就只能考虑1位；比如当前位是1，就可以考虑<b>1或2位</b>；比如当前是0，<b>那就不可能</b>。因为在上一位时，就应该把这个0考虑进去了，<b>开头是不可能是0的</b>。把这些情况考虑清楚后，写出<b>线性的递推关系</b>。对于“*”，则枚举0-9的各种可能性，都处理一下。看了下当年的代码，居然这么长...我以为没那么复杂呢。

<hr>

640 Solve the Equation

题意：给定一个包含<b>未知数x、整数、加减法</b>的<b>一元一次方程</b>。请解出x。

难度：medium

解法：有意思。主要工作是<b>字符串解析</b>，把加减法都归拢一下，x也归拢。最后要处理三种情况：<b>唯一解、无解、无数解</b>。这些规则在初中数学课都讲了，就不细说了。

<hr>

641 Design Circular Deque

题意：设计一个循环双向队列。各种功能就不细说了，有<b>容量上限</b>。

难度：medium

解法：622题是循环队列，这题是循环双向队列了。其实双向队列，用双向链表是最直观的（如果你不用下标访问的话）。如果要支持下标访问，那还是用一个<b>循环数组</b>，<b>头尾位置</b>都可以<b>向前向后</b>。这个算法本身不难，但都是<b>下标挪来挪去</b>，很容易出错。因此，这题<b>极其考验耐心和仔细</b>。看了下我之前的代码，用python都写了很长，<b>果然很麻烦</b>，是道难题。

<hr>

642 Design Search Autocomplete System

题意：用过搜索引擎吧？设计一个类似的<b>搜索补全系统</b>。给定用户输入的搜索内容，以“#”结尾。对于每个前缀串，都输出<b>前缀匹配</b>的<b>热度前3</b>的词条。每次用户<b>输入一个字符</b>，执行一次匹配。当用户输入“#”时，搜索完成，<b>输入的词条也加入词条库</b>。

难度：hard

解法：付费题。这题目太长了，描述得超级具体。算是个费劲的<b>系统设计题</b>吧。从算法角度，对已有词条的记录，肯定是用<b>字典树</b>最好，因为做的都是<b>前缀匹配</b>。除此之外，要注意用户输入的新句子，<b>也要入库，参与统计</b>的。在字典树的基础上，对于<b>热度排序</b>，用了一个SortedSet作为优化。因为题目要求是按照`(热度,字典序)`排序，插入set的元素自然也是一个元组。整个实现还是很麻烦的，包括字典树的查找、插入、更新操作。<b>确实是难题。</b>

<hr>

643 Maximum Average Subarray I

题意：给定一个数组nums和整数k，请求出长度为k且平均值最大的子数组。返回平均值。

难度：easy

解法：因为窗口大小是固定的，直接滑动，判断每个k长度子数组的平均值就行了。总代价是<b>O(n)</b>。

<hr>

644 Maximum Average Subarray II

题意：643的变体。给定数组nums和整数k，请求出长度不小于k，且平均值最大的子数组。返回平均值。

难度：hard

解法：付费题。这次难度是hard了，说明不一定用简单的<b>滑动窗口思维</b>能搞定。数据范围也暗示你，不能用O(n^2)暴力解法。用<b>滑动窗口</b>想了10分钟，毫无思路，放弃。碰到这种找最大、最小，但又让你束手无策的题目，就想想，能直接对这个值<b>二分搜索</b>吗？想了下，<b>好像可以</b>。为什么可以？因为这个<b>单调性</b>是存在的。比如min(nums)和max(nums)作为边界，取一个值x在这中间，看能不能使某个<b>长度不小于k</b>的子数组，其<b>平均值大于等于x</b>。能想到这儿，就快做出来了。虽然能想出这个，就挺费劲了。比如每次检查的平均值是x，那就把所有nums[i]-x，然后<b>以0作为判断位置</b>，这样就不用操心<b>平均数、除法</b>之类的问题了。具体做法还是看代码吧。<b>有点难写，且很难想</b>的一题。

<hr>

645 Set Mismatch

题意：给定1-n共n个数，其中某个数x被替换成了y，且x、y都在1-n范围内。请找出<b>缺失的x和重复的y</b>。

难度：easy

解法：既然是easy，用最朴素的<b>哈希表计数</b>就可以了。如果要玩一些杂技的话，就用那个<b>在原数组上叠罗汉</b>做计数的办法。

<hr>

646 Maximum Length of Pair Chain

题意：给定一些区间`[x,y]`，如果`p1=[x1,y1],p2=[x2,y2]`，且`y1<x2`，则两区间可以连起来。请找出能连起来的区间的<b>最大个数</b>。

难度：medium

解法：这个问题，如果视为(x,y)的二维<b>最长递增子序列</b>，也可以。这样你可以很轻易想出<b>O(n^2)的DP解法</b>。但是<b>O(nlogn)的LIS解法</b>，就很难想了。实际上这题和LIS<b>不完全一样</b>，就因为它是<b>(x,y)区间</b>，而不是一个值。这题的聪明之处在于<b>贪心策略</b>，贪心就可以搞定。首先，<b>区间排序</b>是必做的。排序之后，每次你其实只关心当前的<b>最右端</b>在哪儿，也就是max_y。对于下一个区间(x,y)，如果`x>max_y`，则可以<b>扩一个区间</b>，且更新max_y为y。想想为什么我们<b>不关心之前的x</b>？因为那已经过去了，<b>和扩区间没有关系了</b>。还有一点补充，关于排序的方式。你用`(x,y)、(y)`这两种排序方式，其实都可以做。最终关心的，还是y维度。x维就算是<b>乱序也不影响结果</b>。

<hr>

647 Palindromic Substrings

题意：给定字符串s，返回s的回文子串的个数。

难度：medium

解法：这题容易。以<b>每个位置为中心</b>，往两边检查<b>对称性</b>即可。对<b>奇偶情况</b>，要分开处理。总代价O(n^2)。

<hr>

648 Replace Words

题意：英语里有<b>词根</b>，词根加上一些<b>词缀</b>，可以变成<b>派生词</b>。给定一个<b>词根表dictionary</b>，请将一个句子sentence中的单词替换成<b>词表中存在的词根</b>。如果多个词根符合，使用<b>最短</b>的一个。

难度：medium

解法：这个例子倒不是真正的<b>英语语法、词根</b>之类的，而是<b>前缀匹配</b>。句子长度、词表长度都还有点大，因此<b>不能暴力</b>解决。建立<b>字典树</b>比较合理。对sentence进行分词，查找<b>字典树</b>，如果有词根匹配，按<b>最短匹配</b>的原则，找到要替换的词根。最后用空格拼装成句子。看了下我当年的代码，没用字典树，而是搞了个<b>字符串滚动哈希</b>（其实就是BM匹配算法），用于做<b>前缀匹配</b>。思路差不多，方法不同而已。

<hr>

649 Dota2 Senate

题意：给定两个阵营<b>R和D</b>。一个长度为n的RD字符串，表示两个阵营<b>攻击的顺序</b>。从左往右，每个玩家攻击时，可以<b>选一位</b>场上剩余的<b>对方阵营玩家</b>，并将其<b>ban掉</b>。被ban的玩家在自己的轮次无法再攻击。如果一方玩家全被ban，则输掉比赛。如果两方都使用最佳策略，请问R和D谁获胜？

难度：medium

解法：就不说什么<b>近卫天灾</b>之类的话了。考虑这个题，贪心策略可行吗？比如RRDDR。我作为R方，肯定优先ban<b>排在前面的D玩家</b>。因为他攻击时间更早，威胁就更大。那比如<b>有连续x个R，y个D</b>，如果x>=y，那么这y个D都被ban了，没得玩了。照这个思路，<b>双方都应该贪心</b>。就按这个逻辑，看看最后谁赢。我当年代码写得太长了，这题用python的话，应该在10-20行内解决战斗。

<hr>

650 2 Keys Keyboard

题意：给定一个特殊键盘，只有三个键：<b>“A”键、全选复制、粘贴</b>。如果你要打出n个“A”，请问至少要按几次键？<b>开始时</b>，屏幕已有一个字母“A”。

难度：medium

解法：<b>搜索还是DP</b>？还是用搜索吧，<b>定义状态</b>为`(当前字符数,剪贴板字符数,步数)`。“打A”的转移为`(+1,+0,+1)`；“全选复制”的转移为`(+0,=当前字符数,+1)`；“粘贴”的转移为`(+剪贴板字符数,+0,+1)`。执行BFS，直到<b>搜出目标值n</b>为止。看了下当年代码，是用<b>O(n^2)的DP解法</b>。

<hr>

651 4 Keys Keyboard

题意：650的变体。和刚才的2键键盘类似，这次是4个键：<b>按“A”、全选、复制、粘贴</b>。这次你至多可以按键N次，请问最多能输出多少字符“A”？

难度：medium

解法：付费题。和刚才的思路完全一样，只不过按键稍有变化，把<b>全选和复制</b>分开了。依然<b>用BFS</b>，按照每个按键的<b>状态转移</b>做搜索。搜到N步为止。

<hr>

652 Find Duplicate Subtrees

题意：给定一个二叉树，请找出其中所有<b>重复的子树</b>。两个子树如果从根节点开始，所有位置完全相同，则视为重复。

难度：medium

解法：首先，对于n节点二叉树，如果递归进行暴力匹配，时间是O(n^2)。太慢了，得优化。就用`节点->子树序列化`的方式做一下映射。因为一棵树的<b>序列化</b>，和自身肯定是<b>一一对应</b>的。判断字符串重复，就很容易了，用<b>哈希表记录</b>即可。

<hr>

653 Two Sum IV - Input is a BST

题意：1的变体。给定一个二叉搜索树，请判断是否存在两个元素，相加为k。

难度：easy

解法：我没想出什么巧办法，就是用一个<b>哈希表</b>。在<b>中序遍历</b>时，不断添加<b>已访问元素</b>到表中。对于当前元素x，如果<b>k-x在哈希表</b>中，就算找到了。

<hr>

654 Maximum Binary Tree

题意：给定一个<b>无重复值</b>的数组nums。以一种递归方式构建一棵<b>最大二叉树</b>。每次取<b>最大值</b>为根节点。其左侧子数组，为<b>左子树</b>；右侧子数组，为<b>右子树</b>。<b>递归构建</b>整个二叉树，

难度：medium

解法：在每一步，都需要找出当前范围内的<b>最大值</b>，然后分出<b>左右段</b>。第一种思路，<b>比较朴素</b>，就是每次用<b>O(n)代价遍历</b>找出最大值，然后<b>左右分别递归</b>。这样的<b>分治策略</b>，总代价是O(nlogn)，可以接受。第二种思路，是先按`(值,下标)`的方式，降序排列。第一个就是根节点，随后的节点，依次按值的范围进行插入。比如数组`[1,5,7,3]`，排序后是`[(7,2),(5,1),(4,3),(1,0)]`，那么7是根节点，5在7左，4在7右，1在5左。每插入一个节点，平均代价是O(h)，也就是树的高度。这样，其实总代价也是O(nlogn)。第二种思路麻烦一点，因此还是倾向<b>第一种解法</b>。

<hr>

655 Print Binary Tree

题意：给定一棵二叉树，用一种<b>特殊的排版</b>将其打印出来。

难度：medium

解法：不细说了，比较<b>繁琐枯燥</b>的一道模拟题。

<hr>

657 Robot Return to Origin

题意：给定一个机器人，从(0,0)出发。按照一个<b>上下左右</b>的序列移动，请判断最终是否<b>回到了原点</b>。

难度：easy

解法：按序列移动即可，检查终点。

<hr>

658 Find K Closest Elements

题意：给定有序数组arr，整数k和x。请找出arr中，和x最接近的k个数。

难度：medium

解法：因为是有序数组，那么定位<b>最接近位置</b>，可以直接<b>二分搜索</b>。从这个位置为起点，<b>双指针往两边延伸</b>。每次都选较为接近的点，延伸一步。这样，总代价是O(logn+k)，就是<b>O(k)</b>。我当年估计没注意到，<b>数组是有序的</b>，因此用了<b>两个堆</b>的解法。

<hr>

659 Split Array into Consecutive Subsequences

题意：给定一个升序数组，请问能否将其<b>划分</b>为几个<b>子序列</b>，使得每个长度至少为3，且都是<b>公差为1的等差数列</b>。

难度：medium

解法：其实这个题目只有一种情况难想，就是类似<b>`[1,2,3,3,4,4,5]`</b>，你知道<b>应该取1234和345，而不能取12345</b>。怎么用代码表达呢？我想了十分钟，总算想出来了。注意看4的位置，<b>两个4，一个5</b>。这代表什么，<b>在边界处，个数是一定会减少的</b>。判断边界，就用这个办法。除此之外，没有难点了。

<hr>

661 Image Smoother

题意：给定一个m x n矩阵表示的<b>灰度图</b>。对每个像素，求<b>3 x 3的均值</b>。如果在边界，则只考虑3 x 3<b>界内部分</b>的均值。结果按<b>整除</b>计算。

难度：easy

解法：按要求计算即可。

<hr>

662 Maximum Width of Binary Tree

题意：给定二叉树，求<b>最大宽度</b>。最大宽度是<b>一层节点数</b>的最大值。

难度：medium

解法：用任意方式遍历，<b>记录深度</b>并按深度<b>统计个数</b>即可。

<hr>

663 Equal Tree Partition

题意：给定一个二叉树，请问是否能<b>去掉其中一条边</b>，将二叉树分为两个，且<b>两棵树的节点和</b>相等。

难度：medium

解法：付费题。其实等效于<b>找一个子树</b>，使得子树和是<b>总和的一半</b>。递归遍历，<b>记录所有子树和</b>，看是否存在等于总和一半的即可。

<hr>

665 Non-decreasing Array

题意：给定数组nums，请判断是否可以通过</b>至多修改一个元素</b>，使得数组变为<b>升序</b>。

难度：medium

解法：仔细想一下，其实非常简单。升序数组，<b>相邻元素都是<=关系</b>。那么如果都满足，或者<b>仅有一个不满足</b>，就符合题意。否则，就不符合。只检查相邻元素，因此代价是<b>O(n)</b>。

<hr>

666 Path Sum IV

题意：112的变体。给定一种<b>奇怪的编码方式</b>，表示一棵<b>二叉树</b>，请求出这棵二叉树的所有<b>根到叶的路径和</b>。

难度：medium

解法：付费题。比较<b>无聊且怪异</b>的一题。两件<b>完全独立</b>的事。第一件是按照题意<b>建立这个二叉树</b>；第二件是<b>求路径和</b>。如果你不建二叉树，直接求和，其实也行。

<hr>

667 Beautiful Arrangement II

题意：526的变体。给定n，请构造一个1-n的<b>排列</b>，使得相邻元素之差`d_i=|a_i-a_{i+1}|`的序列`[d_1,d_2,...,d_{n-1}]`恰好包含k个不同值。返回<b>任意一种</b>有效排列即可。

难度：medium

解法：这和526的条件好像完全不相干。感觉有点难，<b>没什么想法</b>。k和n都比较大，不可能<b>直接搜</b>。比如我希望d_i的取值，恰好就是`{1,2,...,k}`，应该怎么做？考虑这样的排列`[1,k+1,2,k,3,k-1,...]`，前面会消耗掉1~k+1，用掉的差值则是1~k。那么如果我<b>消耗完剩余的数</b>，但<b>不增加新的差值</b>，就完成目标了。<b>能做到吗</b>？可以，而且很容易，后面直接跟上`[k+2,k+3,...,n]`就行了。这题有点小聪明，<b>考的是灵感</b>，而不是技术。

<hr>

669 Trim a Binary Search Tree

题意：给定一个二叉搜索树。请按照<b>[low,high]</b>的范围，修剪这棵树。请返回得到的新BST的根节点。

难度：medium

解法：递归处理，但要<b>注意递归的写法</b>。因为任何节点都可能被删，包括<b>根节点</b>，所以<b>返回新的根节点</b>是比较灵活的做法。这样就不用担心这棵树会变成什么样了，因为不论怎么变，你都会<b>一层层往上返回</b>。根据[low,high]<b>控制递归的走向</b>。

<hr>

670 Maximum Swap

题意：给定一个非负数num，你至多可以交换两个数位<b>一次</b>。请返回能得到的最大数。

难度：medium

解法：思路非常简单，不过<b>各种边界case</b>要考虑到位。把<b>第一个非最大位</b>，和<b>在它右边的</b>，<b>最后一个最大位</b>交换。如果找不到这两者，就不用换了。

<hr>

671 Second Minimum Node In a Binary Tree

题意：给定一个二叉树，求其中的<b>第二小值</b>。

难度：easy

解法：没什么技巧，<b>统计值</b>然后找第二小就行了。当然，你用一个最大堆处理，也可以。用min、second_min两个变量，也可以。

<hr>

672 Bulb Switcher II

题意：319的变体。有n栈灯，编号1-n，开始都是<b>亮的</b>。有四种按钮：按钮1，全flip；按钮2，偶数flip；按钮3，奇数flip；3k+1的flip。如果<b>总共按k次</b>按钮，但<b>种类和顺序</b>你可以选择。请问最终可能有<b>多少种不同结果</b>？

难度：medium

解法：乍一看很复杂，2^1000这么多。实际上，从这四个按钮去考虑。因为按钮只有开和关，那么其实总共2^4=16种按钮状态，每个按钮两次就还原了。还有一个技巧，因为<b>2和3的公倍数是6</b>，因此<b>用6个就足够观察了</b>。6的倍数，情况都是一样，没区别。那你可以用6位二进制111111，去编码状态。然后看看这16种按钮方式，能得到几个结果。讨论区里还有更简洁的做法，直接O(1)分情况讨论。所以，这题其实是<b>智力题</b>。一星差评。

<hr>

673 Number of Longest Increasing Subsequence

题意：给定数组nums，求出不同的<b>最长递增子序列</b>的个数。要求严格递增。

难度：medium

解法：LIS问题，标准形式是<b>求长度</b>。现在要求统计个数，那还是先求这个长度。然后要考虑一个问题，一个具体的最长递增子序列，怎么求？答案是<b>回溯</b>。在每个位置，找出上一个位置，一步步<b>往回跳</b>。比如`[2,4,1,3,6]`，可以是`[2,4,6]`或者`[1,3,6]`。那么我们考虑6的前一个元素，可以是4或3；4的前一个只有2；3的前一个只有1。按这种<b>回溯关系</b>，进行<b>DP</b>。用dp[i]表示<b>i位置结尾</b>的<b>递增子序列</b>，<b>有多少种</b>组成方式。如果i的前驱是`[j_1,j_2,...]`，则dp[i]=sum(dp[j])。最后，只考虑递增子序列长度为<b>LIS值</b>的那些位置。看了下我以前的代码，确实是这么做的，思路完全一样。总代价为O(n^2)，不过<b>实际的平均复杂度会远好于n^2</b>，这个就不细说了。

<hr>

674 Longest Continuous Increasing Subsequence

题意：给定数组nums，求出其中的<b>最长递增等差子数组</b>的长度。

难度：easy

解法：这题的标题<b>实在不恰当</b>。这叫<b>“subarray”</b>，不叫“subsequence”。问题本身很简单，如果发生<b>错配</b>，就从倒数两个元素重新开始匹配。检查是否<b>等差数列</b>，且<b>公差是否为正</b>。

<hr>

675 Cut Off Trees for Golf Event

题意：给定一个m x n地图，0是墙、1是空地、<b>h>1是高度为h的树</b>。你需要从(0,0)出发，上下左右移动，砍倒所有的树。已知所有树的<b>高度都不同</b>，且你必须按<b>从低到高</b>的顺序砍树。请返回砍完所有树的<b>最小步数</b>，如无法完成则返回-1。

难度：hard

解法：mn的最大值都是50，因此<b>单轮的搜索代价</b>是很小的，这给<b>从头搜到尾</b>的方案提供了可能。既然规定了必须从低到高砍树，那你的<b>执行顺序是固定的</b>。因为<b>有墙</b>，你就<b>只能搜索</b>，而不能用两点的坐标直接得到路径。这么看来，好像你的<b>选择不多</b>，要做的事也<b>很明确</b>。那就按要求，一个个地搜吧，每搜一棵，就砍一棵。中途如果路径<b>无法到达，就返回-1</b>。事实证明，<b>确实没什么技巧</b>，按要求实现就行了。

<hr>

676 Implement Magic Dictionary

题意：给定一个词表dictionary和一个词word。请判断能否改变word的一个字母，使结果匹配词表中的某个词。注意，<b>word本身匹配</b>dictionary是不算的。

难度：medium

解法：显然，要么<b>对word改</b>一个字符，要么<b>对dictionary的所有词</b>改一个字符。如果search函数调用非常多，且dictionary不算大，则改dictionary比较好。否则，改word比较好。我选择<b>改word</b>，逐个改字符，然后尝试匹配就行了。匹配就用一个<b>哈希表保存dictionary</b>即可。对这个题其实还有很多<b>可探讨的地方</b>，比如字符串哈希、位压缩、冷词热词之类的。总之，可以弄成一个<b>综合的讨论题</b>。不仅仅是个算法题。

<hr>

677 Map Sum Pairs

题意：设计一个map，key是字符串类型，value是整数。且支持给定一个<b>key前缀</b>，求匹配这个前缀的<b>value之和</b>。

难度：medium

解法：有两种解法，第一种是<b>构建字典树</b>，并在字典树上对值做好累加。这样当你查询时，就可以直接得到求和了。这种方式，<b>插入比较麻烦</b>，但求和方便。第二种是用OrderedDict，因为OrderedDict的key是有序的，对key用bisect_left，判断是否前缀匹配。从找到的位置，逐个进行累加。这种方式，插入方便，求和稍麻烦。总体上，<b>第二种方法更简单的多</b>。不过我当年选的是字典树，当年用C++写的。

<hr>

678 Valid Parenthesis String

题意：给定一个“(”、“)”组成的括号序列，其中也可能包含“\*”。<b>单个“\*”字符</b>可以表示“（”、“）”、“”中的一种。请判断给定括号序列能否完整匹配。

难度：medium

解法：<b>单纯的括号匹配</b>，用一个计数，模拟栈顶就行了。现在给了“\*”，比如我们用cc表示这个计数。如果到末尾时，cc>0，表示“(”多了；如果cc<0，表示“)”多了。你都可以通过星号来补全。是不是在<b>任何时候都可以</b>？不是。比如<b>cc=-3</b>，右括号多3个，但你<b>目前</b>只有2个星号，那就g了。因为你用完“((”，前面序列也没法匹配，即使后面匹配，前面已经错了。但如果是<b>cc=3，你有2个星号</b>，可以吗？这种可以。因为<b>左括号多余</b>，要到了<b>最后才检查</b>。按这个原则，进行<b>计数和检查</b>。看了下当年的代码，第一种O(n^3)暴力解法，第二种高效解法，就是我现在说的这个。看来<b>当年我没想出来，但这次想到了</b>。

<hr>

679 24 Game

题意：扑克牌，<b>算24点</b>。注意，除法不是整除，而是<b>实数除法</b>。

难度：hard

解法：就是标准的，算24点。规则不说了，<b>暴力搜索</b>就行。代码的写法，可以把<b>四则运算</b>用一个dict存起来。<b>函数也是变量，可以保存的</b>，这样代码写起来简洁点。固定4张牌，所以搜索空间很小，不存在效率问题。

<hr>

680 Valid Palindrome II

题意：125的变体。给定字符串，能否通过<b>删除至多一个字符</b>，得到<b>回文串</b>？

难度：easy

解法：<b>从两端往中间匹配</b>，如果错配只有一处，判断应该删哪个字符；如果没有错配，则本身就是回文串。

<hr>

681 Next Closest Time

题意：给定一个`HH:MM`格式的时间，请用时间里<b>出现的数字</b>，拼出下一个<b>最近的时间</b>。

难度：medium

解法：付费题。毕竟就这么几个数字，<b>暴力搜</b>，然后检查<b>下一个最近的值</b>也是可以的。注意23:59这种要<b>延到第二天</b>的情况。

<hr>

682 Baseball Game

题意：太繁琐，不写了。

难度：easy

解法：水题，但题目很繁琐。

<hr>

684 Redundant Connection

题意：给定一个<b>无向图</b>。已知这个无向图是在<b>树的基础上</b>，添加一条边形成的。请找出一条边，使得删去这条边能让这个图变成树。

难度：medium

解法：用<b>并查集</b>可以完美解决。针对每条边，做union操作。如果发现轮到某条边的时候，两点的<b>find结果相同</b>，则表示已经连通了。那么，这条边就是<b>多余的边</b>，可以删去。

<hr>

686 Repeated String Match

题意：给定字符串a和b。允许你重复字符串a任意次，请问至少重复多少次，才能让b称为这个`{aaa...aaa}`串的子串？如果不可能，则返回-1。

难度：medium

解法：这个问题不要想复杂了，其实就是<b>把a重复到恰好长于b</b>，记这个重复串为a1。如果b是a1子串，则返回个数；如果不是子串，则返回-1。就这么简单。想明白了，就会发现这是个<b>坑爹智力题</b>。总不能说让人<b>手写KMP算法</b>，是这题的考察点吧？我直接a1.find(b)，用库函数里的<b>Sunday算法</b>，效率就足够好了。看了下当年的代码，好像当年我没看出智力题，现在能一眼看出了。

<hr>

687 Longest Univalue Path

题意：给定二叉树，请找出以<b>任意两点</b>为端点的<b>单值路径</b>。单值路径是指整个路径上所有点的值相同。

难度：medium

解法：在二叉树上，凡是<b>不要求从根节点出发</b>的递归，都可以写成<b>双层递归函数</b>。fun1()递归调用自己，同时还调用fun2()；fun2()只递归调用自己。

<hr>

688 Knight Probability in Chessboard

题意：给定n x n国际象棋棋盘，如果一个马，从(r,c)位置出发，马走“日”。每次按照8个日的方向，等概率选一个，包括走出界。只要<b>马还没有出界</b>，就不断随机移动，<b>至多k步</b>。请问最终马落在棋盘内的的概率是多少？

难度：medium

解法：先不考虑浮点数的<b>精度问题</b>，想想这个概率该怎么算。其实很简单，连搜索都不需要。<b>直接/8</b>就行了。比如当前<b>在(i,j)位置的概率是p</b>，那么下一步，你只需要算出<b>马走日</b>得到的8个位置中，<b>界内的有哪些</b>。给这些界内的值，都<b>+p/8</b>就行了。界外的情况很复杂，所幸<b>你不需要管界外</b>。只把界内的值<b>累加出来</b>就行了。

<hr>

690 Employee Importance

题意：给定一个员工列表，每个员工有id、重要值、下属id列表。给定某个员工id，返回他和他所有的下属的重要值之和。

难度：medium

解法：<b>树形结构，递归求和</b>。奇怪的是，为什么我以前的代码用的是并查集？这不应该是<b>自顶向下</b>的递归吗？仔细看了下，<b>怀疑是不是题目改了</b>？老的代码并不完全符合这个题意。

<hr>

692 Top K Frequent Words

题意：给定一个字符串数组，求出出现频率前k大的值。如果频率相同，优先返回字典序小的。

难度：medium

解法：直白的方法就是统计、排序、取前k个。排序按`(-频率,+字典序)`即可，总代价是O(nlogn)。除此之外，没想出<b>更简便</b>且效率明显高的办法。如果要搞一些<b>复杂而奇奇怪怪的算法</b>来达到要求，那还是算了。

<hr>

693 Binary Number with Alternating Bits

题意：给定整数，判断它的所有<b>相邻二进制位</b>是否都不同。

难度：easy

解法：如果奇数，则`(x|(x<<1))+1`是2的幂；如果偶数，则`(x|(x>>1))+1`是2的幂。想想例子，比如101010，比如10101。

<hr>

694 Number of Distinct Islands

题意：给定m x n的矩阵表示一个地形。0是水，1是陆地。陆地可以按4方向连成小岛。如果两个小岛可以通过<b>平移</b>（但不能旋转、反转）达到重合，则算作<b>相同小岛</b>。请判断地形中有多少个不同小岛。

难度：medium

解法：付费题。首先，判断小岛个数，是很基础的搜索操作了。这题的特点是<b>如何判重</b>。我想了个笨办法，但也管用。对于小岛的形状，比如它所在的<b>矩形框</b>是p x q的（注意，不是m x n），我把这p x q框框里面的<b>01内容</b>，都<b>连成一个字符串（或者位向量也行）</b>，然后把字符串记录下来。这样判重就可以用<b>哈希表</b>做了，解决了。说白了，就是<b>序列化</b>。不过要注意，<b>框框里</b>如果有<b>别的小岛</b>，不要混进去了。序列化还有其他方式，比如所有点都<b>平移到同一个相对位置</b>，让参考系对齐，这样也行。

<hr>

695 Max Area of Island

题意：给定m x n的矩阵表示一个地形。0是水，1是陆地。陆地可以按4方向连成小岛。请求出<b>最大小岛的面积</b>。

难度：medium

解法：flooding算法，搜索求和即可。返回最大值。

<hr>

696 Count Binary Substrings

题意：给定一个01串s，请返回s中<b>0和1个数相等</b>，且<b>0在一起、1在一起</b>的子串个数。

难度：easy

解法：这个要求太严格了，因此只能发生在<b>连续0和连续1的交界处</b>。统计每一段连续0、连续1的个数，比如x个0、y个1，那就是`min(x,y)`个。<b>继续下个边界</b>，继续统计。<b>结果累加</b>。总代价<b>O(n)</b>。

<hr>

697 Degree of an Array

题意：给定数组nums，它的<b>“度”</b>定义为其中<b>最大的频率值</b>。请求出nums的<b>最短子数组</b>，使得子数组的度等于nums的度。返回长度。

难度：easy

解法：首先对nums做统计，求出<b>最大频率</b>，以及最大频率对应的值。统计的同时，也把每个值出现的<b>第一次i1、最后一次i2</b>位置记下来。把<b>最大频率对应的值</b>，扫一下。对每个值，找出<b>`i2-i1+1`</b>的最小值，就是答案。

<hr>

698 Partition to K Equal Sum Subsets

题意：给定数组nums，请问能否<b>划分为4个子序列</b>，使得4个部分的和相等？

难度：medium

解法：不要求连续，因此可以视为<b>子序列划分</b>。如果是划分为2组，可以作为一个<b>01背包问题</b>处理。划分为4组的话，则可以理解为<b>背包^3</b>。这么做太麻烦了，还是直接<b>搜索+回溯</b>吧。虽然数据规模已经很小了，还是注意<b>剪枝优化</b>。

<hr>

700 Search in a Binary Search Tree

题意：给定二叉搜索树和目标值val，如果存在，请返回节点。否则返回null。

难度：easy

解法：这就是原封不动的<b>BST的基本用法</b>。小了向左，大了向右，相等返回。
