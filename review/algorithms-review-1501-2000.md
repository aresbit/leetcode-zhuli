# LeetCode 一句话题解 - 1501-2000

[返回目录](./README.md)

- [LeetCode 一句话题解 - 1501-2000](#leetcode-一句话题解---1501-2000)
  - [1501 - 1600](#1501---1600)
  - [1601 - 1700](#1601---1700)
  - [1701 - 1800](#1701---1800)
  - [1801 - 1900](#1801---1900)

代码库地址：  
[https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/1501-2000](https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/1501-2000)

## 1501 - 1600

1502 Can Make Arithmetic Progression From Sequence

题意：给定数组nums，请问能否排序变成一个等差数列？

难度：easy

解法：那就<b>排序</b>。

<hr>

1503 Last Moment Before All Ants Fall Out of a Plank

题意：有一些蚂蚁在木板上走，<b>向左或向右</b>，速度都是1。初始位置为`left[i]`和`right[j]`，分别表示向左或向右的蚂蚁的位置。如果两只蚂蚁<b>相遇</b>，则都<b>回头继续走</b>。请问经过多长时间，所有蚂蚁都走出木板边界？

难度：medium

解法：其实是个<b>智力题</b>。两蚂蚁<b>碰撞</b>，等效于<b>穿过</b>了。因此你可以认为，所有蚂蚁<b>就这么一直走</b>，走出边界就行了。计算<b>max时间</b>即可。总代价`O(n)`。

<hr>

1504 Count Submatrices With All Ones

题意：给定m x n的01矩阵，请统计全为1的子矩阵个数。

难度：medium

解法：方法有很多种，但大致的复杂度都是`O(n^3)`。比如我用<b>前i行的每个j列</b>的<b>1个数</b>做累加，可以得到一个数组。但如果当前行的j列是<b>0</b>，则累加值<b>清零</b>。比如当前累加值是`[3,0,1,5,2]`。对于j=3，<b>值5</b>的位置。我<b>往回倒推</b>，看看以5作为<b>右下角</b>，且宽度为`1,2,3,...`的矩形分别有多少个。统计为[5,1,0]个。再看<b>值2</b>的位置，统计为[2,2,1,0]。这个统计总是<b>单调递减</b>的。如此，对于一行的统计代价是O(n^2)，因此总代价是`O(n^3)`。考虑这个变化过程`3->00->001->0015->00122`。我以前提交的代码，已经看不懂了。但思路肯定大同小异。这题可以转化为<b>84题</b>那样的<b>直方图形状</b>去考虑。

<hr>

1506 Find Root of N-Ary Tree

题意：给定n叉树的所有节点，已知这些节点属于同一棵树。请找出<b>根节点</b>。

难度：medium

解法：付费题。`O(1)`空间的加法我没想到。但常规解法很容易，可以用并查集，把`parent->child`关系转化为`dj[child]=parent`。这样，就可以<b>向上走到顶</b>，顶部就是根节点。总代价`O(n)`。

<hr>

1507 Reformat Date

题意：给定类似“20th Oct 2052”这样的日期格式，转化为“YYYY-MM-DD”格式。

难度：easy

解法：水题，不过略麻烦。

<hr>

1508 Range Sum of Sorted Subarray Sums

题意：给定数组`nums`，求它的所有子数组和，并把值升序排列，得到一个数组`sm`。请求出sum(sm[left-1:right])。结果模`1e9+7`返回。

难度：medium

解法：这题有意思，乍一看没什么思路。显然你不能<b>直接穷举</b>，因为太多了。想了半天，确实没什么思路。然后就<b>真穷举了</b>，然后就<b>真过了</b>。总代价就算`O(n^2*logn)`吧。

<hr>

1509 Minimum Difference Between Largest and Smallest Value in Three Moves

题意：给定数组nums，你可以做三次操作。每次允许任选一个元素，改为任意值。求`min(max(nums)-min(nums))`。

难度：medium

解法：其实就是让元素尽可能<b>靠拢</b>。如果`n<4`，答案直接就是0。对于`n>=4`，这其实等效于<b>丢弃3个元素</b>。那我们考虑对nums<b>排序</b>，从前面丢x个，从后面丢y个，且`x+y=3`。求4种丢法，其中的<b>差值最小值</b>。这题几乎都在动脑上，代码很短。可以算个<b>小智力题</b>。

<hr>

1512 Number of Good Pairs

题意：给定数组nums，请求出`i<j,nums[i]==nums[j]`的对数。

难度：easy

解法：哈希计数，求和即可。如果`mm[x]=cc`，则`cc*(cc-1)/2`。

<hr>

1514 Path with Maximum Probability

题意：给定无向图，每条边都有个[0,1]的概率。连续走边，概率<b>累乘</b>。给定起点src和终点dst，请求出一条概率最大的路径，返回概率。

难度：medium

解法：这相当于是<b>带权最长路径</b>？不对，这其实是<b>最短路径</b>。因为你要取`-log()`。题目要求<b>累乘概率最大</b>，取`-log()`之后就成了<b>累加总和最小</b>。剩下就是<b>Dijkstra算法</b>了。因为算法规定不能处理<b>负权</b>，取`-log()`之后也恰好<b>没有负权</b>，完美。出这题的人，还<b>挺有创意的</b>。

<hr>

1518 Water Bottles

题意：喝汽水，<b>瓶子换汽水</b>，听过吧？你有x瓶汽水，每y个瓶子可以换1瓶汽水。请问给定x、y，你总共能喝多少瓶？

难度：easy

解法：<b>喝完了换，换完了喝</b>。直到<b>不够换1瓶</b>为止。

<hr>

1519 Number of Nodes in the Sub-Tree With the Same Label

题意：给定一个无向图表示的树，根节点为0。对于每个节点i，请统计i所在的子树里，和i有<b>相同节点值</b>的节点个数。

难度：medium

解法：题目不难，就是题目描述有点<b>看不懂</b>。可以递归遍历这个树，并且保持一个<b>哈希表</b>，来统计不同值的个数。<b>后序遍历</b>，对于统计结果，查找当前节点的val的出现次数。总代价`O(n)`。

<hr>

1522 Diameter of N-Ary Tree

题意：给定n叉树，求树的直径。

难度：medium

解法：其实这个和n叉树，甚至是不是树都无关。<b>图的直径</b>就是<b>最长路径</b>的长度。还是采用<b>搜两次</b>的思路，参见<b>1245题</b>。当然，你如果不想转化为无向图去求解，也可以在树上采用<b>双层递归</b>的写法。两种方法的思路都不难，但<b>实现都略麻烦</b>。总代价`O(n)`。

<hr>

1523 Count Odd Numbers in an Interval Range

题意：给定low、high，统计`[low,high]`范围内奇数的个数。

难度：easy

解法：在<b>水题界</b>也是相当炸裂的存在。

<hr>

1525 Number of Good Ways to Split a String

题意：给定字符串s，请将其分为左右<b>两个子串</b>。要求两边唯一值的个数相同，请求出不同划分的个数。

难度：medium

解法：使用两个哈希表，从`i=0`开始右移。<b>一个增、一个减</b>，更新统计。当两者的`len()`相同，就是符合条件的。总代价`O(n)`。

<hr>

1526 Minimum Number of Increments on Subarrays to Form a Target Array

题意：给定数组target，元素非负。你有一个同长度的数组arr，<b>初始全为0</b>。每次你可以任选一个arr的<b>子数组，给所有元素+1</b>。请问至少多少次操作，可以把arr变成target？

难度：hard

解法：这是个<b>智力题</b>。你可以考虑数组值的<b>升降</b>。比如用类似<b>水位上涨</b>，淹没的思路去做。但这样的<b>模拟算法</b>，很难在`O(n)`时间搞定，也不容易想清楚。比如`[1,2,4,1,0,3,7,2]`，你能看出来有<b>两个小山</b>。那这个+1操作肯定要分两批做，因为<b>子数组无法连到一起</b>。实际上，<b>关键思路</b>极其简单（如果<b>想不到就很难</b>）。只要<b>值上升了</b>，你就要执行`+1`。如果值持平或者下降，你什么都不用做。为什么下降不用管呢？因为上升时你已经+1到达<b>最高点</b>了，那是不是随后下降的位置，你已经<b>“淹没”</b>了？因此就<b>不用重复+1</b>了。总代价`O(n)`。

<hr>

1528 Shuffle String

题意：给定字符串s和位置indices，把`s[i]`按照`indices[i]`重排一下。

难度：easy

解法：水题。

<hr>

1529 Minimum Suffix Flips

题意：给定01串s和target，都长度为n。开始s是全0，每次操作，允许你选择s[i:n]反转。请问至少几次操作，能把s变为target。

难度：medium

解法：其实很好理解，每次我都可以反转右边的一部分。那么我只考虑有几段000111这种连续的0段、1段。我只关心<b>有几段</b>，而<b>不在乎每段有几个</b>。因为我选可以选任意位置反转，每反转一次，就会多出一段01变化。<b>最靠左的0段</b>可以忽略，不需要反转。这题以前是<b>Bulb Switcher</b>的变体题，后来改名字了。总代价`O(n)`。

<hr>

1530 Number of Good Leaf Nodes Pairs

题意：给定二叉树，请求出两节点路径长度不超过distance的<b>节点对个数</b>。

难度：medium

解法：形象上很好理解，但怎么搜效率更高？采取双层递归，遍历x、y两个节点吗？这个思路可以，不过可以做得更直观。我可以遍历，并记下每个节点的路径，用<b>01串</b>表示。比如<b>“010”代表“左右左”</b>。那么“010”和“0011”的距离，就是<b>“10”+“011”的长度</b>，5。也就是<b>去掉公共前缀</b>后的剩余长度和。枚举得到的n个路径串，计算距离。总代价`O(n^2)`。这个方法效率并不高，但<b>有助于理解</b>，这样写代码<b>不容易出错</b>。

<hr>

1534 Count Good Triplets

题意：给定数组arr，请找出`(i,j,k),i<j<k`，使得`|arr[i]-arr[j]|<=a`、`|arr[j]-arr[k]|<=b`、`|arr[i]-arr[k]|<=c`。

难度：easy

解法：不考虑复杂方法了，<b>直接枚举</b>。似乎有更优解法，但<b>思维和实现难度</b>会显著上升，罢了。总代价`O(n^3)`。

<hr>

1535 Find the Winner of an Array Game

题意：给定数组arr，我们每次都比较`arr[0]`和`arr[1]`的大小。大的放到0位置，小的放到n-1位置。不断执行这个比较，直到某个值<b>连续赢k次</b>为止。请返回连赢k次的<b>值</b>。

难度：medium

解法：n可以达到1e5，k则可以非常大。但是我们知道，如果k>=n，则结果一定是`max(arr)`，因为<b>最大值</b>肯定是<b>赢麻了</b>。那么对于`k<n`的情况，我们至多模拟`O(k+n)`次，也能知道结果。因此，直接模拟吧。这个过程因为涉及到“移动到末尾”，用<b>链表</b>实现很高效。真的需要链表吗？<b>不需要。</b>你只要把`arr[0]`和`arr[i]`比较就行了，i可以移动，但`arr[0]`总是赢家的位置。这时，你完全可以<b>无视“交换到末尾”</b>这个操作。总代价`O(n)`。

<hr>

1539 Kth Missing Positive Number

题意：给定一个<b>严格递增</b>的数组，元素都是正数。请返回`1~inf`里，第k个<b>未出现的值</b>。

难度：easy

解法：`O(n)`的枚举做法就不说了。对于二分搜索，我们可以考虑一个值x，我判断x是否出现在`arr`。比如<b>出现</b>，位置是i，则x之前<b>共有`x-i-1`个元素</b>没出现；比如<b>没出现</b>，且`<x`的最大值是y，位置是i，则x是<b>第`x-i-
1`个没出现的元素</b>。这样可以二分搜索，逐渐卡到第k个没出现的值。easy难度，就不要搞那么复杂了。

<hr>

1541 Minimum Insertions to Balance a Parentheses String

题意：给定括号序列s，你可以任意插入<b>左右括号</b>。请求出最小的插入次数，使得序列<b>平衡</b>。注意，这次<b>右括号改为“))”</b>，两个字符。

难度：medium

解法：这是个<b>贪心</b>问题，不用DP。用计数cc表示<b>匹配计数</b>，如果出现`cc<0`，则<b>立刻补充</b>左括号。如果<b>处理完了</b>发现`cc>0`，则补充右括号。不过，这题的右括号是<b>“))”</b>，因此要<b>特殊处理</b>一下。总代价`O(n)`。

<hr>

1544 Make The String Great

题意：给定字符串s，如果相邻字符存在同字母大小写的情况，比如“aAEe”这种，则<b>都删除</b>。持续删除这种对子，直到不存在为止。返回结果。

难度：easy

解法：凡是这种类似<b>祖玛</b>一样的<b>删除+靠拢</b>逻辑，都可以用<b>栈</b>处理。

<hr>

1545 Find Kth Bit in Nth Binary String

题意：给定一种01序列，`s[0]='0',s[i]=s[i-1]+'1'+reverse(inverse(s[i-1]))`。请求出`s[n]`的第k位。

难度：medium

解法：当然不会把完整的`s[n]`算出来，应该<b>倒推</b>。你甚至可以写个<b>尾递归</b>，这样思维上容易理解。`s[n]`的长度是`2^n-1`，其中<b>左中右</b>分别是什么，你都知道。按照这个方式，一步步倒推回去。总代价`O(n)`。

<hr>

1550 Three Consecutive Odds

题意：给定数组arr，请判断是否存在连续3个奇数。

难度：easy

解法：水题。

<hr>

1551 Minimum Operations to Make Array Equal

题意：给定数组arr，`arr[i]=2i+1`。每次操作，你可以选两个元素，执行`arr[i]+=1,arr[j]-=1`。请问至少几次操作，可以使<b>所有元素相等</b>。

难度：medium

解法：一道简单的<b>数学题</b>，你可以把所有数都变成均值。比如`[1,3,5]`变成`[3,3,3]`，`[1,3,5,7]`变成`[4,4,4,4]`。答案就是奇数`(n^2-1)/4`，偶数`n^2/4`。

<hr>

1552 Magnetic Force Between Two Balls

题意：有n个篮子，位置在`position[i]`。你需要选m个篮子放入磁铁。两个磁铁间的吸力是`|x-y|`。请问如何放置，可以使这些球之间的<b>最小吸力最大</b>？返回这个<b>最大值</b>。

难度：medium

解法：C-137，居然还有<b>Rick and Morty</b>的梗。又是<b>minimax问题</b>，考虑二分搜索。比如<b>最小吸力是x</b>，则我们尝试放置m个磁铁，且保持m-1个间隔都`>=x`，看能不能放够m个。用这个<b>判定函数</b>，做<b>二分搜索</b>。总代价`O(nlog(int))`。

<hr>

1556 Thousand Separator

题意：给定整数，每3位加个点。

难度：easy

解法：这是<b>欧洲</b>那边，比如德国的表示法，<b>用点</b>而不是逗号。

<hr>

1557 Minimum Number of Vertices to Reach All Nodes

题意：给定有向图，请返回一个<b>最小的点集</b>，使得所有点都可以从这个点集<b>到达</b>。

难度：medium

解法：很明显，把<b>入度为0的点</b>都收集起来就行了。入度为0，就是拓扑排序的<b>最前面</b>，肯定是从这些点出发<b>遍历整个图</b>。总代价`O(V+E)`。

<hr>

1558 Minimum Numbers of Function Calls to Make Target Array

题意：给定数组nums，开始你有个同长度数组arr，值全为0。你希望通过两种操作，把arr变成nums。第一，单个值加1，`arr[i]+=1`；第二，所有值乘2，`arr*=2`。

难度：medium

解法：我们看个例子，想想怎么变。比如`[3,5,2]`，很显然，奇数一定是`+1`得到的。那么我们必须对应`-1`。2次操作，变为`[2,4,2]`。然后就可以`/2`了，1次操作，变为`[1,2,1]`。因此可以按照这个思路，<b>统计奇数+除以二</b>两步交替进行。总代价`O(nlog(int))`。<b>换种方式</b>，你也可以对每个元素统计`-1`和`/2`的次数。`-1`要`sum()`，`/2`要`max()`。

<hr>

1560 Most Visited Sector in a Circular Track

题意：有<b>一圈</b>赛道，分为n段。有m场比赛，每场比赛的赛段是`[rounds[i-1],rounds[i]]`。请统计被使用次数最多的所有赛段。

难度：easy

解法：题目描述实在<b>太差劲</b>，评论区都骂翻了。绕圈，<b>哈希计数</b>即可。

<hr>

1561 Maximum Number of Coins You Can Get

题意：有3n堆硬币，每堆的个数是`piles[i]`。每次，你可以从中<b>任选3堆</b>。Alice拿`max(3堆)`，你拿`max(2堆)`，剩的给Bob。请问你最多可以拿到多少硬币？

难度：medium

解法：我们先考虑`piles.sort()`，<b>排序</b>之后依次取3堆。这样你总是拿到3堆中的第2个。能比这个更优吗？我找不出更好的，但也不知道怎么<b>数学证明</b>。总代价`O(nlogn)`。

<hr>

1566 Detect Pattern of Length M Repeated K or More Times

题意：给定数组arr，请判断是否存在一个<b>长度m</b>的子数组，在arr中<b>连续重复了k次</b>。

难度：easy

解法：数据量很小，可以直接暴力匹配。但也有个偷懒的办法，你可以把arr转化为字符串，每个元素就作为字符处理。然后用re模块，写个<b>正则匹配</b>。这个还挺有意思，`re.search(r'(.{{{}}})\1{{{}}}'.format(m,k-1), s)`。意思是先<b>捕捉</b>一个<b>m子串</b>，然后让这个子串重复`k-1`次。正则因为有自己的<b>官方优化</b>，会比暴力匹配快很多。

<hr>

1570 Dot Product of Two Sparse Vectors

题意：给定两个<b>稀疏向量</b>，求<b>点乘</b>。

难度：medium

解法：付费题。点乘的计算是`sum(xi*yi)`。既然稀疏，那我们就只保存`(i,val)`<b>非0值</b>的记录。然后按照哈希表的方式，<b>求交集</b>。相乘求和即可。

<hr>

1572 Matrix Diagonal Sum

题意：给定<b>方阵</b>，请求出正反对角线元素之和。

难度：easy

解法：水题。

<hr>

1574 Shortest Subarray to be Removed to Make Array Sorted

题意：给定数组arr，你可以从中删除一个子数组，使得剩下的部分升序排列。请返回删除的<b>最小长度</b>。

难度：medium

解法：我以前没想出`O(n)`解法，这次想出来了。以前那个思路就不讲了，我们用双指针`i=0,j=后缀升序排列的第一个位置`。比如`[1,2,3,10,4,2,3,5]`，则`i=0,j=5`。然后<b>i位置</b>表示删除子数组的<b>左边界</b>，`j-1`就是删除的右边界。i前进时，j也前进，而且<b>不会回头</b>。因此总代价是`O(n)`。

<hr>

1575 Count All Possible Routes

题意：有一条路上有n个城市，位置是`locations[i]`。你从`src`出发，经过一些城市到达`dst`。已知你开始有`fuel`汽油，每次移动的耗油是从x到y耗油`|x-y|`。如果你在任何位置，汽油都<b>不能为负</b>，但是你可以<b>重复访问</b>任何城市，包括起点终点。请求出能成功到达的<b>路径种类数</b>，结果模`1e9+7`返回。

难度：hard

解法：城市数量最多100，这显然不能<b>暴力搜索</b>。那么关键是什么？关键是可以<b>重复访问</b>。这就把思路变成<b>DP</b>，而不是穷举搜索了。我们以<b>城市数、剩余油量</b>，去做DP。定义`dp[i][j]`为<b>剩余油量i</b>，且<b>最后城市是j</b>的种类。剩下的<b>状态转移</b>就不说了。为什么选油量？因为<b>fuel只有200</b>，location太大了，用location没法做。总代价`O(f*n^2)`。

<hr>

1576 Replace All ?'s to Avoid Consecutive Repeating Characters

题意：给定字符串，包含字母和“?”。请将<b>问号</b>都替换为<b>字母</b>，使得相邻字符都不同。返回任意的有效结果。

难度：easy

解法：水题。

<hr>

1578 Minimum Time to Make Rope Colorful

题意：给定n个气球，每个有颜色`colors[i]`。你需要拿走一些气球，使得剩下的相邻气球都不同色。拿走每个气球的代价是`neededTime[i]`。请求出最小总代价。

难度：medium

解法：这题不要<b>误解成DP问题</b>。你可以把<b>连续的同色气球</b>看成1个。因为你只能留1个。那就留<b>`needTime`最大</b>的那个，剩下的<b>都要拿走</b>。按这个逻辑，求和即可。总代价`O(n)`。

<hr>

1579 Remove Max Number of Edges to Keep Graph Fully Traversable

题意：给定一个无向图，存在<b>三种边</b>：A可访问，B可访问，AB都可访问。现在允许你删除一些边，使得剩余的边依然能让A、B<b>从所有点到达所有点</b>。请返回删除的最大边数。

难度：hard

解法：这题很难，主要难在你可能会往一些<b>更难的方向</b>去想，然后就<b>想不出来</b>了。我考虑过<b>割边</b>问题，显然graph cut不简单，我甚至不知道一个具体的<b>求割边算法</b>。这条路走不通，后来看了评论区，说<b>并查集</b>。我<b>完全想不到</b>，尝试理解了一下。其实这题的巧妙在于边有<b>三种类型</b>，A型、B型、AB型。我们<b>先考虑A</b>，`A+AB`型的边。那么，当一条边导致dj的<b>连通分量减少</b>，说明`union()`成功了，我们<b>需要这条边</b>。那剩下的边，就是<b>多余边</b>了。同理，对`B+AB`也执行一次。要注意AB部分<b>不要重复执行</b>，所以写这个代码<b>有点技巧</b>。这题不能算独立完成，因为<b>我看了评论思路</b>。

<hr>

1582 Special Positions in a Binary Matrix

题意：给定m x n矩阵mat，如果`mat[i][j]=1`，而且它是i行、j列唯一的1，则称为<b>特别位置</b>。求特别位置的个数。

难度：easy

解法：水题，统计`row_cnt[m]`和`col_cnt[n]`即可。

<hr>

1583 Count Unhappy Friends

题意：有n个人，n是偶数。每个人对其他`n-1`人有偏好`preferences[i]`。这个偏好的<b>先后顺序</b>代表偏好程度。现在给定`n/2`组配对，把这n个人结伴。如果存在`(x,y)+(u,v)`，且x更喜欢u，u更喜欢x，则<b>x、u不开心</b>。请统计出<b>不开心的人数</b>。

难度：medium

解法：这题<b>有点费解</b>，指的是<b>配对配错了</b>，导致不开心。那是不是直接枚举`O(n^2)`次？好像可以，那我们就按照<b>题目给定的规则</b>去做。比如检查`(x,y)`，那么我先检查其他的y1，看有没有更偏好的。如果有，则检查y1的配对`(y1,x1)`，看看y1是不是<b>更偏好x，而不是x1</b>。如果<b>双向检查</b>都符合题目规则，则说明<b>x不开心</b>。对于y，则按`(y,x)`的顺序检查一遍，<b>反之亦然</b>。总代价`O(n^2)`。

<hr>

1584 Min Cost to Connect All Points

题意：给定二维平面一些点`(xi,yi)`，距离计算按<b>曼哈顿距离</b>。求出<b>最小生成树</b>的权值。

难度：medium

解法：题目没说MST，但<b>这个就是MST</b>。n个点，<b>`C(n,2)`条边</b>，每条边的距离，你可以用曼哈顿距离计算。然后执行<b>Kruskal算法</b>即可。总代价`O(n^2logn)`。

<hr>

1588 Sum of All Odd Length Subarrays

题意：给定数组nums，请求出所有长度为奇数的子数组之和。尝试用`O(n)`代价完成。

难度：easy

解法：要`O(n)`代价也不难，对于`nums[i]`，考虑它<b>被加了几次</b>。i的左边有x个，右边有y个，其中`x=i+1,y=n-i`。则`nums[i]`总共被加了`cc[i]=(x//2)*(y//2)+((x+1)//2)*((y+1)//2)`次。总和就是`sum(cc[i]*nums[i])`。

<hr>

1592 Rearrange Spaces Between Words

题意：给定英文句子，把空格收集起来，<b>尽量平均分配</b>，放到<b>单词之间</b>。如果有多余空格，按照<b>靠后多一个</b>的原则分布。

难度：easy

解法：水题。

<hr>

1593 Split a String Into the Max Number of Unique Substrings

题意：给定字符串s，将其<b>划分</b>为几个子串，使得所有子串<b>都不同</b>。求<b>最大的划分个数</b>。

难度：medium

解法：<b>数据范围</b>暗示你直接搜，这个确实没法用DP处理。<b>暴力搜吧。</b>

<hr>

1598 Crawler Log Folder

题意：有一些目录访问记录logs，包括“../”、“./”、“x/”三种，代表上一层、当前位置、x子目录。请求出执行logs所有记录后的<b>目录深度</b>。以“/”根目录为0深度。

难度：easy

解法：水题。

<hr>

1600 Throne Inheritance

题意：皇室的血脉和继承顺序，有出生`birth()`，有去世`death()`。按照<b>先父子、后兄弟姐妹</b>的顺序，输出继承顺序。如果成员去世，则从继承顺序中去掉。

难度：medium

解法：题目描述非常啰嗦难懂，但例子一看就明白了，<b>前序遍历</b>。对于<b>成员去世，不能删除</b>对应的节点。只做一下<b>标记</b>，不放入继承顺序即可。可以用`dict[str,list[str]]`的方式来保存<b>树形结构</b>。加一个<b>live标记</b>，用于判断成员是否还活着。

## 1601 - 1700

1601 Maximum Number of Achievable Transfer Requests

题意：有n个房子，编号`0~n-1`。现在有一些调动申请`[x,y]`，表示x房子有一个员工想调动到y房子。现在要求每个房子的总人数都保持不变，也就是`迁入=迁出`。请问最多能满足多少个申请？

难度：hard

解法：这个问题<b>好像挺简单</b>，但仔细一想应该<b>比较难</b>。一种可能的<b>误区</b>是从<b>入度出度的max</b>值入手，认为可以贪心。<>其实不对。</b>看评论区，有人认为是<b>最小代价最大流</b>问题，那就真的挺难了。我没有考虑复杂模型，基于这个小数据量，使用了暴力解法，但是用<b>位压缩</b>提升一下效率。在位操作的情况下，暴力解法的代码其实<b>非常短</b>。因此给人一种这题很简单的错觉。

<hr>

1602 Find Nearest Right Node in Binary Tree

题意：给定二叉树，所有值都唯一。请找出val对应的节点的，<b>同一层的下一个节点</b>。

难度：medium

解法：付费题。这完美符合了<b>层次遍历</b>的做法。用<b>队列</b>处理吧。总代价`O(n)`。

<hr>

1603 Design Parking System

题意：给定<b>大中小</b>车位的数量，每次给定车的类型，请判断当前是否有车位。

难度：easy

解法：水题。

<hr>

1605 Find Valid Matrix Given Row and Column Sums

题意：给定m x n矩阵，你不知道每个元素的值，但你知道<b>m行总和、n列总和</b>，而且<b>所有元素非负</b>。请尝试构造一个<b>符合要求的矩阵</b>，题目保证至少存在一个解。

难度：medium

解法：这题有意思，一件简单的事情<b>反过来</b>，就很有难度了。好像<b>没什么思路</b>。想了很久，关键在于<b>“非负”</b>。比如我随便给mat[i][j]赋值，那么后面有可能出现另一个<b>元素为负</b>的情况。那么保证非负？只要我每次都找<b>最小的x</b>，这样至多剩余元素是0，不会变成负的。那么最小的x怎么定义？就是<b>行&列最小</b>。因此，是`min(rowSum,colSum)`。我需要<b>不断找最小</b>，而且需要<b>一边找一边更新</b>，所以用<b>最小堆</b>。剩下就不说了，总代价`O(mn*(log(m)+log(n)))`。

<hr>

1608 Special Array With X Elements Greater Than or Equal X

题意：对于数组nums，如果存在一个整数x，使得`nums[i]>=x`的个数恰好是x个。

难度：easy

解法：先将nums排序，然后用<b>二分搜索</b>，搜x的值。同时用二分搜索判断>=x的个数。这样相当于<b>双层二分</b>。实际上这个数学模型，就是学术界的<b>H-index</b>。总代价`O(n*log(n)*log(int))`。

<hr>

1609 Even Odd Tree

题意：给定二叉树，根节点为0层，向下依次是123...如果所有偶数层的节点都是奇数且严格递增。所有奇数层都是偶数且严格递减，则称为<b>偶奇树</b>。请判断给定的树是否为偶奇树。

难度：medium

解法：定义很明确。遍历得到<b>每层的值</b>，按规则检查即可。总代价`O(n)`。

<hr>

1611 Minimum One Bit Operations to Make Integers Zero

题意：定义一种奇怪的位操作，你需要通过位操作把n变成0。两种规则，第一，反转<b>最低位</b>；第二，如果存在`1100...00`这样的形式，则可以把它变为`0100...00`。请计算把n变为0的<b>最小步数</b>。

难度：hard

解法：这种规则很别扭，有种成心找茬的感觉。比如你考虑`100`，你必须按照`100->110->10->11->1->0`这种，其中100到110不是一步变化。那么对于连续的1位，比如`11100110`，你可以通过2步变为`100110`。接下来，你需要一些变化，变为`1110`。然后再2步变化，变为`10`，然后是`10->11->1->0`。很复杂，对吧？我最后是通过草稿纸推算，求出<b>变换公式</b>。相当于<b>半个数学解法</b>了。如果你直接递归搜索（记忆化），应该会<b>爆内存+超时</b>。总代价`O(logn)`。

<hr>

1612 Check If Two Expression Trees are Equivalent

题意：一个由符号、运算符组成的算术表达式，可以用<b>语法树</b>表示。现在给定两棵这样的语法树，请判断它们对应的表达式，是否<b>等价</b>。等价的意思是，不论符号<b>赋什么值</b>，两个表达式的最终<b>结果都相等</b>。已知运算符只有“+”加号。

难度：medium

解法：付费题。其实这种问题是很难的，尤其是当你考虑加减乘除括号等运算的情况下，组合非常多。但因为只有加号，那么我只关心每种符号的<b>种类和个数</b>就够了，做一个<b>哈希计数</b>即可。

<hr>

1614 Maximum Nesting Depth of the Parentheses

题意：给定一个合法的算术表达式，请求出括号的最大深度。

难度：easy

解法：水题。

<hr>

1615 Maximal Network Rank

题意：给定一个无向图，我们定义两节点`(x,y)`的rank为直接和<b>x或y</b>连接的<b>边的个数</b>。对于一条边`x-y`，在统计`(x,y)`的rank时只算一次。

难度：medium

解法：规则很明确，可以直接枚举所有(x,y)组合，统计一下。不过统计的时候有个技巧。你可以通过<b>枚举边集</b>，然后针对每条边的`x-y`，都给`rank[x]`、`rank[y]`进行累加。那么`rank[(x,y)]=rank[x]+rank[y]-(1 if (x,y) in roads else 0)`。这样就避免了重复统计，计算<b>效率比较高</b>。最后，从所有`(x,y)`里，找出`max(rank)`。总代价`O(E+V^2)`。

<hr>

1617 Count Subtrees With Max Distance Between Cities

题意：给定一个无向图表示的树，有n节点、n-1条边。给定这个图`G=(V,E)`，你可以从中<b>任选子集</b>`G'=(V',E')`，使得G'也是一棵树，称为子树。给定`d=[1,...,n-1]`，请统计所有可能的子树里，直径为d的个数。直径的意思是图中<b>任意两点的最长距离</b>。

难度：hard

解法：首先，求图的直径，这个在之前遇到过。实际上<b>出题者也默认你会</b>，如果不会就没法做了。参考<b>1245题</b>。对于这题，统计树的个数，这一看就非常难。因为这个个数应该是个<b>组合问题</b>，那么问题是`O(n!)`级别的。`排列组合问题+复杂的判断条件=超级难`。因此，暴力搜吧。题目<b>数据量</b>也告诉你，就得暴力解决。至于暴力怎么做，很简单。n个点，<b>选或不选</b>那就是枚举`O(2^n)`种可能。对于每种可能，我先判断<b>是否为树</b>，再计算<b>树的直径d</b>。`cc[d]+=1`即可。

<hr>

1619 Mean of Array After Removing Some Elements

题意：给定数组nums，请求出删除<b>最小、最大的5%</b>元素之后的均值。

难度：easy

解法：水题。排序之后，二分找出左右边界。对中间段求和即可。总代价`O(nlogn)`。

<hr>

1624 Largest Substring Between Two Equal Characters

题意：给定字符串s，请找出其中两个<b>相同字符c之间</b>的子串的最大长度，且子串不能包含字符c。

难度：easy

解法：水题，其实就是同字符<b>相邻两次出现</b>之间的<b>最大位置之差</b>。用哈希表<b>记录下标</b>即可。总代价`O(n)`。

<hr>

1625 Lexicographically Smallest String After Applying Operations

题意：给定一个数字串，`0~9`组成。你可以执行两种操作<b>任意次</b>。第一，对<b>奇数位置</b>的数字循环+x，`0`变`x`，`9`变`(9+x)%10`；第二，对字符串随意<b>循环移位</b>。请求出能得到的<b>字典序最小</b>的结果。

难度：medium

解法：其实这个“奇数位置”，就是为了把奇偶隔开。对于给定数据规模，你完全可以针对每个s[i]位置，把<b>`s[i]`循环移位到`s[0]`</b>的位置。并使得<b>`s[0]、s[1]`都变成0</b>。这样，后面的`s[i]`值<b>都是确定的</b>。枚举所有这样的做法，能得到n个结果，找出其中最小的就是答案。枚举n个位置，每次枚举，对字符串<b>变换</b>的代价是`O(n)`，因此总代价`O(n^2)`。

<hr>

1628 Design an Expression Tree With Evaluate Function

题意：给定一个<b>算术表达式</b>的<b>后缀表达式</b>形式。请计算表达式的值。

难度：medium

解法：付费题。这个也叫<b>逆波兰表达式</b>，RPN。可以直接用栈处理，遇到运算数，入栈；遇到运算符，就出栈执行计算。总代价`O(n)`。

<hr>

1629 Slowest Key

题意：有一个按键序列，和对应的<b>放手时间</b>。下一键的<b>按键时刻</b>等于上一键的<b>放手时刻</b>。请求出按键<b>持续时间最长</b>的键，如果存在多个，则返回<b>字典序最大</b>的。

难度：easy

解法：水题。<b>相邻相减</b>，然后求`argmax`。

<hr>

1630 Arithmetic Subarrays

题意：给定数组nums，长度为n。现在给定m个查询`(i,j)`。请判断nums[i:j+1]子数组能否通过<b>重排</b>，得到一个<b>等差数列</b>？

难度：medium

解法：如果没有“重排”这个条件，就非常简单了。我直接枚举从nums[i]开始往后，按照`nums[i+1]-nums[i]`这个<b>公差</b>，可以<b>走多远</b>。但现在可以调整顺序，那么<b>土办法</b>，就是真的对`nums[i:j+1]`进行<b>排序</b>，然后判断了。在给定数据量下，这样确实能勉强过。对于重复的查询，把<b>结果缓存一下</b>。我没想出更巧妙的解法，比如<b>单次判断</b>能做到`O(n)`或<b>更低复杂度</b>的解法。

<hr>

1631 Path With Minimum Effort

题意：给定一个m x n矩阵heights，表示每个格子的<b>地形高度</b>。你从`(0,0)`出发，希望到达`(m-1,n-1)`。你可以按照上下左右移动，整条路线的<b>代价</b>，定义为`max(|heights[cur]-heights[last]|)`，也就是相邻格子的<b>最大高度差</b>。请求出<b>最小代价</b>。

难度：medium

解法：这个有点像<b>最短路径</b>，但不是<b>求sum</b>的最短，而是<b>求max</b>。我尝试用Dijkstra（因为我不确定）的思路去做，用常规的<b>队列BFS会超时</b>。因此，用了<b>最小堆</b>进行优化，结果正确且效率OK。正如刚才所说，这里不是`d[u]+uv<d[v]`，而是`max(d[u],uv)<d[v]`。相当于在<b>同样的框架</b>下，只是<b>换了个运算</b>。这种思维要学会，理解<b>换汤不换药</b>的灵活性。总代价`O((V+E)logV)`。

<hr>

1636 Sort Array by Increasing Frequency

题意：给定数组nums，请按照`(+频率,-值)`二维排序。

难度：easy

解法：这种<b>多维排序</b>，对于某些语言确实比较麻烦，但用python超级好写。<b>元组</b>实在太香了。

<hr>

1637 Widest Vertical Area Between Two Points Containing No Points

题意：给定二维平面一些点points，请找出其中两个点，使得两点的(x1,x2)之间没有包含其他点。y坐标无所谓吗，返回`max(|x1-x2|)`。

难度：easy

解法：这题太扯了，之前难度定级是medium，被很多人<b>点踩</b>才改成了easy。对x坐标<b>排序</b>，找相邻的`max(x[i]-x[i-1])`就行了，和y坐标完全无关。

<hr>

1638 Count Substrings That Differ by One Character

题意：给定字符串s和t，请统计s子串，t子串`(ss,tt)`的<b>对数</b>，使得两者<b>长度相同</b>，且只有<b>一个字符不同</b>。

难度：medium

解法：数据规模很小，直接<b>暴力枚举</b>，当然也行。我们看看有没有更好的办法。<b>没想出来</b>，那就暴力过吧。总代价`O(n^3)`。

<hr>

1640 Check Array Formation Through Concatenation

题意：给定数组

难度：easy

解法：虽然题目描述的挺复杂，但关键信息在于<b>“所有值都唯一”</b>。既然唯一，那么对于每个`pieces[i]`里的<b>开头元素</b>，你都可以用哈希表做一下<b>位置映射</b>。这样，你在匹配arr时，对于每个`arr[i]`你都知道去哪个`pieces[j]`里找对应元素。找到开头元素后，依次检查pieces[i]里的剩余元素是否<b>依次匹配</b>。如果所有片段检查完，都能<b>全部匹配</b>，则成功。这个成功条件还是<b>非常苛刻</b>的。还有更土的办法，就是直接<b>DFS暴力搜</b>。这样的话效率还差一大截，但也能过。作为easy题，这题还是<b>略微有难度</b>的。

<hr>

1641 Count Sorted Vowel Strings

题意：请求出由aeiou组成，长度为n且按<b>字典序排列</b>的字符串的个数。

难度：medium

解法：其实这是个<b>组合问题</b>，但用组合公式，好像也没那么容易。还是用<b>DP思路</b>解决吧。我们把`aeiou`看成`01234`五个值，那么我们只关心<b>先后、大小</b>，而不关心具体的aeiou。那么可以定义dp[i][j]为<b>长度为i，以j值结尾</b>的串的个数。剩下的递推关系，就不用说了。DP求和，最后答案就是`sum(dp[n])`。总代价`O(n)`。

<hr>

1646 Get Maximum in Generated Array

题意：给定整数n，生成一个`n+1`长度的数组nums。`nums[0]=0,nums[1]=1`，`nums[2i]=nums[i],nums[2i+1]=nums[i]+nums[i+1]`。请求出`max(nums)`。

难度：easy

解法：n很小，直接生成吧。

<hr>

1647 Minimum Deletions to Make Character Frequencies Unique

题意：给定由小写字母组成的字符串s，你需要删除一些字符，使得剩下字符的<b>频率各不相同</b>。请求出<b>最小删除个数</b>。

难度：medium

解法：首先<b>哈希计数</b>，得到一个<b>频率数组</b>，进行<b>排序</b>。这个数组命名为cc，这个数组长度至多26。对于数组cc，我们再观察连续相等的部分。比如例子`[3,3,3,3,4,4,4,6,8,9]`，那么`[4,4,4]`必须变成`[2,3,4]`，才不会重复。则剩下的`[3,3,3,3]`得继续往下降，变成`[0,0,0,1]`。这其中降成1是因为必须比2小，只能降不能升，且不能出现重复值。只有<b>0值</b>是可以重复的，因为题目说了，已经<b>删光</b>的字母，我们可以<b>忽略不计</b>。因此，这个例子最后得到的频率是`[0,0,0,1,2,3,4,6,8,9]`，总共删除了`3+3+3+2+3+2+1=17`个字符。思维稍有难度，代码则非常简短。总代价`O(n)`。

<hr>

1650 Lowest Common Ancestor of a Binary Tree III

题意：236的变体。给定两个点p、q，父节点可通过parent指针访问。请求出<b>最近公共祖先</b>。

难度：medium

解法：付费题。因为可以访问父节点，而且只有一次查询。可以采取先<b>对齐高度</b>，然后逐渐<b>向上汇合</b>的思路。总代价`O(h)`。

<hr>

1652 Defuse the Bomb

题意：给定<b>循环数组</b>code和整数k。如果k>0，将`code[i]`变为`sum(code[i+1:i+k+1])`；如果k<0，将`code[i]`变为`sum(code[i-k:i])`；如果k=0，将`code[i]`变为0。

难度：easy

解法：做一个子数组求和即可，可以用<b>前缀和</b>快速计算。<b>循环数组</b>，注意下标处理。

<hr>

1653 Minimum Deletions to Make String Balanced

题意：给定字符串s，由ab组成。请从中<b>删除最少的字符</b>，使得剩余字符串里，不存在<b>b在前a在后</b>的情况。

难度：medium

解法：要求所有a在前面，b在后面。那么我们当然可以划分出一个边界，`a...ab...b`这样。因此，我们枚举每个位置i，统计`s[0:i]里b的个数+s[i:n]里a的个数`，这些都要删掉。这个统计在每个i位置，都是可以`O(1)`做到的，总代价`O(n)`。从所有i位置里，求出<b>min值</b>就是答案。看了下以前写的代码，<b>很简短但是没看懂</b>。和我现在的思路好像不一样。

<hr>

1656 Design an Ordered Stream

题意：给定n个数据，每个形如`(id,val)`。id从1~n，val是字符串。现在给定一个插入顺序，请按id升序返回。比如例子`(3,1,2,5,4)`，每次插入一个值，返回目前<b>id连续且递增</b>的最长序列。这个例子，返回的依次是`[[],[1],[2,3],[],[4,5]]`，但返回的不是id，而是<b>对应的val值</b>。

难度：easy

解法：这叫easy？这题目至少90%的人一遍看不懂。当然，题目本身确实不难，但描述太晕了。实际上可以开辟一个n长度数组，再设置一个<b>cur_id指针</b>，初始`cur_id=1`。每当<b>cur_id的对应数据</b>到了，就向前逐个检查，<b>如果存在就输出</b>。因为插入的顺序可能是乱的，你能找到的顺序数据也就不一定存在。不存在就<b>继续等</b>。一道<b>浪费脑细胞</b>的题。总代价`O(n)`，单步均摊`O(1)`。

<hr>

1657 Determine if Two Strings Are Close

题意：给定两个字符串s和t。你可以对<b>s串或t串</b>执行两种操作，任意次。第一，随意交换两个字符；第二，把<b>两种</b>不同字符进行<b>种类互换</b>。比如`aabc`变成`ccba`，`a`和`c`种类互换。请问经过任意次变换，能否把s变成t？

难度：medium

解法：可以交换也就可以<b>随意排序</b>。可以种类互换，也就等于可以<b>交换频率</b>。也就是说，字符顺序和频率顺序都可以随便换了。那么我对s和t都做哈希计数，得到cs、ct。如果`set(s)==set(t) && sorted(cs)==sorted(ct)`就行了。也就是说，两者的字符集一样，频率统计排序后一样，则满足题目要求。总代价`O(n)`，后面的排序、比较成本就忽略不计了。

<hr>

1660 Correct a Binary Tree

题意：有一个二叉树，其中某个节点p的right指向了<b>同层的右侧另一节点q</b>。请找出p节点，删除<b>p和它的整个子树</b>。返回剩余的二叉树。

难度：medium

解法：付费题。既然是同层次，那用层次遍历可以找出。比如层次遍历，那么p、q会先后遍历到，但q还会被重复遍历一次。因为“q在p的下层”<b>（并不是）</b>。因此，我们在做层次遍历的时候，最好保留(p,q)这样的父节点记录。当我发现q重复遍历，那么它的<b>第二个父节点p</b>就是错的。我们<b>删除p时</b>，还需要知道<b>p的父节点</b>。因此，遍历过程中，需要把<b>每个点的父节点</b>都记下来。总代价`O(n)`。这题不算难，但也有一点点难度。

<hr>

1662 Check If Two String Arrays are Equivalent

题意：给定两个字符串数组word1和word2，请判断两个数组<b>所有元素连起来</b>得到的字符串是否相等。

难度：easy

解法：水题。直接`''.join(arr)`然后比较就行了。

<hr>

1663 Smallest String With A Given Numeric Value

题意：我们定义字母`a~z`的对应数值为`1~26`。一个由字母组成的字符串s，对应数值为`sum([i]的数值)`。请求出<b>长度为n，数值为k</b>的<b>字典序最小</b>的字符串。

难度：medium

解法：可以用<b>贪心原则</b>，最前面的字符，我总是希望<b>尽可能小</b>。我从`aaa...aaa`开始，初始数值是n。然后<b>从后往前填z</b>。这样能<b>最快消耗</b>剩余数值，且保持<b>前面的字典序</b>最小。直到把数值都用完，得到最终结果。总代价`O(n)`。

<hr>

1664 Ways to Make a Fair Array

题意：给定数组nums，你可以选定nums[i]删除。如果<b>剩余的数组</b>，`奇数位置之和==偶数位置之和`，则称为<b>公平数组</b>。请求出符合要求的<b>i位置的个数</b>。

难度：medium

解法：删除i元素后，i之后的位置，<b>奇偶性</b>会交换。因此，我们可以采取统计<b>前缀奇、前缀偶、后缀奇、后缀偶</b>的方法。然后，找出所有符合`前缀偶+后缀奇==前缀奇+后缀偶`的i位置，统计个数。总代价`O(n)`，额外空间`O(n)`。

<hr>

1668 Maximum Repeating Substring

题意：给定字符串s，请找出其中<b>连续重复</b>的子串，返回<b>最大重复次数</b>。比如`ababc`，最大重复是`ab`，重复次数是2。

难度：easy

解法：这题和1566题类似，都是找连续重复子串。除了<b>直接暴力匹配</b>外，可以用<b>正则匹配</b>搞定，属于<b>高效偷懒</b>的做法。`re.search(r'(.+)\1+', s)`。先匹配一个子串，然后让它重复`k-1`次。匹配结果里，`总长/子串长=重复次数`。总代价理论应该是`O(n^2)`的，但实际运行效率很接近`O(n)`。

<hr>

1669 Merge In Between Linked Lists

题意：给定链表l1和l2，长度分别为n和m。请将l1的第`[a,b]`节点段删除，并把l2插入到<b>这部分</b>。

难度：medium

解法：很纯粹的<b>链表题</b>，没有算法难度，主要考察<b>耐心仔细</b>。总代价`O(n+m)`。

<hr>

1670 Design Front Middle Back Queue

题意：请在一个双向队列deque的基础上，设计一个支持中间入队、中间出队的队列。如果中间位置有<b>两个元素</b>，则选靠左的一个。

难度：medium

解法：它既然是个双向队列，那我们就用deque。但这次我们用<b>两个deque</b>，命名`d1、d2`，元素<b>各占一半</b>。这样，d1的右侧+d2的左侧，就是<b>“中间”</b>了。我们总是保持`len(d1)>=len(d2)`，且`|len(d1)-len(d2)|<=1`。剩下就是实现题目要求的所有API了，在这种`d1+d2`的设计下，所有操作都是严格`O(1)`的。但是，这题的工作量非常大，除了<b>烦人累人</b>之外，没什么难点了。

<hr>

1672 Richest Customer Wealth

题意：给定矩阵，求<b>单行</b>的<b>最大和</b>。

难度：easy

解法：水题。

<hr>

1673 Find the Most Competitive Subsequence

题意：给定数组nums，请找出长度为k的<b>字典序最小</b>的子序列。

难度：medium

解法：题目给了个奇怪的名称<b>“competitive”</b>，其实翻译过来就是字典序最小。乍一想，没什么思路。仔细想了很久，终于有了个<b>单调栈+双向队列</b>的思路。其中<b>单调栈st在左，双向队列dq在右</b>。两者长度加起来<b>总是等于k</b>。具体思路挺费劲的，直接看我的代码好了，我也是想了很久才弄明白。例子`2433509617834`，变化过程`[24][33]->[2335][]->[233][0]->[23][09]->...`，代码里有注释。为什么搞这么个奇怪组合呢？因为我希望<b>字典序最小</b>，那么如果左边能<b>越变越小</b>，这就符合我的希望。第一，一个<b>单调栈，单调递增</b>，我总是用<b>更小的值</b>替换当前栈内的值，同时保持单调性。第二，后面的值一个个进来，它不一定是单调的，那么我不能把不单调的值都丢掉，因此我用个<b>普通队列先存着</b>，放后面，稍后或许有用。结合这两个思路，就有了这个解法。总代价`O(n)`。我觉得这题比很多hard都难，<b>非常难想</b>。

<hr>

1676 Lowest Common Ancestor of a Binary Tree IV

题意：236的变体。给定二叉树，和树里的<b>一些节点nodes</b>。请返回所有这些节点的最近公共祖先。

难度：medium

解法：付费题。这次不是多次查询，而是给<b>一堆节点</b>找一个LCA。可以采用<b>后序遍历</b>的办法。比如我进行遍历，每遇到一个目标节点，则<b>计数+1</b>。当我向上返回，发现计数恰好等于`len(nodes)`，则这个点就是LCA了。注意，必须采用<b>向上返回+计数求和</b>的方式进行统计，不能在最下层直接+1-1。总代价`O(n)`。

<hr>

1678 Goal Parser Interpretation

题意：做一些特定的字符串替换。

难度：easy

解法：水题，直接`replace`或者`re.sub`函数就行。

<hr>

1679 Max Number of K-Sum Pairs

题意：给定数组nums，你可以从中选两个相加等于k的元素删除。请问最多能删多少次？

难度：medium

解法：按照two sum的思路，我们先对数组<b>排序</b>，用<b>双指针</b>的思路。令`i=0,j=n-1`，然后还是按照two sum的做法，<b>ij逐渐靠拢</b>即可。如果`nums[i]+nums[j]=k`，就可以删除。如果不等于k，则按照大小，选择i或者j进行移动。这样，总打架就是`O(nlogn+n)=O(nlogn)`了。

<hr>

1680 Concatenation of Consecutive Binary Numbers

题意：给定整数n，我们把`1~n`所有数，按二进制形式连成一个01串。请求出这个01串的十进制值，结果模`1e9+7`返回。

难度：medium

解法：<b>二进制值，连起来。</b>那就相当于<b>左移位</b>，然后加上`i`的二进制值。因此我们可以按这种方法，不断进行`res=((res<<ni)|i)%MOD`，其中ni是i的<b>二进制的位数</b>。求位数可以用`ni=int(log2(i)+1)`。总代价`O(n)`，因为题目答案是固定的，可以通过<b>预计算</b>来提高效率。

<hr>

1684 Count the Number of Consistent Strings

题意：给定词表words和字符串allowed。如果一个单词w的字母都在allowed中，则称为<b>一致词</b>。请统计words中一致词的个数。

难度：easy

解法：水题，`''.join(sorted(set(w)))==''.join(sorted(allowed))`。

<hr>

1685 Sum of Absolute Differences in a Sorted Array

题意：给定升序数组nums，请返回一个result数组，长度相同。且`result[i]=sum(|nums[i]-nums[j]|),j=0~n-1`。

难度：medium

解法：我们能不能`O(1)`代价求出`result[i]`？当然可以。因为nums有序，我们可以轻易去掉这个`|...|`。将`sum(|nums[i]-nums[j]|)`转换为前缀和、后缀和两部分，也就是`(i*nums[i]-pre[i-1])+(post[i+1]-(n-1-i)*nums[i])`。注意处理<b>下标问题</b>，`i=0、i=n-1`的情况。将式子化为前缀和、后缀和之后，这两个数组的预计算代价都是`O(n)`，之后的每次枚举代价是`O(1)`。因此，总代价`O(n)`。其实只计算前缀和就足够了。因为<b>任何子数组和</b>，都可以通过<b>前缀相减</b>得到。

<hr>

1686 Stone Game VI

题意：877的变体。有n个石头，且对于AB来说，两人对同一石头的价值评价可能不同，价值为`a[i]、b[i]`。从A开始，每人轮流从中拿一颗石头，拿完为止，最终<b>总分多</b>的人获胜。请判断结果，用+1、0、-1表示A胜、B胜、平手。

难度：medium

解法：好像不容易想出DP的思路，因为每次选石头没有<b>位置限制</b>。因此不好定义形如`dp[i][j]`这样的<b>子问题</b>。想了很多思路，都不对。最终还是看评论区了，答案是按`-(a[i]+b[i])`排序，求和之后降序。<b>非常非常神奇</b>的思路。照着答案去理解，能想出原因。比如考虑一个<b>最大的</b>`a[i]+b[i]`，那么对于A而言，如果`a[i]`很小，则`b[i]`很大，反之亦然。那么如果a[i]被A拿走了，这代表b[i]就损失掉了，<b>B亏了相当于A赚了</b>。如果`a[i]`很大，则A也有动机去拿，因为<b>A直接就赚了</b>。因此，当`a[i]+b[i]`越大，<b>当前玩家</b>就越有动机去拿它。所以，<b>排序</b>的思路就有了。但这个思路，我自己绝对想不出来。只觉得<b>太巧妙了</b>，匪夷所思。总代价`O(nlogn)`。

<hr>

1688 Count of Matches in Tournament

题意：给定n个队伍，如果n是偶数，则举行`n/2`次比赛，晋级`n/2`个队伍；如果n是奇数，则举行`(n-1)/2`次比赛，晋级`(n+1)/2`个队伍。请求出总共的<b>比赛次数</b>。

难度：easy

解法：直接求就行了，总代价`O(logn)`。

<hr>

1689 Partitioning Into Minimum Number Of Deci-Binary Numbers

题意：如果一个十进制数全由01组成，我们称为<b>十-二进制数</b>。现在给定一个<b>十进制大数</b>，请判断<b>至少</b>用几个十-二进制数，可以求和得到它？

难度：medium

解法：非常无聊的<b>智力题</b>，出题人太敷衍了。答案就是<b>最大的数位</b>。

<hr>

1690 Stone Game VII

题意：877的变体。有n个石头，每个价值是`stones[i]`。AB两人轮流拿，每次可从最左或最右拿一个，得分是<b>剩余石头的价值和</b>。最后得分高的人赢。B发现自己<b>必输</b>，因此B的目标改为尽量<b>缩小分差</b>，A则尽量<b>拉大分差</b>。请返回最终<b>A和B的分差</b>。

难度：medium

解法：<b>这么烧脑</b>，题目都看不懂。不过看懂之后，发现并不难，还是比较常规的<b>DP思路</b>。定义`dp[i][j]`为`stones[i:j+1]`的最大得分，则`dp[i][j]=max(sum(stones[i+1:j+1])-dp[i+1][j],sum(stones[i:j])-dp[i][j-1])`。最终答案就是`dp[0][n-1]`。总代价`O(n^2)`。

<hr>

1694 Reformat Phone Number

题意：按照特定格式，格式化一个电话号码。

难度：easy

解法：水题，比较枯燥。

<hr>

1695 Maximum Erasure Value

题意：给定数组nums，你可以从中删除一个<b>子数组</b>，要求子数组没有<b>重复值</b>。请求出删除的<b>最大子数组和</b>。

难度：medium

解法：既然是<b>唯一值</b>，那我们可以用<b>哈希计数</b>。采用<b>滑动窗口+双指针</b>的做法。这个技巧<b>用过很多次了</b>，应该熟悉了。`i=0,j=0`，i固定前进一步，j则在`nums[i]`导致<b>重复值</b>的时候，才向前移动，直到没有重复值为止。这样`(j,i)`范围总是尽可能长，且保证里面没有重复值。在这个过程中，不断求子数组和，更新max即可。总代价`O(n)`。

<hr>

1700 Number of Students Unable to Eat Lunch

题意：有n个三明治和n个学生，用01表示三明治类型。三明治按照<b>栈</b>组织，只能从栈顶拿。学生按照循环队列组织，如果遇到不喜欢的三明治，可以<b>循环转圈圈</b>。请问最终有几个学生<b>吃不到</b>自己喜欢的三明治？

难度：easy

解法：这题描述实在<b>太啰嗦</b>，而且题目本身<b>很无聊</b>。循环队列其实没什么用，因为你可以一直<b>转圈圈</b>，只要当前<b>栈顶的三明治</b>能被任何学生吃掉，就可以继续。否则，就<b>到此为止</b>了。结束时，剩余的<b>三明治个数</b>就是答案。总代价`O(n)`。

## 1701 - 1800

1701 Average Waiting Time

题意：有一个餐馆，有一个厨师。厨师按照客人的到来、点餐<b>顺序</b>做菜。每个客人有`[到达时间,出餐时间]`。厨师同一时刻只能<b>做一个菜</b>，客人会<b>持续等待</b>。请求出所有客人的<b>平均等待时间</b>。

难度：medium

解法：因为<b>出餐顺序是固定的</b>，这个问题就没有动脑的成分了。按顺序处理，求出所有的等待时间，计算平均即可。`等待时间=出餐时间-客人到达时间`，总代价`O(n)`。

<hr>

1704 Determine if String Halves Are Alike

题意：给定字符串s，长度为偶数。请将其分为等长的两部分`a+b=s`。请判断a和b是否包含相同的<b>元音个数</b>，包括<b>大小写</b>。

难度：easy

解法：水题。元音是`aeiou`，包括大小写。

<hr>

1706 Where Will the Ball Fall

题意：有一个m x n矩阵，球从第0行开始往下滚动。用`-1`表示`/`，`+1`表示`\`，也就是向<b>左下、右下</b>滚动。如果遇到“\/”V型，则会停下来。如果遇到“//”或者“\\”，则可以继续往下。现在从第0行的每一列放一个球，请求出每个球能否<b>掉出最下排</b>。用`answer[i]`表示第0行i列的球最终<b>滚出的列数</b>。如果球被卡住了，则返回-1。

难度：medium

解法：这题难点在于理解题目，明白题意之后，按照“//”或者“\\”向下滚动即可，遇到“\/”<b>V型结构</b>，就卡住不动了。总代价`O(mn)`。

<hr>

1708 Largest Subarray Length K

题意：给定数组nums，元素值唯一。请找出其中长度为k，<b>字典序最大</b>的子数组。

难度：easy

解法：付费题。这题其实是<b>智力题</b>。字典序比较，本来是个`O(n)`的事情，但因为nums的元素值唯一，因此第一个元素就不同。因此，对nums的<b>字典序比较</b>，代价是`O(1)`的。总代价`O(n)`。

<hr>

1710 Maximum Units on a Truck

题意：给定不同种类的盒子，给定每种的`(个数,单个重量)`。现在给定一辆卡车，给定可放<b>箱子的个数</b>。请求出能装的<b>最大总重量</b>。

难度：easy

解法：水题，排序即可。

<hr>

1716 Calculate Money in Leetcode Bank

题意：给定一个数列{1,2,3,4,5,6,7,2,3,4,5,6,7,8,...}，找规律，求出前n项和。

难度：easy

解法：纯<b>算术题</b>。规律就是7天一个等差数列，而且<b>每7天</b>，等差数列的<b>首项+1</b>。可以在草稿纸上<b>列一下公式</b>，然后求和。不能完全算水题，<b>公式推导</b>还是需要一点脑力的。

<hr>

1717 Maximum Score From Removing Substrings

题意：给定字符串s，你可以执行两种操作。删除一个“ab”，则得分x；删除一个“ba”，则得分y。如果允许执行<b>任意次</b>两种操作，请问<b>最大的得分</b>是多少？

难度：medium

解法：首先，我们只关心由“ab”组成的子串，那么其他字符都是<b>不相关的</b>。那么我们分离出其中的ab子串，逐个处理。我们考虑`aab、bba、aaa、bbb、aba、bab`这样的情况。不难发现，`aaa、bbb`这种没用；aab、bba这种不需要选择；只有<b>`aba、bab`</b>这样的情况，我们才<b>需要考虑</b>应该怎么做。那么比如`x>y`，也就是说`ab`更值钱，我应该怎么选？我们看`aba`，去掉ab得到a，去掉ba还是得到a，那么我应该选ab，得x分。同理`bab`，去掉ab得到b，去掉ba还是得到b，那么我应该选ab。因此，这个题是<b>贪心</b>的。剩下要做的，就是按照ab和ba的分治，优先删除<b>分值高的</b>。比如`x>y`，则<b>先删ab后删ba</b>。总代价`O(n)`。这题的难度甚至超过了一些hard，主要在于<b>难想</b>。

<hr>

1718 Construct the Lexicographically Largest Valid Sequence

题意：给定`1~n`，请构造一个长度`2n-1`的序列。要求1出现1次，`2~n`各出现2次。且对于每个i，两个i出现的<b>位置恰好相差i</b>。请返回所有这种序列里，字典序最小的一个。

难度：medium

解法：挺神奇的要求，乍一想没什么思路。在草稿纸上画了一下，认为可以尝试<b>搜索</b>。但怎么做到字典序最小呢？那肯定是<b>前面的元素</b>尽可能小。但想尝试用贪心策略，是不可能的。经过尝试，最终发现暴力搜+适当剪枝可行，但得到字典序最小的关键方法，是从`n~1`<b>反着搜</b>。我想不出怎么<b>用数学解释</b>，至少我说不清楚。但正着搜，答案确实是错的。总代价就算`O(n!)`吧，实际经过剪枝，效率<b>勉强可接受</b>。

<hr>

1720 Decode XORed Array

题意：给定数组arr，把<b>相邻元素</b>都做<b>异或</b>，得到了数组`encoded`。现在给定`arr[0]`和`encoded`，请还原出数组arr。

难度：easy

解法：水题。按照`encoded[i]=arr[i]^arr[i+1]`的关系，一步步推出来就行了。

<hr>

1721 Swapping Nodes in a Linked List

题意：给定链表，请交换<b>正数第k和倒数第k</b>节点。

难度：medium

解法：题意很明确，你可以交换<b>节点值</b>，或者交换节点本身。我选择节点值，稍微容易点。总代价`O(n)`。

<hr>

1725 Number Of Rectangles That Can Form The Largest Square

题意：给定一个一些长宽值`[x,y]`，我们从中剪出<b>正方形</b>。请求出能得到的边长为`max(min(x,y))`的正方形的个数。

难度：easy

解法：水题，先求出最大边长，然后统计<b>等于最大边长</b>的个数。

<hr>

1726 Tuple with Same Product

题意：给定数组nums，没有重复值。请从其中元素里，选出`(a,b,c,d)`，使得`ab=cd`。调整元素顺序，视为<b>不同组合</b>。请求出组合的个数。

难度：medium

解法：首先，对于给定的一个组合，你可以通过2*2*2调整出8个顺序。那么我们搜组合数，<b>结果*8</b>。我们枚举`nums[i]*nums[j]`，进行<b>哈希计数</b>。比如某个`mm[x]=cc`，那么总共有cc个组合，乘积等于x。则共有`C(cc,2)=cc*(cc-1)/2`种组合数，共有`cc*(cc-1)*4`个结果。把所有这些结果累加，就是最终答案。总代价`O(n^2)`。

<hr>

1727 Largest Submatrix With Rearrangements

题意：给定01矩阵，你可以任意<b>交换列</b>。请求出能得到的<b>全是1</b>的子矩阵的<b>最大面积</b>。

难度：medium

解法：如果不能交换，求<b>全1子矩阵</b>的问题之前已经做过了，在<b>85题</b>。现在允许做列交换，应该怎么换？其实，还是按照类似<b>84题、85题</b>，直方图最大矩形的思路。我们针对每列，按照从上到下，求一个“前缀和”。这个前缀和按照<b>1累加0清零</b>的做法。比如`[1,1,0,1,0]`变成`[1,2,0,1,0]`。针对每列求出前缀和之后，你可以在<b>每行</b>得到一个<b>数组</b>。对数组排序（因为你可以交换列），剩下就不说了。你可以想象一个<b>递增的直方图</b>，求其中的<b>最大矩形面积</b>。总代价`O(mn)`。

<hr>

1732 Find the Highest Altitude

题意：你从海拔0出发，每次高度变化为`gain[i]`。请求出<b>最高海拔</b>。

难度：easy

解法：水题。

<hr>

1734 Decode XORed Permutation

题意：给定一个`1~n`的排列perm。你不知道perm，但知道perm的相邻元素异或的值encoded，其中`encoded[i]=perm[i]^perm[i+1]`。请求出perm。已知<b>n是奇数</b>。

难度：medium

解法：首先，给定n的规模，不能用`O(n^2)`的方式去<b>暴力枚举</b>。其实关键在于<b>n是奇数</b>。比如`1^2^3^...^n=sm`。那么encoded共有n-1个值，我们按照`encoded[0]^encoded[2]^...^encoded[n-1]`，结果就恰好等于`perm[0]`。你知道`perm[0]`，就<b>知道一切</b>了。总代价`O(n)`。这题其实是<b>智力题</b>。

<hr>

1736 Latest Time by Replacing Hidden Digits

题意：给定`hh:mm`格式的时间，其中可能包含“?”。允许把<b>问号</b>替换为<b>任意数字</b>，请求出能得到的<b>最晚的时间</b>。

难度：easy

解法：水题，而且挺枯燥。

<hr>

1738 Find Kth Largest XOR Coordinate Value

题意：给定m x n矩阵mat，我们定义`val[i][j]`为`mat[0:i+1][0:j+1]`的所有值的异或。请求出val[i][j]的<b>第k大</b>的值。

难度：medium

解法：这个矩阵的<b>前缀异或</b>，其实和<b>前缀求和</b>的思路一样。具体做法就不说了，之前已经做过很多次了。得到所有`val[i][j]`值之后，用一个<b>大小为k的最小堆</b>，可以得到第k大的值。当然，求第k大，你<b>直接排序</b>也可以的。效率不如最小堆，但思路更容易。总代价`O(mn+mn*log(mn))=O(mn*log(mn))`。

<hr>

1740 Find Distance in a Binary Tree

题意：给定二叉树中两个节点p和q，请求出p到q的距离。

难度：medium

解法：付费题。用<b>0左1右</b>的方式，找出p和q的路径，然后针对<b>路径串</b>求距离即可。比如`00101`和`011`的距离，等于`(5-1)+(3-1)=6`。总代价`O(n)`。

<hr>

1742 Maximum Number of Balls in a Box

题意：给定整数`[x,y]`，请对每个值的<b>数位求和</b>，统计每个求和的<b>个数</b>。请求出最大的个数。

难度：easy

解法：按题意实现。求数位和，<b>哈希计数</b>，然后返回`max(mm.values())`。

<hr>

1743 Restore the Array From Adjacent Pairs

题意：有一个数组nums，长度为n，且<b>没有重复值</b>。现在给定`n-1`组相邻关系，你只知道数对，但不知道相邻是<b>左右还是右左</b>。请给出一种<b>可能的nums结果</b>。

难度：medium

解法：不论左右还是右左，它总有<b>两个边界</b>，对吧？那么边界值在数对里，都<b>只出现1次</b>，而其他值则出现了两次。因此，我们先找出<b>边界值</b>，然后沿着边界，逐个求出<b>下一个元素</b>。比如`[[2,1],[3,4],[3,2]]`，很明显1、4是边界。比如我选1作为`nums[0]`，就可以逐步求出整个数组`[1,2,3,4]`。如果我选4作为`nums[0]`，那么结果就是`[4,3,2,1]`。总代价`O(n)`。

<hr>

1748 Sum of Unique Elements

题意：给定数组nums，请求出所有<b>唯一值的和</b>。

难度：easy

解法：水题。

<hr>

1749 Maximum Absolute Sum of Any Subarray

题意：给定数组nums，请求出所有<b>子数组和的绝对值</b>的最大值。

难度：medium

解法：最大子数组和，但这次加了个`abs()`。那么我们对于<b>负值</b>，也要考虑进去。其实很简单，我把<b>所有元素都*-1</b>，然后再执行一次<b>最大子数组和</b>，就相当于处理了负值问题。这是个<b>镜像问题</b>，对吧？总代价`O(n)`。

<hr>

1750 Minimum Length of String After Deleting Similar Ends

题意：给定abc组成的字符串s，你可以选择前缀s1、后缀s2进行删除，如果：第一，两者都是单值；第二，两者的单值字符相同；第三，两者位置不交叉。比如`aabca`可以变为`bc`。经过任意次操作，请求出剩余串的<b>最小长度</b>。

难度：medium

解法：题目描述很<b>啰嗦</b>，但问题本身<b>非常简单</b>。其实就是从<b>两端</b>不断删掉<b>相同字符</b>。这个medium难度不合理。用`i=0,j=n-1`双指针即可。总代价`O(n)`。

<hr>

1752 Check if Array Is Sorted and Rotated

题意：给定数组nums，请判断是否<b>循环有序</b>。意思是nums经过一次<b>循环移位</b>，可以变成<b>升序数组</b>。

难度：easy

解法：水题。

<hr>

1753 Maximum Score From Removing Stones

题意：有三堆石头，个数分别是abc。每次，你选<b>两堆石头</b>，各取1个石头，得1分。如果剩余石头不足两堆，则游戏结束。请求出<b>最大得分</b>。

难度：medium

解法：总共就3个数，我们当然不需要<b>一个一个地模拟</b>。其实我们按照`(min,mid,max)`三个值。总是从`(mid,max)`里取，直到mid降到等于min为止。`(min,mid,max)->(min,min,max-mid+min)`新得到的值又可以分出`(min,mid,max)`，持续这个过程，直到<b>三堆变两堆</b>。再取min(x,y)，<b>两堆变一堆</b>。总代价`O(log(min(a,b,c)))`。

<hr>

1756 Design Most Recently Used Queue

题意：设计一个<b>类似队列</b>的数据结构，长度为n，初始数据是`[1,2,...,n]`。支持`fetch(k)`操作，将<b>第k个值</b>移动到<b>队尾</b>并<b>出队</b>。

难度：medium

解法：付费题。我们考虑一下`O(1)`代价的实现。如果我用数组，那么`fetch()`之后，剩余与元素的挪动需要`O(n)`时间，不可行。如果我用链表，那么寻找第k个元素需要`O(k)`时间，不可行。如果我用<b>双向链表+哈希表</b>的映射方式，LRU cache的做法，好像<b>还是不行</b>。因为我找的是第k个，经过一次移动，后面所有的位置映射<b>都会错位</b>。我不可能在O(1)代价内，精确定位到<b>第k个</b>，还能同时修复后面<b>所有的错位</b>。结论是，我想不出<b>全`O(1)`的解法</b>。最后我用了<b>双向链表</b>解决，`O(k)`解法。

<hr>

1758 Minimum Changes To Make Alternating Binary String

题意：给定01字符串s，每次你可以反转一个字符。请问至少多少次反转，可以把s变成<b>01交替</b>？

难度：easy

解法：按照<b>01交替或者10交替</b>，分别判断一下次数，<b>取min</b>即可。

<hr>

1759 Count Number of Homogenous Substrings

题意：给定字符串s，请求出所有<b>单值子串</b>的个数。结果模`1e9+7`返回。

难度：medium

解法：对于长度n的单值串，个数就是`n*(n+1)/2`。按<b>每段</b>进行<b>求和</b>即可。比如`aaabbccccd`，就是四段。总代价`O(n)`。

<hr>

1760 Minimum Limit of Balls in a Bag

题意：有n个包包，每个里面有`nums[i]`个球。你可以执行k次操作，每次操作你可以任选一个值，将其分为两个正值，比如`nums[i]=x+y`。拆分之后还可以再拆分。请求出经过<b>至多k次</b>操作以后，`min(max(袋子里求的个数))`的值。

难度：medium

解法：还是非常经典的<b>minimax问题</b>。那么这个问题有没有<b>单调性</b>？有的。比如我<b>不执行操作</b>，那么答案就是`max(nums)`。现在我希望把这些值拆得更小，这样`max(nums)`也会<b>随之变小</b>。因此，我按照`[1,max(nums)]`作为二分的<b>上下界</b>。对于每个值x，我判断是否能<b>不超过k次拆分</b>，使得`min(max(nums))<=x`。单次判断的代价是`O(n)`，因此总代价是`O(nlog(int))`。

<hr>

1762 Buildings With an Ocean View

题意：给定n个房子，从左到右，高度分别是`heighs[i]`。已知大海在最右边，对于<b>i位置</b>，如果i的右侧不存在<b>比它更高的</b>`heights[j]`，则i位置可以看到海。请求出所有能看海的i位置，按升序排列。

难度：medium

解法：付费题。很明显，这是个有<b>单调性</b>的问题，而且非常简单。我只要统计<b>后缀max</b>，然后比较`heights[i]`和后缀max即可。如果`heights[i]>max(heights[i+1:n])`，则i位置可以看到海。总代价`O(n)`。

<hr>

1763 Longest Nice Substring

题意：给定字符串s，由26个字母组成。如果一个串的<b>所有字母</b>，都是<b>对应大小写</b>均出现，则称为<b>“好串”</b>。比如`AbBBa`是好串，`abccBA`不是。现在请求出s的<b>最长好子串</b>，如果存在多个，则返回位置<b>最靠前的</b>。

难度：easy

解法：题目本身还是略有难度的。但<b>数据很小</b>，怎么做都行。讲道理，我也没想出什么<b>特别高效</b>的办法。除了用<b>位操作</b>标记一下字母的<b>出现情况</b>。比如小写标1，大写标2，则大小写就是`1|2=3`，<b>位操作</b>。总代价`O(n^2)`。

<hr>

1764 Form Array by Concatenating Subarrays of Another Array

题意：给定一组数组groups和一个数组nums。请问`groups[i]`是否<b>依次</b>在nums中作为<b>子数组</b>出现，且互相位置不存在交叉。

难度：medium

解法：原题目的描述<b>非常费解</b>，几乎看不懂。但翻译过来就是这个意思。这个不是子序列，而是子数组匹配。其实相当于把“子数组”视为一个元素，然后再匹配<b>“子数组的子序列”</b>。有点绕嘴。如果要效率高的话，可以用KMP之类的<b>高效算法</b>，进行子串匹配，对于每个`groups[i]`，找到第一个匹配下标`match[i]`，然后继续在`nums[match[i]+len(groups[i]):n]`里找下一个匹配`groups[i+1]`。这样的话，总体时间倒是可以做到`O(n^2)`，不过高效的匹配算法，得自己实现。更简单的话，就<b>暴力匹配</b>。总代价`O(n^3)`，但实际执行一般会<b>接近`O(n^2)`</b>。

<hr>

1765 Map of Highest Peak

题意：给定一个m x n地形idWater，0陆1水。现在你需要给每个位置指定一个高度`height[i][j]`。要求水的高度是0，陆地高度至少是1。且相邻两格的高度差<b>至多是1</b>。请求出`max(max(height[i][j]))`。

难度：medium

解法：既然希望地形<b>尽可能高</b>，那么我们就尽量多+1。我们从水格子作为起点，以0高度开始<b>执行BFS</b>。那么对于<b>陆地</b>的`(x,y)`位置，`h[x][y]=min(h[x+offx][y+offy])+1`，也就是要取四个方向最矮的一个+1。这样才不会违反<b>高度差为1</b>的规则。不用担心`[0,1,2,3,4,1,0]`这种情况，不可能出现的。因为你在执行BFS时，每个水格子<b>前进的速度</b>一样，最后高度提升也是<b>均匀的</b>，肯定对半分。这个<b>min运算其实也是多余的</b>，因为BFS第一次到达某个格子，这个值本身就是min的。总代价`O(mn)`。

<hr>

1768 Merge Strings Alternately

题意：给定字符串s1、s2，按照<b>s1、s2字符交替</b>的方式合并成一个串。如果有多余字符，则加到末尾。

难度：easy

解法：水题。

<hr>

1769 Minimum Number of Operations to Move All Balls to Each Box

题意：给定一个01串，长度为n。代表n个盒子，其中1表示这个盒子有1个球。如果每次允许你把<b>一个球移动到相邻盒子</b>，允许一个盒子有多个球。对于每个位置i，请求出至少多少次能把所有球移动到i盒子。

难度：medium

解法：显然，这题就是让你在`O(n)`总代价内，求出n个位置的答案。那么我们可以考虑<b>i和i+1的关系</b>。我们考虑<b>前缀1、后缀1</b>的个数。从左到右，一边统计前缀1的个数`pref`，一边给`answer[i]+=pref`。后缀1的统计，反之亦然。正反累加完成后，`answer`结果就出来了。总代价`O(n)`，正反遍历两次。

<hr>

1773 Count Items Matching a Rule

题意：给定一些记录`(类型,颜色,名称)`，和一些规则，可能是<b>类型、颜色、名称</b>的一种。请判断给定记录，是否匹配<b>任意一条规则</b>。

难度：easy

解法：水题。

<hr>

1775 Equal Sum Arrays With Minimum Number of Operations

题意：给定数组nums1、nums2，所有值都在`1~6`。每次允许你从<b>两数组</b>任选一个元素，改为<b>`1~6`的任意值</b>。请问至少多少次操作，可以使<b>两数组之和</b>相等。

难度：medium

解法：首先，数组的长度比较大。我们用<b>哈希计数</b>，统计`1~6`的个数，改为cc1、cc2<b>两个长度6的数组</b>。考虑题目的对称性，我们不妨假设`sum(cc1)<=sum(cc2)`。那么cc1应该加，cc2应该减。我们考虑<b>三种做法</b>：第一，cc1加；第二，cc2减；第三，cc1加且cc2减。如果第一第二都不够，则第三；如果第三还不够，则<b>无解</b>。要注意，<b>“cc1加”和“cc2减”</b>是不同的，因为两者用的<b>次数可能不一样</b>。对于加，采取加到6；对于减，采取减到1。总之，这题虽然是<b>贪心思路</b>，但也挺麻烦的。虽然计算量不大，但<b>动脑+代码</b>有点费劲。总代价`O(n)`。

<hr>

1779 Find Nearest Point That Has the Same X or Y Coordinate

题意：给定一个点`[x,y]`，和一些点`[ai,bi]`。如果`[ai,bi]`和`[x.y]`有相同的<b>x或y坐标</b>，称为有效点。请求出<b>曼哈顿距离最小</b>的有效点的下标。如果有多个，则返回下标最小的一个。

难度：easy

解法：水题。题意很清晰了，按要求实现即可。

<hr>

1780 Check if Number is a Sum of Powers of Three

题意：给定整数n，请判断n是否为<b>3的不同幂</b>相加得到。

难度：medium

解法：如果你考虑用类似<b>01背包</b>的思路去做，那就考虑错了。其实，只需要<b>模3除3</b>即可。如果模3的<b>余数总是0或者1</b>，则符合要求。总代价`O(logn)`。这其实就是<b>3进制</b>。

<hr>

1781 Sum of Beauty of All Substrings

题意：一个字符串的<b>“颜值”</b>，定义为`max(字符频率)-min(字符频率)`。给定字符串s，请返回它所有子串的颜值之和。

难度：medium

解法：这个倒是有意思，所有子串，都要求`max(freq)-min(freq)`。我们当然不可能<b>都统计一遍</b>。对于给定数据量，`O(n^2)`的枚举可以接受。那么，我们就从i位置开始，<b>逐个加字符，更新统计</b>。在每次添加字符时，要同时得到<b>max值和min值</b>。这个可以用`SortedDict`，以`O(logn)`代价得到。因此，单次枚举代价是`O(logn)`，总代价则是`O(n^2logn)`。看了下以前的代码，我写了个`O(n^3)`的暴力解法，也过了。

<hr>

1784 Check if Binary String Has at Most One Segment of Ones

题意：给定01字符串s，请判断s中是否<b>至多有1段</b>连续的1。

难度：easy

解法：水题。

<hr>

1790 Check if One String Swap Can Make Strings Equal

题意：给定字符串s1、s2，请问能否在s1或s2中执行一次字符串交换，使得`s1==s2`。

难度：easy

解法：水题。判断`s1[i]!=s2[i]`的位置，如果恰好有<b>两个</b>，而且<b>交叉相等</b>，则可以通过一次交换满足要求。

<hr>

1791 Find Center of Star Graph

题意：有一个无向图，n个节点，n-1条边。已知这个图是星型，有一个中心点。请找出这个中心点。

难度：easy

解法：很显然，中心点的<b>度数</b>是`n-1`。

<hr>

1792 Maximum Average Pass Ratio

题意：有n个班级，每个班共有`x_i`人，其中`y_i`人可以通过考试。现在有额外的z人，这些人都可以通过考试，你可以把这些人分配到n个班级。请设法分配，使得`mean(y_i/x_i)`，也就是<b>平均通过率最大</b>。求出`max(mean(y_i/x_i))`。

难度：medium

解法：我的第一想法是<b>贪心原则</b>。比如我有z个人，那么我分配z次，每次我都找<b>目前通过率最低</b>的班级，分配1个人。因此，可以用<b>最小堆</b>处理。总代价`O((n+z)logn)`。我没仔细想这个思路<b>对不对</b>，直觉认为是对的。实际运行也对，但<b>怎么证明</b>我没想好。

<hr>

1793 Maximum Score of a Good Subarray

题意：给定数组nums，我们定义一个数组的分值为`min(arr)*len(arr)`，也就是<b>最小值乘以长度</b>。请求出包含了`nums[k]`的<b>子数组</b>的最大分值。

难度：hard

解法：hard，肯定需要一个高效算法。对于这题，目标应该是`O(n)`。可以<b>贪心</b>吗？实际上除了贪心，我也想不出DP的思路。我们用双指针ij，从`k,k`出发，向左向右走。每次我都比较`nums[i]`和`nums[j]`，取较大的一个。试验的结果，<b>贪心是对的</b>。但为什么贪心是对的？我们可以用<b>反证法</b>，不过具体怎么证我还没想好。总代价`O(n)`。像这种算法题，经常出现代码跑通了、结果对了，但<b>数学证不出来</b>的情况。这种时候别太强求，<b>码农就是码农</b>，数学这种看看就行，<b>学不会的</b>。

<hr>

1796 Second Largest Digit in a String

题意：给定字符串s，请求出其中出现的出现的<b>第二大数字</b>。

难度：easy

解法：水题。

<hr>

1797 Design Authentication Manager

题意：设计一个<b>鉴权令牌</b>的管理结构。可以在`cur`时刻<b>生成</b>`id`的令牌，有效期为`ttl`。也可以对已有的id令牌，在`cur`时刻进行<b>刷新</b>，刷新后有效时间延长至`cur+ttl`。此外，还要支持查询当前`cur`时刻，<b>有效令牌</b>的个数。

难度：medium

解法：当然，如果你没做过<b>IAM</b>相关的业务，确实会对这题的应用场景赶到陌生。身份认证时，会发一个<b>令牌</b>。令牌会<b>过期</b>，过期前可以<b>刷新</b>，刷新也就是<b>延长时效</b>。第一想法是用一个<b>SortedDict</b>，以生成（或刷新）时间作为key。其实<b>刷新</b>操作，你可以理解为<b>删除+生成</b>操作。因为是SortedDict，可以通过<b>二分搜索</b>找到下标，这样可以<b>统计个数</b>。对于查询`cur`时刻的有效令牌数，其实相当于查询<b>`cur-ttl`之后生成</b>的令牌数。基于SortedDict，所有基本操作的代价都是`O(logn)`。

<hr>

1798 Maximum Number of Consecutive Values You Can Make

题意：给定一些硬币，每个的面值是`coins[i]`。请求出最大的k，使得从[0,k-1]都可以由这些硬币的<b>面值相加</b>得到。

难度：medium

解法：乍一想，最坏情况是类似`[1,2,4,8,...]`这样，因为这样可以得到所有的值。但你仔细想想，这题并不需要像<b>01背包</b>那样处理。比如我用`coins[0:i+1]`可以拼出的<b>最大连续值</b>是`[0,x]`。那么，关键来了，如果`coins[i]>x+1`，那就<b>g了</b>，因为`x+1`这个值我<b>得不到</b>。如果`coins[i]<=x+1`，那我可以得到的<b>连续范围</b>就成了`[0,x+coins[i]]`。思路<b>简洁而巧妙</b>，总代价`O(n)`。鉴定为<b>智力题</b>。

<hr>

1800 Maximum Ascending Subarray Sum

题意：给定数组nums，请求出<b>严格递增子数组</b>的最大和。

难度：easy

解法：元素都是正的，因此严格递增可以按照<b>贪心原则</b>去匹配，多多益善。总代价`O(n)`。

## 1801 - 1900

1801 Number of Orders in the Backlog

题意：现在有一些不同类型商品的买入、卖出订单。格式是`<买卖,数量,种类>`。如果存在`买价>卖价`的情况，则按照<b>最高买价、最低卖价</b>。不断执行这个逻辑，处理所有交易记录。对于<b>无法满足</b>的买卖记录，则放入库存。请计算最后库存里<b>剩余多少记录</b>？结果模`1e9+7`返回。

难度：medium

解法：请了解<b>股票买卖</b>的基本模型，<b>bid、ask</b>之类的。ask是买，bid是卖，`ask>=bid`，交易才能发生，这个差价就是bid-ask spread，赚差价。促成交易的就是做市商，<b>market maker</b>。可以说这就是金融市场的<b>“物种起源”</b>了。这题非常好，可以说是给金融0知识的人，做了个基本科普。这个题本身倒是很容易，我既然需要求出最大最小，且需要<b>随时更新</b>，而且买、卖有明确的区别，那我可以把<b>买放入最大堆、卖放入最小堆</b>。剩下就不用说了。总代价`O(nlogn)`。

<hr>

1805 Number of Different Integers in a String

题意：给定字符串，找出其中<b>连续数字串</b>，代表的整数的<b>唯一值</b>个数。

难度：easy

解法：水题。

<hr>

1806 Minimum Number of Operations to Reinitialize a Permutation

题意：给定一个长度n的数组，n是偶数，初始是`[0,1,...,n-1]`。每次执行类似扑克牌洗牌的操作，比如`[0,1,...,n-1]`变成`[0,n/2,1,n/2+1...,n/2-1,n-1]`

难度：medium

解法：其实这个就是扑克牌里，<b>切牌洗牌</b>的做法，`123456`变成`142536`。那么这个置换方式经过多少次能<b>还原</b>？其实这是个<b>置换群</b>，我们需要求出每个环的周期（阶、order），那么总周期就是LCM，<b>最小公倍数</b>。当然，你不管这些代数知识，直接去模拟也可以，但那样的效率就差一个数量级了。以置换群求周期，总代价是`O(n)`。直接进行模拟，总代价则是`O(n^2)`。LCM算法是基于GCD的，<b>最大公约数</b>。这个复杂度非常低，可以忽略不计了。

<hr>

1807 Evaluate the Bracket Pairs of a String

题意：给定一个字符串，其中包含类似“[key]”形式的<b>括号串</b>。在给定一些`[key,value]`信息的情况下，请<b>将“[key]”替换为“value”</b>。如果key没有出现在给定信息中，则替换为<b>“?”</b>。

难度：medium

解法：<b>字符串题</b>，中规中矩。没有嵌套括号之类的复杂情况，解析并替换即可。总代价`O(n)`。

<hr>

1812 Determine Color of a Chessboard Square

题意：给定8 x 8国际象棋棋盘，输入格子坐标，请判断黑白。

难度：easy

解法：水题，`x+y`的奇偶判断。

<hr>

1816 Truncate Sentence

题意：给定一个英文句子，请截取前k个单词。

难度：easy

解法：水题，先split，再join。

<hr>

1817 Finding the Users Active Minutes

题意：给定一些用户操作记录，格式为`[id,t]`，表示id用户在t分钟时活跃。活跃时间按<b>唯一值</b>统计，同1分钟多次活跃只统计1次。现在请求出<b>总活跃时间</b>分别为`1~k`分钟的用户个数。

难度：medium

解法：题目很清晰，就是<b>哈希计数、累加</b>。总代价O(n)。

<hr>

1822 Sign of the Product of an Array

题意：给定数组nums，请求出nums元素乘积的符号，用0或者+-1表示。

难度：easy

解法：水题。

<hr>

1823 Find the Winner of the Circular Game

题意：约瑟夫环问题。n个人排<b>1圈</b>，从1开始每数到第k个，就淘汰。剩下的下一个继续从1开始，数到k再淘汰。最后剩下的一人是赢家，请求出赢家的序号。

难度：medium

解法：原版的<b>约瑟夫环问题</b>。直接模拟，代价当然是`O(nk)`，可以用<b>链表</b>实现。这题的精妙之处，在于<b>子问题转化</b>。可以考虑<b>n问题和n-1问题</b>之间的关系，两者的<b>偏移量</b>是多少？我们以0下标为准，<b>正推公式</b>就是`res=(res+k)%i,i=2~n`。对于1下标，所有值都+1即可。总代价`O(n)`。

<hr>

1826 Faulty Sensor

题意：有两个数组a1和a2，原本完全相同。但其中一个数组<b>可能丢失了</b>一个元素，并在结尾随机添加了一个元素。请判断丢失数据的是<b>1还是2</b>数组。如果没有丢失，则返回-1。

难度：easy

解法：付费题。从头到尾进行比较，如果<b>全对</b>，则<b>没有丢失</b>。如果有丢失，则必然存在一个<b>不匹配</b>。比如`a1[i]!=a2[i]`，则后面进行反向匹配。判断`a1[i]`和`a2[i+1]`，或者`a1[i+1]`和`a2[i]`是否对应相等。前者，则a1丢失；后者，则a2丢失。总代价`O(n)`。

<hr>

1827 Minimum Operations to Make the Array Increasing

题意：给定数组nums，每次你可以任选一个元素+1。请问至少多少次操作，能使nums<b>严格递增</b>。

难度：easy

解法：把`nums[i]`变为`max(nums[i],nums[i-1]+1)`。

<hr>

1828 Queries on Number of Points Inside a Circle

题意：给定n个点`[xi,yi]`，和m个圆`[rxi,ryi,ri]`。针对每个圆，请判断有多少个点被包含在圆内，<b>边界</b>也算在内。

难度：medium

解法：对于圆内，用`距离<=半径`可以判断。那么我们直接枚举`O(mn)`次可以完成，这算是暴力解法。有没有更好的办法？可以稍微优化一下，比如我们按照x顺序排序，按y顺序排序。这样可以直接把`dx>r`或者`dy>r`的点排除掉，减少<b>无效计算</b>。虽然总代价还是`O(mn)`，但这个O会稍微小一点。除此之外，没想出更巧妙的办法。

<hr>

1829 Maximum XOR for Each Query

题意：给定数组nums和整数mb。对于每个前缀`nums[0:i+1]`，请求出一个值`answer[i]<(1<<mb)`，使得`xor(nums[0:i+1])^answer[i]`最大。

难度：medium

解法：题目描述挺费解的，但大致意思就是<b>给前缀求异或</b>，然后再异或一个值，使得结果最大。这个异或的值`answer[i]`至多是<b>mb位二进制数</b>。其实读懂后会发现<b>这题很简单</b>，虽然题目挺难懂。比如5位数`01001`，那我异或`10110`就得到`11111`了，这就是最大了。因此，实际上就是对`nums[0:i+1]`求异或，得到的结果取<b>低mb位</b>，然后<b>取反</b>。所以，确实如评论区所说。这题本身不难，但是<b>描述太差</b>导致<b>强行变难</b>了。

<hr>

1832 Check if the Sentence Is Pangram

题意：给定字符串，请判断是否包含了全部26个字母。

难度：easy

解法：水题。

<hr>

1833 Maximum Ice Cream Bars

题意：有n个巧克力，价格为`costs[i]`。你总共有coins的钱，如果购买顺序任意，请问最多能买几个冰淇淋？请用<b>计数排序</b>完成。

难度：medium

解法：我很难理解，为什么要提“计数排序”。这<b>随便什么排序</b>都可以吧，按<b>最便宜的买</b>就行了。总代价`O(nlogn)`。

<hr>

1836 Remove Duplicates From an Unsorted Linked List

题意：给定链表，请删除所有存在重复的值，只保留<b>唯一值</b>。

难度：medium

解法：付费题。用哈希表统计<b>唯一值</b>，然后再遍历一次进行删除操作即可。就不要想各种奇奇怪怪的巧妙解法了。总代价`O(n)`。

<hr>

1837 Sum of Digits in Base K

题意：给定整数n，请求出n在k进制之下的<b>数位之和</b>。

难度：easy

解法：水题，进制转换。

<hr>

1839 Longest Substring Of All Vowels in Order

题意：给定一个aeiou组成的字符串，请求出至少包含<b>aeiou各一个</b>，且<b>升序排列</b>的最长子串。返回长度。

难度：medium

解法：这题的关键在于<b>别想太复杂</b>，这<b>不是滑动窗口</b>。因为要求<b>升序排列</b>，我们直接用一个数组记录当前找到的<b>最长子串</b>即可。如果我遇到了<b>降序</b>，则当前的整个子串就可以清空了，因为你只能放弃<b>之前的所有字符</b>。总代价`O(n)`。

<hr>

1844 Replace All Digits with Characters

题意：给定`[字符,数字,字符,数字,...]`交替形式的字符串，请把所有数字位置，都按`右移(字符,数字)`替换为移位后的字符。比如`a2b3c1`变为`acbecd`。

难度：easy

解法：水题，读懂题目后就很容易。

<hr>

1845 Seat Reservation Manager

题意：设计一个预定座位的数据结构，支持`reserve()`预定序号最小的空闲作为；支持`unreverse(n)`释放n号已预订的座位。

难度：medium

解法：很显然，实现方法要保证两个操作都是`O(1)`或者均摊`O(1)`。那么比如我们用一个<b>数组</b>，则寻找空闲的代价是`O(n)`，不行。用<b>哈希表</b>记录类似<b>已占用区间</b>的话，也不能做到`O(1)`查找。最后，我想了个<b>最笨但也最简单</b>的办法，用`SortedSet`直接记录`reserved`和`free`<b>两个集合</b>。这样就能以`O(logn)`代价完成两种操作了。实现简单，思路直观，很好。

<hr>

1846 Maximum Element After Decreasing and Rearranging

题意：给定数组nums，所有元素都是正数。你可以任意<b>重排顺序</b>，或者对任意元素<b>减去任意正值</b>。要求`nums[0]=1`，且任意相邻元素相差不超过1。请求出可能得到的`max(nums[i])`的<b>最大值</b>。

难度：medium

解法：题目读懂了就会发现<b>很简单</b>。在可以随意排序的情况下，我们当然会选择<b>升序排列</b>。然后把`nums[0]`先变成1，再对后面的元素，依次取`min(nums[i],nums[i-1]+1)`，这样能保证相邻元素<b>相差不超过1</b>。最后返回`nums[n-1]`的值，总代价`O(nlogn)`。

<hr>

1848 Minimum Distance to the Target Element

题意：给定数组nums，请求出位置i，使得`nums[i]==target`，且i和位置start最近。返回`|i-start|`。

难度：easy

解法：水题。

<hr>

1850 Minimum Adjacent Swaps to Reach the Kth Smallest Number

题意：给定一个数字串`num`，请找出比它大的<b>第k个排列</b>`num'`。求出从`num`到`num'`至少要做多少次<b>相邻交换</b>。

难度：medium

解法：这是<b>两个问题</b>，第k个next permutation，多少次相邻交换。第一个问题其实可以有更高效、更数学的解，但我没写出来。应该是和<b>数位DP</b>相关。第二个问题，难度不大，就不细说了。我执行了k次next permutation，因此总代价是`O(nk)`。计算相邻交换次数，平均代价接近`O(n)`，但最坏情况是`O(n^2)`。因此，这题的总代价是`O(n*(n+k))`。对于给定数据量<b>可接受</b>，但不算太好。

<hr>

1852 Distinct Numbers in Each Subarray

题意：给定数组nums，请求出所有<b>k长度</b>的子数组的<b>唯一值个数</b>。

难度：medium

解法：付费题。固定大小的<b>滑动窗口</b>，用<b>哈希表</b>不断更新统计即可。总代价`O(n)`。

<hr>

1854 Maximum Population Year

题意：给定n个人的<b>出生、死亡</b>年份，请计算<b>人口最多</b>的年份。如果存在多个，返回最早的一个。在世时间按照`[x,y)`计算。

难度：easy

解法：相当于区间覆盖，求<b>最大覆盖次数</b>。因为是<b>批处理</b>问题，我们可以用哈希表，按照`mm[x]+=1`和`mm[y]-=1`处理，然后按值<b>从大到小</b>的顺序，进行<b>后缀累加</b>。这个排序操作，也可以改用SortedDict。这样值本身就是有序的，反向遍历即可。对于<b>easy难度</b>，这题算难题了。

<hr>

1855 Maximum Distance Between a Pair of Values

题意：给定两个<b>降序数组</b>nums1、nums2，请找出`i<=j`，满足`nums1[i]<=nums2[j]`。求出`max(j-i)`。如果不存在，则返回0。

难度：medium

解法：因为数组都是有序的，我们使用<b>双指针</b>`i=0,j=0`。对于每个`nums1[i]`，我都将j尽量前进，<b>直到`nums1[i]>nums2[j]`</b>。因为i、j都是不回头，只前进的，因此总代价是`O(n1+n2)`，答案就在`j-i-1`里取max。

<hr>

1859 Sorting the Sentence

题意：给定“<单词><序号> <单词><序号>...”格式的句子，请按<b>序号</b>重新排序单词。返回排序后的句子。

难度：easy

解法：水题。

<hr>

1860 Incremental Memory Leak

题意：有一个程序，占用内存不断增加。第i秒时，会<b>新分配</b>i个内存单位。有两个内存条，每次都从空闲更多的内存分配。如果空闲一样，则从1卡分配。请求出`[崩溃时间,内存1剩余,内存2剩余]`。

难度：medium

解法：题目很清晰，直接<b>按题意模拟</b>就可以。总代价是`O(sqrt(n))`，n是内存容量。

<hr>

1861 Rotating the Box

题意：给定一个m x n矩阵，表示<b>带格子</b>的一个箱子。其中有空格、障碍物、石头。石头在空位时，会因为<b>重力</b>往下掉。现在把这个箱子<b>顺时针旋转90度</b>，请求出旋转之后的状态。

难度：medium

解法：顺时针90度，那么<b>右就成了下</b>。因此，你可以先把石头向右推，再旋转；也可以先旋转，再把石头向下推。<b>怎么“推”</b>的细节就不说了，总代价`O(mn)`。这题还挺有意思，训练<b>形象思维</b>。

<hr>

1863 Sum of All Subset XOR Totals

题意：给定数组，求出所有<b>子集</b>的<b>异或</b>的<b>和</b>。

难度：easy

解法：n长度，那么子集共有`2^n`个。求和，这也没什么技巧了。直接<b>DFS搜索+枚举求和</b>即可。总代价`O(2^n)`。

<hr>

1865 Finding Pairs With a Certain Sum

题意：给定数组nums1、nums2，设计一个数据结构。支持`nums2[i]+=val`，支持查询`nums[i]+nums2[j]==tot`的对数。已知nums1很小，nums2很大。

难度：medium

解法：这题的关键在于数据量，如果nums2很大，我们就不能设计一个需要<b>经常遍历nums2</b>的算法。nums1不变，那么我们可以对nums1进行<b>哈希计数cc1</b>。nums2可变，则我们同时保留<b>nums2数组和哈希计数cc2</b>。对于查询<b>求和个数</b>，我可以遍历cc1，对于其中每个值`x`，我都在cc2里找`tot-x`。这样，`add()`函数的代价能保持`O(1)`，`count()`函数的代价是`O(n1)`，因为n1很小，这个效率可以接受。

<hr>

1869 Longer Contiguous Segments of Ones than Zeros

题意：给定01串，请判断<b>最长连续1的个数</b>，是否严格大于最长连续0的个数。

难度：easy

解法：水题。

<hr>

1874 Minimize Product Sum of Two Arrays

题意：给定数组nums1、nums2，如果允许你调整nums1的顺序，请求出`min(sum(nums1[i]*nums2[i]))`。

难度：medium

解法：付费题。其实允许调整nums1，也就相当于<b>允许调整nums1和nums2</b>。既然元素都是<b>正数</b>，从直观上，肯定是按照<b>大乘小</b>这样搭配，结果<b>最小</b>。当然，数学证明麻烦点，用<b>反证法</b>应该可以做到。那么我们`nums1.sort()`，`nums2.sort(reverse=True)`，就可以了。总代价`O(nlogn)`。

<hr>

1876 Substrings of Size Three with Distinct Characters

题意：给定字符串s，请求出<b>长度3且无重复字符</b>的子串的个数。

难度：easy

解法：水题。

<hr>

1877 Minimize Maximum Pair Sum in Array

题意：给定长度2n的数组nums，请将其分为n个<b>数对`(xi,yi)`</b>。使得`max(xi+yi)`最小，求出这个最小的最大值。

难度：medium

解法：贪心原则，把数组<b>排序</b>。按照小配大的方式。`i=0,j=2n-1`，<b>向中间靠拢</b>。这样得到的数对组合，肯定是<b>尽可能平均</b>的。因此，最大值一定最小。总代价`O(nlogn)`。

<hr>

1880 Check if Word Equals Summation of Two Words

题意：如果字符`a~j`表示`0~9`。给定字符串，我们将其转为整数值。现在给定w1、w2、w3，请将其转为整数值i1、i2、i3，并判断`i1+i2`是否等于i3。

难度：easy

解法：数据很小，不用<b>大数计算</b>，直接用int类型处理。

<hr>

1884 Egg Drop With 2 Eggs and N Floors

题意：你有两个一样的鸡蛋。鸡蛋在`<=f楼`时，掉下不会破；`>f楼`时，则会破。现在允许你设计扔法，至少需要扔几次，能确定f的值？

难度：medium

解法：经典<b>智力题</b>，扔鸡蛋问题。不是一般的典，<b>典中典</b>。如果鸡蛋无限个，那当然用<b>二分策略</b>。但你只有2个鸡蛋，而且必须能求出f的值。如果你<b>扔光了还没求出f</b>，那就算失败。比如有1000层楼，我按10层楼分一段，则有100段。每段内10层，我需要精确到1的粒度。因此，最坏情况需要`100+10=110`次。但我一定要分成<b>均匀的段</b>吗？不一定。因此，思维可以变为<b>“我下个鸡蛋丢到`cur+x`层”</b>，然后往`dp[k][n]`表示k个鸡蛋总共丢到n层考虑。总代价`O(kn^sqrt(n))`，此处k=2，因此等于`O(n^1.5)`。这个<b>根号n</b>怎么来的？就是刚才说的100层分10段，只有<b>最均匀的分段</b>，平均效率是最好的。

<hr>

1886 Determine Whether Matrix Can Be Obtained By Rotation

题意：给定nxn方阵mat和target。请判断mat能否通过旋转变成target。

难度：easy

解法：按照<b>0、90、180、270</b>四个方向比较即可。

<hr>

1887 Reduction Operations to Make the Array Elements Equal

题意：给定数组nums，每次操作，你可以选取<b>一个最大值mx</b>，将其变为<b>第二大值smx</b>。请问至少多少次操作，可以把nums<b>所有元素变相等</b>？

难度：medium

解法：对nums进行<b>哈希计数</b>，然后按照key<b>从大到小</b>，把<b>个数</b>进行<b>后缀累加</b>。比如`[3,5,5,2,1]`，统计后是`{1:1,2:1,3:1,5:2}`。那么从5开始累加，就是`2->3->4->5`，但最后那个5是不需要的。因为所有元素都变成<b>最小值</b>，任务已经完成了，不用再变了。因此总次数是`2+3+4=9`次。总代价`O(nlogn)`。

<hr>

1893 Check if All the Integers in a Range Are Covered

题意：给定一些区间`[x,y]`，请判断区间`[left,right]`是否被这些区间完全覆盖了。

难度：easy

解法：做<b>区间合并</b>，判断合并结果里的某个区间是否完全包含了`[left,right]`。因为合并后的结果一定<b>不相交</b>，那么包含目标区间的肯定是<b>某个</b>特定区间，不可能是多个。如果做不到<b>完整包含</b>，那就说明有<b>漏掉的点</b>。总代价`O(n)`。

<hr>

1894 Find the Student that Will Replace the Chalk

题意：有n个学生，编号`0~n-1`。初始有k个粉笔，第i个学生会用`chalk[i]`个。从`0~n-1`<b>循环进行</b>。请问第几个学生时，粉笔<b>不够用</b>了？

难度：medium

解法：对chalk<b>求和</b>得到sm，先`k%=sm`，去掉<b>整圈的值</b>。然后逐个相减。总代价`O(n)`。

<hr>

1895 Largest Magic Square

题意：一个k阶幻方的所有k行、k列、两个对角线，<b>求和都相等</b>。现在给定m x n矩阵，请求出幻方的<b>最大阶数</b>。

难度：medium

解法：对k行、k列、两个对角线都计算<b>前缀和</b>，总代价`O(n^2)`。然后枚举每个`(i,j)`位置为左上角。利用前缀和，计算子数组和。总体思路就是枚举，总代价为`O(n^2*n*1)=O(n^3)`，额外空间`O(n^2)`。

<hr>

1897 Redistribute Characters to Make All Strings Equal

题意：有n个词words，每次你可以任选`words[i]`的一个字符，移动到`words[j]`的任意位置。请问能否通过多次操作，使<b>所有词相同</b>？

难度：easy

解法：所有单词进行<b>哈希计数，并求和</b>。如果每种字符的数量都是<b>n的倍数</b>，就可以<b>均分</b>。

<hr>

1899 Merge Triplets to Form Target Triplet

题意：给定一些三元组triplets`[ai,bi,ci]`，和一个目标三元组`[x,y,z]`。每次你可以任选`[ai,bi,ci]`和`[aj,bj,cj]`，然后把j元组更新成`[max*(ai,aj),max(bi,bj),max(ci,cj)]`。如果你可以执行任意次操作，使得其中一个元组等于`[x,y,z]`？

难度：medium

解法：这个合并操作，相当于选两个元组，取两者的<b>较大值</b>。那么对于triplets中任何<b>超过x、y、z的值</b>，我们都可以<b>丢弃</b>，那些是不能用的。其实可以直接用<b>贪心思路</b>，把所有同时满足`a<=x,b<=y,c<=z`的值都进行<b>合并</b>，最后结果如果是`[x,y,z]`就满足；不是，就不满足。总代价`O(n)`。
