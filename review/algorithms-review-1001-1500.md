# LeetCode 一句话题解 - 1001-1500

[返回目录](./README.md)

- [LeetCode 一句话题解 - 1001-1500](#leetcode-一句话题解---1001-1500)
  - [1001 - 1100](#1001---1100)
  - [1101 - 1200](#1101---1200)

代码库地址：  
[https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/1001-1500](https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/1001-1500)

## 1001 - 1100

1002 Find Common Characters

题意：给定一个词表words，请统计在所有单词中都出现的字母，<b>顺序任意</b>。返回结果<b>包括字母种类和个数</b>，可以是多个。

难度：easy

解法：<b>哈希计数</b>，取min即可。

<hr>

1003 Check If Word Is Valid After Substitutions

题意：我们定义<b>一种操作</b>，在一个字符串的<b>任意位置</b>，插入“abc”。给定字符串s，请判断能否<b>从空串“”开始</b>，经过若干次操作得到s？

难度：medium

解法：乍一看，可能会想类似`dp[i][j]`的思路。其实仔细想想，这是个<b>栈操作</b>。比如“aabcbc”，那么当我<b>攒够一个abc</b>，我就可以把它<b>出栈</b>了。`[a,a,b,c]->[a]`，继续入栈bc，得到`[a,b,c]->[]`。按照这个思路，用一个栈处理整个字符串，如果最后能<b>清空整个栈</b>，则序列有效。奇怪的是，我以前的代码直接用的<b>暴力解法</b>，也过了。

<hr>

1004 Max Consecutive Ones III

题意：485的变体。给定01数组nums，如果你至多可以反转k个0，请问能得到的<b>最长连续1的个数</b>是多少？

难度：medium

解法：这题有两种思维，一种是想办法找出<b>应该反转0的位置</b>。这种很难，做不出来。另一种是找出一个窗口，使得窗口尽量长，且<b>窗口里有至多k个0</b>。你看，<b>滑动窗口</b>的思路就有了。这个滑动窗口<b>连dict都不需要</b>，因为我们只关心0的个数。

<hr>

1005 Maximize Sum Of Array After K Negations

题意：给定数组nums，你必须执行<b>k次操作</b>，每次任选一个元素乘以-1。请返回<b>最大的数组和</b>。

难度：easy

解法：根据<b>负数的个数</b>，分情况讨论。因为可以重复选同一个元素，那么<b>如果k很大</b>，我们可以浪费2m次操作，剩下k-2m次则用于<b>把负数变正</b>。

<hr>

1006 Clumsy Factorial

题意：阶乘知道吧？我们定义一种<b>奇怪的阶乘</b>`clumsy(n)=n*(n-1)/(n-2)+(n-3)-(n-4)*...`。但是这个式子依然按<b>正常的+-*/优先级</b>执行，除法以<b>整除</b>为准。给定n，请求出clumsy(n)的值。

难度：medium

解法：`a/b*c`、`+d-`，按照这两部分做<b>结合</b>。数据规模也不大，就这样<b>3131分组</b>，进行计算就行了。

<hr>

1007 Minimum Domino Rotations For Equal Row

题意：给定等长的数组tops、bottoms。每次允许你<b>任选位置i</b>，将`tops[i]`和`bottoms[i]`交换。请判断是否可能让tops或者bottoms变成<b>同一个值</b>。

难度：medium

解法：可以反过来想。如果能做到，则表示<b>某个值x</b>在<b>所有tops[i]或bottoms[i]都出现了</b>。因此，用哈希表记录每个值出现的位置。如果某值x出现在n个位置，则符合要求。对于<b>最小交换次数</b>，则考虑这个x所处的位置，<b>在tops居多，还是bottoms居多</b>。

<hr>

1008 Construct Binary Search Tree from Preorder Traversal

题意：给定前序遍历，请重建出一棵<b>二叉搜索树</b>。

难度：medium

解法：BST的中序遍历是有序的，因此你相当于有了<b>前序和中序</b>。剩下不说了。

<hr>

1009 Complement of Base 10 Integer

题意：给定整数n，请将其二进制表示进行01反转。

难度：easy

解法：水题。

<hr>

1010 Pairs of Songs With Total Durations Divisible by 60

题意：给定数组times，请找出其中`(times[i]+times[j])%60==0`的`(i,j)`对数。

难度：medium

解法：用哈希表，进行前缀计数。如果当前元素`times[i]%60==r`，则统计之前余数为`60-r`的个数。总代价O(n)。

<hr>

1011 Capacity To Ship Packages Within D Days

题意：有n件货物，重量为weigts[i]。如果每天运输的货物总量不能超过limit，且你需要在days天内，<b>按weights的顺序</b>运完。请问<b>limit最小值</b>是多少？

难度：medium

解法：首先，这个问题有<b>单调性</b>。因此可以用二分搜索limit的值，那么判断依据怎么定？判断依据应该是limit取某值x时，能否在days天完成运输。实际上，本题的关键在于“按weights的顺序”。<b>如果可以乱序</b>，这个问题就成了<b>背包问题</b>，那就难了。要求按weight顺序的话，<b>每次判断运送天数</b>，就很容易，可以用O(n)代价完成。这样，总代价就是O(nlog(int))。

<hr>

1013 Partition Array Into Three Parts With Equal Sum

题意：给定数组nums，请判断能否划分为<b>左中右三段</b>，使得三段的<b>子数组和都相等</b>。

难度：easy

解法：对于easy题，这题还是<b>稍难</b>的。我们<b>枚举j维度</b>，则`nums[j:n]`这段<b>后缀和</b>我们可以O(1)获取，比如值为sm。则我们在前缀`nums[0:j]`里，判断是否存在某个前缀和`nums[0:i]`等于sm。如果存在，且中段`nums[i:j]`恰好也等于sm，则<b>三等分</b>就找到了。这些<b>前缀、后缀和</b>都需要O(n)代价进行<b>预处理</b>，处理之后就可以O(1)查询了。枚举j维度代价是<b>O(n)</b>，每个位置的判断代价为<b>O(1)</b>，因此总代价是O(n)。

<hr>

1014 Best Sightseeing Pair

题意：给定数组nums，任选选取两个位置`i<j`，则得分为`nums[i]+nums[j]+i-j`。请求出<b>最大得分</b>。

难度：medium

解法：O(n^2)枚举的做法很简单，需要想想<b>优化</b>办法。一种方法是对数组先按值排序，然后直接<b>暴力枚举</b>。但是枚举时，可以加一点检查，<b>让循环尽早结束</b>。除此之外，想不出很高效的解法。看到评论区，有人说可以理解为`(nums[i]+i)+(nums[j]-j)`，这样就简单了。<b>确实。</b>

<hr>

1015 Smallest Integer Divisible by K

题意：给定正整数k，请求出一个最小的n位数，使得所有数位都是1，且这个数<b>被k整除</b>。返回n，如果不存在则返回-1。

难度：medium

解法：其实你可以理解为<b>余数</b>。比如从1开始，1、10、100、...每个<b>都对k取模</b>。这样我会得到一个余数序列，且这个序列<b>一定是循环的</b>。那么我可以按这个方式，进行<b>累加</b>。如果发现余数求和的序列，<b>能到达0</b>，则可以得出最小的n值。因为余数求和序列也<b>一定是循环的</b>，如果循环节不包括0，则表示这个数<b>永远不会被k整除</b>。

<hr>

1016 Binary String With Substrings Representing 1 To N

题意：给定01字符串s和一个整数n。请判断对于<b>`[1,n]`的所有数</b>，是否可以在s中找到它们的二进制表示。

难度：medium

解法：观察<b>数据范围</b>，可以发现n很大，但<b>s的长度不大</b>。那么我们可以枚举所有s的子串，并统计对应的整数值。检查统计结果是否<b>覆盖了`[1,n]`所有值</b>。这基本就是<b>暴力解法</b>了，但至少对于s的长度，是<b>可接受的</b>。看了下当年代码，我似乎写了个更暴力的解法，<b>竟然还过了</b>。

<hr>

1017 Convert to Base -2

题意：给定整数n，请转换为<b>-2进制</b>。

难度：medium

解法：<b>负数进制</b>，有意思。其实<b>千万不要想复杂</b>，还是按常规的<b>进制转换</b>的做法，<b>模r除r</b>，只不过这次`r=-2`。就这么简单。

<hr>

1018 Binary Prefix Divisible By 5

题意：给定01数组nums，我们用xi表示`nums[0:i+1]`构成的<b>二进制数</b>的值。请返回所有<b>xi被5整除</b>的对应位置i。

难度：easy

解法：水题。

<hr>

1019 Next Greater Node In Linked List

题意：给定单链表，对于每个节点，请找出它之后，<b>第一个大于它的值</b>。如果没有更大值，则按0处理。

难度：medium

解法：不论数组还是链表，其实无所谓。用一个<b>单调栈（或队列也行）</b>，可以处理这个问题。这个栈<b>单调递减</b>，比如当前元素是x，那么如果栈顶元素`y<x`，则表示<b>y的next greater</b>找到了。这时让y<b>出栈</b>。持续出栈，直到栈顶`y>=x`为止，这时<b>把x入栈</b>。按照这个逻辑，最后<b>留在栈中</b>的值，<b>都不存在next greater</b>，结果都按0处理。

<hr>

1020 Number of Enclaves

题意：给定m x n地形，0水1陆地。从任意陆地出发，可以按4邻接方向移动到<b>另一陆地或者出界</b>。请统计所有陆地格子中，<b>不能走出界</b>的个数。

难度：medium

解法：用<b>洪泛算法</b>，搜索<b>不和边界格子连通</b>的陆地个数。或者反过来想，从<b>边界的陆地</b>开始搜索。那么剩下<b>没有被搜到的个数</b>，就是答案。

<hr>

1021 Remove Outermost Parentheses

题意：给定一个<b>匹配的括号序列s</b>，如果找不出`s1+s2=s`，使得s1、s2都是匹配序列，则称s是一个<b>原始串</b>。现在给定s，将它划分为几个原始子串，并去掉每个子串的<b>最外层括号</b>。返回去掉后的剩余结果。

难度：easy

解法：题目讲得挺复杂，思路倒是不难。用一个栈进行模拟，<b>“(”入栈，“)”出栈</b>。当栈<b>恰好清空</b>，证明你找到了一个<b>原始串</b>，记录下对应的<b>左右边界</b>，把<b>边界的“(”和“)”</b>去掉即可。

<hr>

1022 Sum of Root To Leaf Binary Numbers

题意：给定二叉树，节点值都是0或1。从根到叶组成的路径表示一个<b>二进制数</b>。请求出所有<b>路径之和</b>。

难度：easy

解法：按题意，递归求和即可。

<hr>

1023 Camelcase Matching

题意：<b>驼峰命名法</b>，比如“HelloWorld”，HW大写。现在给定一个词表queries和一个模式串。请判断单词里的<b>大写字符</b>是否符合<b>给定模式</b>。符合的标准是，给定单词w和模式p，你可以在p中<b>插入小写字符</b>，<b>使其变为w</b>。

难度：medium

解法：其实就是<b>判断子序列</b>。但判断过程中，如果发现单词里的<b>大写字符没有匹配</b>，则不符合要求。因为你<b>只能插入小写字符</b>，大写必须全部匹配。

<hr>

1024 Video Stitching

题意：给定一些`[x,y]`形式的区间clips，请从其中选出最少的区间，使得拼起来能<b>完整覆盖`[0,t]`范围</b>。返回选出的<b>区间个数</b>。

难度：medium

解法：首先按`(x,y)`维度<b>排序</b>。接下里，O(n^2)的DP思路很容易想到了。对于`clips[i]`，枚举`0~i-1`，看是否满足`clips[j].y>=clips[i]`，如果满足，则`dp[i]=min(dp[i],dp[j]+1)`。我们只关心<b>最少用dp[i]步</b>能到达i位置。最后检查结果时，判断两个条件：<b>i位置</b>是否能到达，<b>右边界t</b>是否能覆盖`clips[i].y>=t`。那么<b>左边界0</b>怎么确定呢？左边界在DP计算时，已经确定过了。

<hr>

1025 Divisor Game

题意：给定整数n，玩一种游戏。两人轮流选一个<b>n的约数x，且x<n</b>，n变为<b>n-x</b>。如果一方<b>无法找到x</b>，则输掉游戏。请判断<b>先手</b>是否必胜？

难度：easy

解法：还是按照博弈的<b>基本思路</b>：定义<b>一步状态转移</b>关系`x->y`，如果<b>所有</b>y都输，则x输；如果<b>存在某个</b>y能赢，则选这条赢的路，x赢。照这个思路，搜索所有状态转移，用<b>DP思路</b>可以解决。对于一道easy题，这已经很难了。

<hr>

1026 Maximum Difference Between Node and Ancestor

题意：给定二叉树，请求出其中两节点a、b的<b>最大差值`|a.val-b.val|`</b>，且a是b的祖先节点。注意，是<b>祖先节点</b>，不一定是父节点。

难度：medium

解法：因为是祖先节点，我可以往下看。对于任何点p，p所在子树总有个<b>最小值、最大值</b>。那么我用`max_val`、`min_val`表示。则这个<b>子树之内</b>，答案只能是`|p.val-max_val|`、`|p.val-min_val|`其中之一。按这个思路，遍历整棵树即可。

<hr>

1027 Longest Arithmetic Subsequence

题意：给定数组nums，求出最长的<b>算术子序列</b>长度。算术意思是<b>等差数列</b>。

难度：medium

解法：很明显的<b>DP思路</b>，枚举两个维度`j<i`，则公差`d=nums[i]-nums[j]`。我可以用`dp[(i,d)]`表示以i位置为<b>终点</b>，公差为d的<b>等差数列的长度</b>。实际上dp数组的类型是`list[dict[int,int]]`，细节就不说了。为什么<b>倒推</b>，而不用正推呢？因为i之后的值，<b>你还不知道</b>，无法<b>复用子问题的结果</b>，这不符合DP的思维。

<hr>

1028 Recover a Tree From Preorder Traversal

题意：给定一种特殊的前序遍历。对于节点p，如果它深度为d，则输出d个`-`，再输出`p.val`。根节点的深度为0。如果节点只有<b>1个子节点</b>，则一定是<b>左节点</b>。按照这个遍历结果的字符串，重建整棵树。

难度：hard

解法：首先当然是字符串处理，解析成`[(深度,节点值)]`的格式。既然是前序遍历，那我们从深度变化，来判断是往下还是往上。比如`1-2--3--4-5--6--7`，处理后对应`[(0,1),(1,2),(2,3),(2,4),(1,5),(2,6),(2,7)]`。那么我们从i=0开始，根据i+1位置的深度，来判断我应该往下<b>1层</b>，还是往上<b>1或几层</b>。至于<b>左右节点</b>，如果左子树已经遍历了，就往右；否则，先创建左子树。总体上，不算特别难，但需要一点<b>脑力+体力</b>的一题。

<hr>

1029 Two City Scheduling

题意：有2n个人，每个人前往a城、b城的代价，分别是`costs[i]=[ai,bi]`。现在需要各n人前往两个城市，请求出<b>最小的总代价</b>。

难度：medium

解法：其实这题有点<b>脑筋急转弯</b>。如果你按<b>DP思路</b>做，也可以，但很复杂。我们考虑选出了n人去a城，n人去b城，则可以理解为`sum(所有a[i])-sum(没被选中的a[j])+sum(对应被选中的b[j])`。这其中`sum(a[i])`是固定值，因此我们尽可能让`sum(没被选中的a[j]-b[j])`<b>最大</b>，则总代价就<b>最小</b>。于是，你按a[i]-b[i]排序，选出<b>后n个值</b>，就是最大值了。对后n个，我们<b>取b城</b>；前n个，则<b>取a城</b>。代码非常简单，但思维并不容易。<b>有点坑人。</b>

<hr>

1030 Matrix Cells in Distance Order

题意：给定<b>行数列数n、m</b>，以及中心点`(r0,c0)`。请按照距离<b>从近到远</b>，给n*m个坐标排序。距离以Manhattan距离`|x1-x2|+|y1-y2|`为准。

难度：easy

解法：按题意实现即可，<b>排序</b>。

<hr>

1031 Maximum Sum of Two Non-Overlapping Subarrays

题意：给定数组nums和长度n1、n2。请在其中找出两个长度为n1、n2的<b>不重叠子数组</b>，使得<b>子数组和加起来</b>最大。

难度：medium

解法：按照<b>前缀max、后缀max</b>的方式，求出每个i位置的<b>子数组最大和</b>。针对n1、n2都求一次。然后按照<b>n1左n2右、n2左n1右</b>的方式求出最大值。思路不难，写起来还挺麻烦的。

<hr>

1033 Moving Stones Until Consecutive

题意：有三颗石头，位于`a<b<c`三个位置。每次操作，你可以选左右端点的一个，把石头移动到k位置，且满足`a<k<c,k!=b`。这个步骤必然会缩小范围，如果最终<b>abc挨在一起</b>，则操作结束。请求出你能执行的最大、最小操作次数。

难度：medium

解法：最大次数简单，我每次只移动一格，而且区间长度也至少-1。那我就每次-1，答案是`c-a-2`。<b>最小次数</b>，要想一下。比如abc，我拿a，则我肯定应该把a放到bc中间，这样就成了bac。为什么？因为这样我直接<b>消灭了一个区间</b>。因此，每次我都<b>消灭更长的区间</b>，也就是`max(ab,bc)`。其实<b>至多2次就能搞定</b>，想想为什么？这题总体上是个<b>智力题</b>。

<hr>

1034 Coloring A Border

题意：给定m x n矩阵grid，`grid[i][j]`的值表示颜色，想通颜色的4邻接格子组成一个<b>连通分量</b>。现在给定位置`(r,c)`，请将对应的连通分量的<b>边界</b>改为color颜色。

难度：medium

解法：洪泛算法，从`(r,c)`出发，<b>执行BFS</b>并且找出边界，修改值为color即可。

<hr>

1035 Uncrossed Lines

题意：给定数组nums1和nums2，你可以选定`nums1[i]`和`nums2[j]`连一条线，如果<b>两者的值相等</b>。每个元素不能发出<b>超过一条线</b>，且要求所有线不能<b>交叉</b>。请问至多能连几条线。

难度：medium

解法：重点是线不能<b>交叉</b>。也就是说，对于上一条线`(i1,j1)`，我们的下一条线`(i2,j2)`必须满足`i1<i2,j1<j2`。<b>贪心还是DP？</b>应该是<b>DP</b>。我们定义`dp[i][j]`表示`nums1[0:i+1]`和`nums2[0:j+1]`部分<b>最多能连线</b>的个数。剩下不用说了，这其实就是最长公共子序列，<b>LCS问题</b>。

<hr>

1037 Valid Boomerang

题意：给定三个点，判断是否<b>不共线</b>。

难度：easy

解法：水题。

<hr>

1038 Binary Search Tree to Greater Sum Tree

题意：把一个BST转化为<b>“较大树”</b>。意思是，每个节点的值都变为<b>本身+所有大于它的值之和</b>。

难度：medium

解法：有个<b>土办法</b>，就是做<b>中序遍历</b>。把节点都<b>放到数组里</b>，进行后缀累加。

<hr>

1039 Minimum Score Triangulation of Polygon

题意：<b>多边形</b>的<b>三角剖分</b>是图形学里的一种基本操作。给定n个顶点的<b>凸多边形</b>，每个点有个分值`values[i]`。现在需要将其划分为n-2个三角形，每个三角形的点都从n个点选取，且不存在<b>交叉边</b>。对于每个三角形，分值按照<b>三顶点分值`values[i]`的乘积</b>计算。总分是所有三角的<b>分值之和</b>。请求出最小总分。

难度：medium

解法：如果不知道这个概念，从<b>几何上</b>确实挺难理解。最好<b>用草稿纸画一下</b>。其实这题难点在于<b>怎么划分子问题</b>。比如我选了ijk三个点，分<b>三种情况</b>讨论。比如ijk相邻，则剩余的i~k是<b>一个子问题</b>；比如ij相邻，k不相邻，则剩余的i~k、j~k是<b>两个子问题</b>；比如ijk都不相邻，则剩余的i~j、j~k、k~i是<b>三个子问题</b>。n变形，这相当于一个<b>环形数组</b>。因此你用dp[i][j]表示子问题时，要注意i<=j、i>j的情况，两者其实是<b>对称的</b>。剩下的DP细节就不说了。<b>有难度</b>的一题，需要一点<b>几何思维</b>才能搞明白。对于每个dp[i][j]，需要枚举中间的k得到最优解，因此总代价是<b>O(n^3)</b>。用<b>三层循环</b>或者<b>记忆化搜索</b>都可以。

<hr>

1040 Moving Stones Until Consecutive II

题意：1033的变体。这次有<b>n个石头</b>，其他规则完全相同。返回最大、最小移动次数。

难度：medium

解法：既然1033题已经做了，而且是个<b>智力题</b>，那这次尝试用<b>相同思维</b>。游戏结束的条件是，n个石头完全<b>挨在一起</b>。<b>最大次数</b>，还是按照每次距离-1，这个总是可以办到的，和1033一样。最小次数，则可以考虑枚举两个位置i、j，但i、j距离<b>至少应该是n-1</b>，这样才能<b>容纳n个石头</b>。剩下工作，就是把(i,j)范围之外的石头<b>都搬进来</b>了。<b>这题挺难的。</b>

<hr>

1041 Robot Bounded In Circle

题意：机器人开始在`(0,0)`位置，朝向+y方向。三种命令，G前进1格、L左转、R右转。如果给定一个<b>指令序列s</b>，机器人不断<b>重复执行</b>这个序列。请判断机器人的路径是否构成一个<b>环路</b>。

难度：medium

解法：其实是个<b>智力题</b>，很坑爹的那种。我们只执行一次s，如果发现<b>方向变了</b>，则<b>一定会循环</b>。<b>仔细想想</b>为什么。如果方向不变，则判断发生的总位移`(x,y)`是否为0，<b>不为0则不循环</b>。其实<b>循环的逻辑</b>不难想，如果你转了<b>180度</b>，`(+x,+y)`就变成了`(-x,-y)`，两次回原点；如果你转了<b>90度</b>，则依次按照`(+x,+y),(+y,-x),(-x,-y),(-y,+x)`，四次回原点。总之，一定会循环的。

<hr>

1042 Flower Planting With No Adjacent

题意：n个节点的<b>无向图</b>，存在一些边`[x,y]`。已知每个点的度数不超过3。你可以用4种颜色给n个点着色，使得任意<b>两个相邻的点</b>不同色。请返回一种有效的<b>着色方案</b>。

难度：medium

解法：这就是著名的<b>四色定理</b>，讲的是地图上相邻的地块，最多用四种颜色就可以保证相邻颜色不冲突了。当然，<b>证明四色定理</b>曾经是一个<b>世界级难题</b>，但给出一个着色方案不算很难。直接<b>搜索+回溯</b>即可。因为颜色总数为4，且每个点的度数不超过3，即使失败了，<b>回溯的代价</b>也<b>不会很大</b>。看来这题曾经的难度是easy，后来改medium了。<b>这肯定不是easy。</b>

<hr>

1043 Partition Array for Maximum Sum

题意：给定数组arr，请将其划分为长度至多为k的子数组。定义每个子数组的得分为`max(sub)*len(sub)`，也就是<b>最大值乘以长度</b>。请求出<b>子数组得分总和的最大值</b>。

难度：medium

解法：DP的思路还是很容易看出的。对于arr[0:i+1]，我可以看看划分出几段。比如我从arr[j:i+1]划分一段，当然这个长度不能超过k。那么`dp[i]=max(dp[j]+max(arr[j:i+1])*(i-j+1))`。这样的话，总代价O(n^2)，答案就是`dp[n-1]`。在这里面，求`max(arr[j:i+1])`的操作，也可以通过<b>预计算</b>来提高效率，<b>预计算代价`O(n^2)`</b>，之后O(1)可查。

<hr>

1046 Last Stone Weight

题意：有n个石头，大小用`stones[i]`表示。每次选出最大的两个石头x、y。如果`x!=y`，则碰撞后剩余石头`|x-y|`；如果相等，则两个石头都消失。请求出<b>最终剩余石头</b>的大小。

难度：easy

解法：<b>最大堆</b>，每次取出两个元素。

<hr>

1047 Remove All Adjacent Duplicates In String

题意：给定字符串s，如果其中存在两个<b>相邻的相等字符</b>`s[i]==s[i+1]`，则<b>都移除</b>。持续移除，直到没有相邻的相等字符为止，返回最终结果。

难度：easy

解法：用<b>栈</b>。

<hr>

1048 Longest String Chain

题意：给定一个词表words，请从中选出一些词`w[i]`，使得每个`w[i]`都是`w[i+1]`的子序列，称为一个<b>“词链”</b>。请求出词链的<b>最大长度</b>。

难度：medium

解法：题目定义了一个predecessor概念，其实就是<b>子序列</b>。首先应该按<b>长度降序</b>进行排序。从0位置开始，定义`dp[i]`为以<b>i位置开始</b>的<b>最长词链长度</b>。则枚举`j=0~i-1`，如果`words[j]`是`words[i]`的子序列，则`dp[i]=max(dp[i],dp[j]+1)`，必须<b>按长度排序</b>，这个枚举方式才有效。看了下当年的代码，<b>写法略有不同</b>，但思路差不多。

<hr>

1049 Last Stone Weight II

题意：1046的变体。这次可以<b>任选两个石头碰撞</b>，不用选最大的两个。这次希望最后剩下的石头最小，或者全部消失。请求出最终剩下的<b>最小石头</b>的尺寸。

难度：medium

解法：想了下，<b>没什么好思路</b>。也不能<b>暴力搜</b>吧？其实有个思路，比如l<b>两个石头</b>`x>y`，碰撞后剩下的是`x-y`。如果我有<b>两堆石头</b>，<b>总量</b>分别是x和y呢？其实<b>可以证明</b>，碰撞后剩下的碎石头，总量也是`x-y`。明白这点，就可以转化为<b>01背包问题</b>了。怎么才能让最终剩余的石头最少？我将石头分为两堆，使得两堆的差值最小即可。因此，对于总和sum，我可以用<b>01背包</b>的解法，求出我能得到的最接近`sum/2`的值。剩下不说了。

<hr>

1051 Height Checker

题意：给定数组a，请比较`a`和`sorted(a)`<b>值不相等</b>的位置个数。

难度：easy

解法：水题。

<hr>

1052 Grumpy Bookstore Owner

题意：给定n分钟，每分钟有`customers[i]`个客人进店。grumpy[i]表示第i分钟的<b>怒气值</b>，0则表示客人<b>满意</b>，1不满意。如果允许你选择其中的<b>连续k分钟</b>，让怒气保持0。请求出最大的<b>满意客人个数</b>。

难度：medium

解法：题目讲得挺复杂，其实只考虑这k分钟就行。首先，我们对<b>所有`grumpy[i]==0`的位置</b>，求customers[i]之和，这个作为一个固定值。然后考虑所有长度为k个窗口，计算每个窗口里，因`grumpy[i]==1`而损失的客人。这个窗口是<b>滑动窗口</b>，且窗口大小<b>固定是k</b>，因此计算很容易，用<b>前缀和相减</b>即可。求出所有窗口中，<b>损失最大</b>的一个。我们挽回这个<b>最大损失</b>，就可以使<b>最多的顾客</b>满意了。总代价<b>O(n)</b>。

<hr>

1053 Previous Permutation With One Swap

题意：给定可能有重复元素的数组arr，请通过<b>一次交换</b>，得到字典序小于arr的最大数组。如果不存在，则返回原数组。

难度：medium

解法：一次交换，要求<b>largest smaller</b>。那么我们应该把交换尽量放在尾巴上。我们看个例子，`[1,6,3,5,7]`，那么357已经顺序，不可能更小，因此我<b>需要交换6</b>。6和谁换？应该和467里，<b>小于6且最大</b>的换，因此是`[1,5,3,6,7]`。总结思路，找出<b>第一个逆序元素</b>`a[i]>a[i+1]`，再从`[i+1,n-1]`里，找出<b>最后一个j</b>，使得`a[j]<a[i]`，交换`(a[i],a[j])`就是答案。总代价<b>O(n)</b>。

<hr>

1054 Distant Barcodes

题意：给定数组arr，请重排顺序，使得任意相邻元素都不相等。

难度：medium

解法：对元素进行计数，得到`(个数,值)`的统计。将统计放入一个<b>最大堆</b>，每次取出<b>个数最多</b>的元素，<b>拿走1个，设置cd=1</b>，cd过了才能重新放入堆中。实际上游戏里的<b>cd机制</b>就是这么实现的，用一个<b>冷却队列</b>，配合<b>计时机制</b>。不用<b>最大堆</b>的话，也可以用<b>哈希表+排序</b>实现，但方式更复杂，且难想。还是用<b>堆</b>吧。

<hr>

1055 Shortest Way to Form String

题意：给定字符串s和t，请从s中选出<b>最少的子序列</b>，使得这些<b>子序列相连</b>等于t。

难度：medium

解法：付费题。DP思路很容易想，不细说了。但这题是<b>贪心还是DP</b>？其实是<b>贪心</b>。比如`t[i:j]`是s的子序列，`t[i:j+1]`不是子序列。那我选`t[i:j]`就是按照<b>尽可能长</b>的原则。但如果我故意选`t[i:j-1]`，舍弃最后一个字符，我能得到<b>更优解</b>吗？答案是<b>不能</b>。对于下一段匹配，你<b>刚才舍弃的字符</b>，至多这次能用上，也可能用不上。用上了，你得到<b>相同的解</b>；用不上，你只能得到<b>更差的解</b>。因此，贪心思路是<b>最优的</b>。按照每次<b>尽可能多匹配</b>的原则，扫描t串即可。总代价`O(nt*ns)`，平均代价则<b>很接近`O(nt+ns)`</b>。

<hr>

1056 Confusing Number

题意：给定一个整数，如果旋转180度后，变为一个<b>不同但依然合法</b>的数，称为<b>“迷惑数”</b>。请判断给定数n是不是迷惑数。

难度：easy

解法：付费题。处理`16890`的情况即可，`25`不算，虽然在<b>七段数码管</b>里，25旋转也有效。

<hr>

1057 Campus Bikes

题意：二维平面上，有n个工人和m个自行车。我们按照`(工人-车的距离,工人编号,自行车编号)`的升序，给工人分配自行车。请返回长度n的数组，表示<b>第i个工人</b>分到的<b>自行车编号</b>。

难度：medium

解法：付费题。要注意，不是从0~n-1号工人依次分自行车，而是从<b>所有配对里</b>，找<b>距离最小</b>的。因此，理论上你需要从O(n*m)个组合里找。暴力解法，就是直接<b>枚举所有组合</b>，按给定的优先级进行<b>排序</b>。按这题的数据量，其实<b>这样就过了</b>。如果想<b>优化</b>，可以额外做一些<b>排序过滤</b>，提前筛选掉很多<b>无用的配对</b>。

<hr>

1058 Minimize Rounding Error to Meet Target

题意：给定一些浮点数prices，你可以对每个值取`floor`或者`ceil`。请问能否得到总和`target`？如果可以，请返回最小的<b>总舍入误差</b>。否则返回“-1”。

难度：medium

解法：对于floor和ceil，差值至多是1。因此，可以把所有元素都变为<b>“0或1”</b>这样处理，减掉一个<b>`floor(x)`的偏移量</b>。如果减去之后，target不在`[0,n]`范围内，则<b>无解</b>。难点在于求出<b>“总舍入误差”</b>，而且要求<b>最小</b>。因此，需要对<b>舍入部分做排序</b>。<b>靠近1</b>的取ceil，<b>靠近0</b>的取floor，这样总舍入误差就是最小的。这题还挺难，<b>思路不太好想</b>。

<hr>

1059 All Paths from Source Lead to Destination

题意：给定有向图和起点终点src、dst，请判断从src发出的路径，无论怎么走，最终<b>一定会停在dst</b>。

难度：medium

解法：付费题。意思就是<b>条条大路同罗马</b>。这个条件很严格，要求src和dst需要连通，且从src<b>可达的点</b>里，出度为0的只有dst一个。而且，<b>不能有环</b>。可以用<b>DFS或者拓扑排序</b>处理，建议DFS。执行DFS时，记录路径，如果路径里有<b>重复节点</b>，则表示有环。如果路径里的点已经在<b>其他路径</b>访问过了，也可以跳过。判断一下<b>出度为0的末端点</b>是否只有dst。

<hr>

1060 Missing Element in Sorted Array

题意：给定有序数组nums，从nums[0]开始，一直+1。请找出<b>第k个</b>缺失的值。比如`[4,7,9,10]`，则<b>第3个缺失值是8</b>，5、6、8。

难度：medium

解法：付费题。显然，O(n)的解法很直白，往下<b>数数</b>就行。那么如何<b>二分</b>呢？我们看看每个相邻元素`(nums[i],nums[i+1])`之间，<b>缺失了多少值</b>。得到一个缺失个数`miss_count`的统计，对这个做<b>前缀和</b>得到`miss_sm`。然后对这个`miss_sm`做二分搜索就行了，剩下不说了。实际写法更简单，直接用`a[mm]-a[ll]`就行了。

<hr>

1061 Lexicographically Smallest Equivalent String

题意：给定s1、s2等长字符串，其中`s1[i]-s2[i]`表示两个字符的等价关系，比如`a-b`表示ab等价。已知等价关系是对称、传递的，即`ab等价且bc等价->ac等价且ca等价`。给定s1、s2定义的等价关系，和一个字符串baseStr，请对baseStr做等价变换，得到<b>字典序最小</b>的结果。返回这个结果。

难度：medium

解法：题目是真的绕嘴，<b>完全不知所云</b>。其实看明白后，很容易想到<b>等价类、无向图连通分量</b>，因此用<b>并查集</b>。对于baseStr的<b>每个字符c</b>，都找出<b>和c等价的所有字符</b>中，<b>最小的一个</b>。所有字符都变为最小，总结果就是<b>字典序最小</b>。

<hr>

1062 Longest Repeating Substring

题意：给定字符串s，请找出其中最长的子串ss，使得ss在s中至少出现两次。位置可以<b>重叠</b>。

难度：medium

解法：付费题。直接<b>枚举i、j两个位置</b>进行匹配，看能匹配多长。总代价`O(n^2)`。

<hr>

1063 Number of Valid Subarrays

题意：给定数组nums，请求出符合条件的<b>子数组个数</b>，要求子数组的<b>0号元素是最小值</b>。

难度：hard

解法：付费题。我们考虑`nums[i]`，i位置往前<b>延伸多长</b>，`nums[i]`能保持最小值？那么直白的解法就是`O(n^2)`的枚举了。因此最优解必须是`O(n)`的。看例子，`[1,4,2,5,3]`，我用一个<b>递增的单调栈</b>。栈的变化情况是`[1]->[1,4]->[1,2]->[1,2,5]->[1,2,3]`。想想<b>4出栈的时候</b>，发生了什么？4遇到了2，因此<b>4不再是最小值</b>了，就出栈了，4对应的<b>边界</b>就找到了。比如<b>i元素的边界是j</b>，也就是说`i<j,nums[i]>nums[j]`（也可能`j==n`，出界了）。那么i元素总共对应了<b>`j-i`个子数组</b>。累加起来，总代价`O(n)`。

<hr>

1064 Fixed Point

题意：给定有序且无重复值的数组A，请找出第一个满足`A[i]=i`的位置i。如果不存在则返回-1。

难度：easy

解法：付费题。<b>二分搜索。</b>

<hr>

1065 Index Pairs of a String

题意：给定文本text和词表words，请找出所有`(i,j)`位置，使得`text[i:j+1]`是词表中的词。

难度：easy

解法：付费题。<b>暴力匹配</b>就行了。

<hr>

1066 Campus Bikes II

题意：1057的变体。这次分配自行车的目标，改为所有`工人-自行车`的<b>距离总和</b>最小。

难度：medium

解法：付费题。乍一想，应该很难。看数据范围<b>`<=10`</b>，说明确实很难。那就<b>暴力搜</b>？虽然是暴力搜，因为数据只有10，可以用<b>位压缩</b>提高效率，用`1<<nb-1`的掩码来表示<b>哪些自行车已经被分配</b>。除此之外，没什么特别技巧了。

<hr>

1071 Greatest Common Divisor of Strings

题意：给定字符串s和t，如果`s=t重复n次`，则称t是s的<b>“约数”</b>。现在给定s1、s2，请求出<b>“最大公约数”</b>，如果不存在则返回“”。

难度：easy

解法：题目难度既然是easy，那就可以<b>暴力匹配</b>了。对于每个串，找出最短的循环节t1、t2。因为是<b>最短循环节</b>，如果`t1!=t2`，则这个公约数<b>一定不存在</b>。如果相等，则考虑n1和n2的最大公约数。最终结果就是`t*gcd(n1,n2)`。对于<b>最短循环节</b>，高效的匹配算法是<b>KMP算法</b>。不想手写KMP的话，直接用`re.match`做暴力匹配就行了。

<hr>

1072 Flip Columns For Maximum Number of Equal Rows

题意：给定m x n的01矩阵，你可以任意选择某列，<b>反转整列的值</b>。请求出能得到的<b>整行值全0或全1</b>的最大行数。

难度：medium

解法：我们先假定某个第i1行变成全1了，这时<b>恰好某个i2行</b>也是全1。我在反转1列时，所有值都一起变，这代表i1行和i2行在任何时刻，都<b>长得一模一样</b>。因此，对于一个01串s，我用`1-s`表示取反结果。则当s变成全1，`1-s`也就成了全0。因此，我可以用<b>哈希表</b>，统计<b>每行的01字符串</b>的个数。比如`00101`有3个，`11010`有2个，那么我经过一些反转，就可以得到3个`11111`和2个`00000`，共5个。思路总结，就是`max(mm[s]+mm[inverse(s)])`。总代价<b>O(m*n)</b>。python是支持<b>大数运算</b>的，你甚至不需要字符串，直接<b>位操作</b>就行了。

<hr>

1073 Adding Two Negabinary Numbers

题意：给定两个-2进制的大数arr1、arr2，最高位在左边。请做<b>加法</b>。

难度：medium

解法：首先<b>反转一下</b>，最低位放左边。`1+1=2`，进位的话，`2*(-2)^k=-(-2)^(k+1)=(-2)^(k+2)+(-2)^(k+1)`，就按这个逻辑处理。当然还有一种<b>偷懒的办法</b>，就是转成10进制，再转回-2进制。对于python当然方便，因为<b>大数运算</b>是内部支持的。其他语言就不一定了。

<hr>

1074 Number of Submatrices That Sum to Target

题意：给定m x n矩阵和一个值target。请统计<b>子矩阵和</b>为target的个数。

难度：hard

解法：枚举子矩阵和，我们如果枚举<b>左上、右下</b>两个角，用<b>前缀和</b>的方式计算，总代价就是<b>O(n^4)</b>。难度hard，当然<b>不会这么简单</b>。因此，要优化。那么，我们枚举<b>行维度i1、i2</b>，这是O(n^2)，得到的就是一个<b>一维数组</b>。求一个数组里，<b>子数组和</b>为target的个数，这个<b>O(n)时间搞定</b>，会做吧？剩下不说了。所有这题关键，就是<b>问题转化的能力</b>。总代价<b>O(n^3)</b>。

<hr>

1078 Occurrences After Bigram

题意：给定一个句子和<b>a、b两个词</b>，如果句子中某词c按照<b>a、b、c</b>连续出现，返回所有这样的词c。

难度：easy

解法：水题。

<hr>

1079 Letter Tile Possibilities

题意：给定一些积木，积木上有字母`tiles[i]`。请求出用这些积木，能拼出的不同序列。可以<b>选部分或者全部，顺序任意</b>。

难度：medium

解法：显然，这个组合数<b>非常非常多</b>。数据稍微一大就<b>炸了</b>，因此给定的规模很小，直接<b>暴力搜</b>吧。很奇怪，我以前为什么写了个<b>这么麻烦的解法</b>。

<hr>

1080 Insufficient Nodes in Root to Leaf Paths

题意：给定二叉树，我们统计所有根到叶的路径。如果对于某节点p，所有<b>经过它的路径</b>，总和都小于limit，则称这个节点p<b>“不足”</b>。请<b>删除</b>所有不足的节点，返回修改后的二叉树。

难度：medium

解法：反过来，如果某条路径的`总和>=limit`，则路径上所有点都是<b>充足</b>的。那么我们可以递归一次，标记出所有的<b>充足点</b>。然后再递归一次，<b>从上到下</b>删除不足点。删除某点p，就等于<b>删除p的整个子树</b>。当然，这个思路也可以<b>一次递归完成</b>。

<hr>

1081 Smallest Subsequence of Distinct Characters

题意：给定字符串s，请找出一个<b>字典序最小</b>的子序列ss，使得ss包含了<b>s中的所有唯一值</b>，且<b>ss无重复字符</b>。

难度：medium

解法：三个要求：字典序最小、包含s的所有值、无重复值。对于26个字母，ss的最大长度也就26。那么我们不用想得很复杂。对应s的每个字符，我们总是比较当前字符如果<b>替换进去</b>，能否得到<b>字典序更小</b>的结果。能，我就放进去。比如`cbacdcbc`，依次判断的结果是`c->cb->cba->bac->bacd->acdb`，其中有两处没有替换，因为替换之后<b>字典序会变大</b>。匹配的总代价是<b>O(n*26)</b>，也等于O(n)。看了下我以前的代码，和上面这个思路<b>不一样</b>。

<hr>

1085 Sum of Digits in the Minimum Number

题意：给定数组nums，判断<b>最小元素</b>的<b>数位之和</b>是否为<b>奇数</b>。

难度：easy

解法：付费题。一句话给了<b>3个要素</b>，真简洁。

<hr>

1086 High Five

题意：给定一些`(学生ID,分数)`的记录，请返回每个学生<b>前5高</b>的分数的<b>均值</b>，按<b>ID升序</b>排列。

难度：easy

解法：付费题。题目很清晰，按要求实现即可。

<hr>

1087 Brace Expansion

题意：给定一种<b>语法</b>，对序列进行展开。用`{a,b}`表示一个含有a、b的集合，用`{a,b}{c,d}`表示ab集和cd集的<b>笛卡尔积</b>，结果为`["ac","ad","bc","bd"]`。给定一个序列，请按语法规则进行<b>展开</b>。给定序列不包含<b>嵌套括号</b>，结果按字典序升序排列。

难度：medium

解法：付费题。既然不包含<b>嵌套括号</b>，那问题就简单点。字符串处理+求笛卡尔积，形式上可以写一个DFS函数，用<b>搜索的思路</b>去做。

<hr>

1089 Duplicate Zeros

题意：给定数组nums，请将其中的0值复制一遍。比如`00`，则变成`0000`。非零元素需要按顺序后移，如果<b>位置不够，则丢弃</b>。请<b>就地修改</b>数组，不返回任何值。

难度：easy

解法：因为要移动非零元素，我们可以先<b>从前往后</b>，统计0的个数。这样就可以确定<b>偏移量</b>了。再<b>从后往前</b>，按偏移量，<b>`>n-1`位置</b>的元素丢掉。<b>在界内</b>的元素，依次填进去。

<hr>

1090 Largest Values From Labels

题意：有n件物品，各有类型`lables[i]`和价值`values[i]`。你需要从中选出<b>至多</b>`numWanted`件，且<b>同类型</b>不能超过`useLimit`件。请求出得到的<b>最大价值总和</b>。

难度：medium

解法：<b>看着很难，其实不难。</b>首先，我肯定应该选够`numWanted件`，<b>没理由少拿</b>。然后，<b>贪心还是DP？</b>应该是<b>贪心的</b>。我直接按`values`降序排列，<b>尽量拿大的</b>。同时，保证遵守`useLimit`的限制即可。

<hr>

1091 Shortest Path in Binary Matrix

题意：给定n x n的01矩阵。请找出一条<b>全0的8邻接</b>路径，从`(0,0)`出发到达`(n-1,n-1)`。

难度：medium

解法：最短路径，这好像直接<b>BFS</b>就行了。按照<b>0格子、8邻接</b>的要求，搜吧。如果希望快一点，还可以<b>双向BFS</b>。这题<b>单向BFS足够了</b>。

<hr>

1093 Statistics from a Large Sample

题意：给定一个`[0,255]`范围的抽样。值范围不大，但是<b>抽样个数非常多</b>。现在给定统计结果`count[i]`表示<b>i值的个数</b>。请求出min、max、mean、median、mode。<b>mode是众数</b>。

难度：medium

解法：这题出得很好，<b>统计学是个好东西</b>。min、max、mean、mode都不说了，很简单。中位数median，可以用`count[i]`计算<b>累加和</b>，看看<b>中间</b>落在<b>哪个值i</b>上。注意<b>特殊情况</b>，如果中间值恰好在<b>`i`、`i+1`的边界</b>，那就是`i+0.5`。

<hr>

1094 Car Pooling

题意：在数轴上，所有位置的<b>初始值为0</b>。给定一些区间`[x,y,val]`和一个capacity值，表示<b>给每个[x,y]区间+val</b>。如果给定的区间可能存在重叠，请判断是否存在某个区间的值<b>超过了capacity</b>。

难度：medium

解法：题目说的拼车问题，转成<b>数学模型</b>，就是<>如上所述。区间+val，这个可以转化成`[0,x-1,-val]`和`[0,y,+val]`两个操作。因此，你可以用<b>后缀和</b>处理，也可以用<b>树状数组</b>处理。x、y的<b>数据范围不超过1000</b>，因此建议用后缀和的方式，<b>简单易实现</b>。

<hr>

1096 Brace Expansion II

题意：1087的变体。给定一种<b>语法</b>，对序列进行展开。用`{a,b}`表示一个含有a、b的集合，用`{a,b}{c,d}`表示ab集和cd集的<b>笛卡尔积</b>，结果为`["ac","ad","bc","bd"]`。如果集合只有一个元素，<b>可以省略“{}”</b>现在给定一个这样的序列，请按如上规则，进行<b>递归展开</b>，返回最终结果。

难度：hard

解法：题目本身倒是定义明确，也没什么特别动脑的地方。因此hard主要体现<b>麻烦</b>。<b>字符串处理+递归解析</b>即可，很费劲的一道<b>体力题</b>。注意对结果进行<b>去重和排序</b>。

<hr>

1099 Two Sum Less Than K

题意：给定数组A和值k，请求出`i<j,A[i]+A[j]`能得到的最大值s，且`s<k`。返回s，如果不存在，则返回-1。

难度：easy

解法：付费题。排序之后，双指针从`i=0,j=n-1`向中间靠拢。排序代价为主，因此总代价`O(nlogn)`。

<hr>

1100 Find K-Length Substrings With No Repeated Characters

题意：给定字符串s，请统计长度为k，且没有重复字符的子串个数。

难度：medium

解法：付费题。这个滑动窗口的<b>大小是固定的</b>，因此非常简单。<b>滑动+统计</b>，看看<b>唯一值个数是否为k</b>就行了。

## 1101 - 1200

1101 The Earliest Moment When Everyone Become Friends

题意：n个人，编号`0~n-1`，给定一些日志logs，格式为`[t,x,y]`，表示x和y在t时刻交朋友。如果x、y通过任意个人<b>间接认识</b>，也算认识。请问<b>最早在什么时刻</b>，所有人都认识了？

难度：medium

解法：付费题。很明显，<b>并查集</b>。

<hr>

1102 Path With Maximum Minimum Value

题意：给定m x n矩阵A，请求出一条从`(0,0)`到`(m-1,n-1)`的路径，可以<b>上下左右</b>走。要求路径经过格子的<b>最小值最大</b>。

难度：medium

解法：付费题。能上下左右，你可能会考虑<b>“回头路”</b>的问题。其实无所谓，你知道这题肯定要搜，问题是<b>怎么搜</b>？答案是BFS，而且用<b>最小堆</b>。最小堆这个思路还有点难想。如果用<b>纯粹的BFS</b>，因为涉及大量<b>无效搜索</b>，效率上不可接受。

<hr>

1103 Distribute Candies to People

题意：你有c个糖果分给n个人。按照`1,2,3...,n,n+1,n+2,...`这样，从1~n人分配，每满n人，回到第1人继续发，直到发完。请返回每个人拿到的糖果数。

难度：easy

解法：水题。用算数技巧算一下。

<hr>

1104 Path In Zigzag Labelled Binary Tree

题意：有一棵无限层的<b>满二叉树</b>。从根节点开始，依次按照<b>左右左右交替顺序</b>遍历每层，依次编号为`1,2,3,...`。现在给定对应<b>序号label</b>。请返回从根到该节点的<b>路径序号</b>。

难度：medium

解法：虽然每层顺序反了一下，但个数是固定的，因为满二叉树的每一层个数都是`2^k`。那么<b>先求出label对应的节点</b>，再根据节点确定每走一步到哪儿，对应位置的序号是什么就行了。<b>用嘴说不清楚</b>，在草稿纸上<b>画一下，列出公式</b>并不难。

<hr>

1105 Filling Bookcase Shelves

题意：你有n本书，你可以<b>依次</b>，按照从左到右、从下到上的顺序，摆成一层层的。不能调整<b>书的顺序</b>，依次。给定每本书的<b>厚度、高度`(th_i,h_i)`</b>，和每层的总宽度`shelfWidth`，要求每层书的厚度不能超过总宽度，超过了需要新加一层。每层的高度则按照`max(h)`处理。请求出最终得到的<b>总高度的最小值</b>。

难度：medium

解法：题目描述<b>相当费解</b>，没有配图的话，完全无法理解<b>到底在问什么</b>。转化为数学模型，其实相当于把`[th,h]`数组<b>划分为几个子数组</b>，要求`sum(th)<=shelfWidth`，目标是`min(sum(max(h)))`。<b>啥玩儿，确实够复杂。</b>我能想出一个`O(n^2)`的<b>DP思路</b>。用`dp[i]`表示`[0:i+1]`段的最优解。则枚举[j+1:i+1]这段作为<b>一层</b>，首先判断能否装进一层`sum(th[j+1:i+1])<=shelfWidth`，再求`dp[j]+max(h[j+1:i+1])`。因此`dp[i]=min(dp[j]+max(h[j+1:i+1]))`。这其中的某些计算，比如`sum、max`都可以通过<b>预计算</b>来加速，这样总代价能控制在O(n^2)。

<hr>

1106 Parsing A Boolean Expression

题意：给定布尔表达式，请进行解析求值。要求支持`tf`作为基本值，运算包括`! & | ()`这几种。

难度：hard

解法：难度是hard，其实没有算法上的难度，就是<b>字符串解析+运算处理</b>了。并没有特别<b>复杂或者坑人</b>的情况。对于单目、二目、三目甚至n目运算符，应该设计出一套统一的<b>文法机制</b>去处理，以免代码写得case by case过于冗长。括号是<b>改变优先级</b>的，肯定要特殊处理。

<hr>

1108 Defanging an IP Address

题意：对于IP地址，把“.”替换为“[.]”。

难度：easy

解法：水题。<b>defang</b>的意思是<b>拔牙</b>，fang是尖牙。IP defang是指的对IP地址做<b>无效化处理</b>。

<hr>

1109 Corporate Flight Bookings

题意：给定区间`[1,n]`，初始值都是0。每次对区间`[x,y]+val`。经过若干次操作，请求出每个位置的值。

难度：medium

解法：题目本身的一些“航班”、“座位”之类的就不说了。<b>区间修改，单查</b>。这是典型的<b>树状数组</b>应用，但因为是<b>批处理问题</b>，不需要树状数组，直接做<b>后缀累加</b>即可。总代价O(n)。

<hr>

1110 Delete Nodes And Return Forest

题意：给定二叉树，请删除所有值为val的节点。因为操作可能生成多棵树，请返回得到的<b>树林</b>。树的所有节点<b>没有重复值</b>。

难度：medium

解法：题目本身并不难，<b>递归执行</b>。记录好<b>父节点</b>，以便更新指针。比如当前节点r需要删除，那就把父节点的对应child位置<b>置空</b>，同时继续往下搜。返回的<b>所有树</b>，要汇总到一起。其实就算有<b>重复值</b>，思路也是一样。

<hr>

1111 Maximum Nesting Depth of Two Valid Parentheses Strings

题意：括号序列，规则就不说了。我们定义括号序列的深度为"()"嵌套的<b>最大层数</b>。如果序列`A+B`，则按`max(d(A),d(B))`处理。空串的深度为0，`d((A))=d(A)+1`。现在给定一个序列S，请将其划分为两个子序列A、B，使得max(d(A),d(B))最小。注意，是<b>子序列</b>，不是子串。

难度：medium

解法：是<b>子序列</b>，不是子串。那么问题就是，对于每个s[i]，应该分配给A还是B？看数据范围，`O(n^2)`的DP思路应该不行，而且我也想不出来。那么<b>贪心</b>行不行？给定已有的A、B序列，分别用栈模拟，称为sa、sb。首先，我可以处理整个s，看下整个序列的<b>最大深度</b>是多少，命名为`max_cnt`。其实，你只要保证`cnt`不超过`max_cnt/2`就行了，<b>想想为什么</b>。就这个，<b>贪心</b>。不超过，给A；超过了，给B。

<hr>

1118 Number of Days in a Month

题意：给定年Y月M，请求出这个月有几天。

难度：easy

解法：付费题。判断<b>闰年</b>即可。

<hr>

1119 Remove Vowels from a String

题意：给定字符串，请删除其中的<b>aeiou</b>。

难度：easy

解法：付费题。水题。

<hr>

1120 Maximum Average Subtree

题意：给定二叉树，请求出所有子树中，<b>平均值的最大值</b>。

难度：medium

解法：付费题。思路很明确，递归<b>求和+计数</b>，用`sum/count`就是平均值。用<b>后序遍历</b>。

<hr>

1122 Relative Sort Array

题意：给定数组a1、a2，a2没有重复值。对a1中的值x，如果x在a2中，则按a2元素顺序排列；如果不在a2中，则升序排列并放到a1末尾。

难度：easy

解法：付费题。水题，要求繁琐且无聊。用<b>哈希表+排序</b>解决。

<hr>

1123 Lowest Common Ancestor of Deepest Leaves

题意：给定二叉树，请找出它的所有<b>最深叶节点</b>的<b>最近公共祖先</b>。

难度：medium

解法：不用去考虑<b>LCA问题</b>的专门解法。这个用<b>后序遍历，递归处理</b>就行。比如<b>当前节点r</b>，我考虑r对应子树的<b>叶节点最大深度d(r)</b>。那么，如果`d(r.left)==d(r.right)==max_d`，则答案可能是r，但<b>还需要往上找</b>，因为别处也可能有同样深度的子树。这个`max_d`可以单独遍历一次得出。随着往上找，同时更新答案。因为是后序遍历，<b>最终答案</b>肯定是某个<b>深度最小的点r</b>，满足上面那个式子。因为它必须<b>足够靠上</b>，才能覆盖到所有的<b>最深叶节点</b>。

<hr>

1128 Number of Equivalent Domino Pairs

题意：一个积木，尺寸为a x b。已知<b>a x b和b x a等价</b>，可以转一下。给定一些积木，请求出<b>等价的对数</b>。

难度：easy

解法：水题。

<hr>

1129 Shortest Path with Alternating Colors

题意：给定有向图，可能存在自环、多重边。图里存在红边、蓝边两种颜色，从0出发，请求出到所有点的<b>最短路径长度</b>，但是要求路径必须<b>红蓝交替或者蓝红交替</b>。如果不可达，则返回-1。

难度：medium

解法：虽然有自环、多重边，还有红蓝颜色要求，毕竟所有边都是长度1，这对于<b>常规的BFS</b>来说没什么区别。注意搜索时按照<b>颜色交替</b>即可。

<hr>

1130 Minimum Cost Tree From Leaf Values

题意：一棵二叉树，它的所有非叶结点，都是`左子树最大叶*右子树最大叶`，<b>乘积</b>。如果已知中序遍历里，所有叶子值是数组arr，请求出<b>非叶节点</b>的<b>最小和</b>。

难度：medium

解法：题目描述太复杂了，看得头晕。其实，所谓的<b>“二叉树”</b>完全是<b>烟雾弹，迷惑你的</b>。直接按照`dp[left]`、`dp[right]`去针对arr数组进行<b>子问题划分</b>，而且很容易看出这是个<b>DP问题</b>。这样，你根本不用考虑二叉树的事情，会发现也不算很难。细节就不说了。针对`dp[i][j]`，枚举中间的k，总代价`O(n^3)`。

<hr>

1131 Maximum of Absolute Value Expression

题意：给定同长度的数组a1、a2，任选(i,j)位置，请求出`|a1[i]-a2[j]|+|a2[i]-a1[j]|+|i-j|`的最大值。

难度：medium

解法：显然题目希望你用低于`O(n^2)`的代价解决。没想出好思路，看了下当年代码，<b>当年也没想出来</b>。网友的思路给人的感觉就是<b>实在巧妙</b>。为了处理<b>绝对值</b>问题，可以通过枚举两个<b>绝对值</b>展开之后的<b>正负号</b>，这样共有`2*2=4`种组合。还要对这个式子做一下拆分，把i项归到一起，j项归到一起。总之，这个<b>神思路</b>我没法独立想出。当然，如果解决<b>某类问题</b>，必须用<b>某种思路</b>，那唯一办法就是<b>学会+记住</b>。

<hr>

1133 Largest Unique Number

题意：给定数组arr，求出其中只出现一次的最大值。

难度：easy

解法：付费题。水题。

<hr>

1134 Armstrong Number

题意：如果一个数n的所有<b>数位的立方</b>，加起来等于n，则称为<b>“Armstrong数”</b>。请判断给定n是否符合要求。

难度：easy

解法：付费题。水题。

<hr>

1135 Connecting Cities With Minimum Cost

题意：给定一些<b>双向边`[x,y,c]`</b>，表示连通x、y的代价为c。请求出连通所有边的<b>最小总代价</b>。

难度：medium

解法：付费题。题目翻译过来，就是<b>最小生成树</b>。因此，用<b>并查集，Kruskal算法</b>。

<hr>

1137 N-th Tribonacci Number

题意：有个序列，类似Fibonacci数列，但形式是`Tn=Tn-1+Tn-2+Tn-3`。给定初始值，请求出Tn。

难度：easy

解法：水题。

<hr>

1138 Alphabet Board Path

题意：26个字母，按照<b>从左到右、从上到下</b>，共5 x 5，加上一个z。现在给定一个字符串target。你可以执行“UDLR”移动，或者“!”选取当前字符。请给出一个执行序列，使得得到的字符串等于target，要求序列长度最短。

难度：medium

解法：这是个<b>模拟题</b>。从起点a开始，字符的<b>位置是确定的</b>，因此也不存在什么<b>“最短路”</b>，直接按顺序走就行了。一个个走，记录下<b>执行的序列</b>即可。唯一要注意的，是z。z的位置必须先经过u。

<hr>

1139 Largest 1-Bordered Square

题意：给定01矩阵，请求出一个最大的<b>正方形</b>，使得正方形<b>边缘都是1</b>。返回最大边长，如果不存在则返回0。

难度：medium

解法：对于每个点`grid[i][j]`，我都考虑上下左右的连续1有多少个。这个计算代价，在四个方向都是`O(n^2)`。然后我枚举左上、右下两个角，左上`O(n^2)`，右下`O(n)`，因为是<b>正方形</b>。左上在`(x,y)`，右下在`(x+d,y+d)`。然后我判断<b>左上向右向下，右下向左向上</b>的连续1的个数<b>够不够d个</b>就行了。对每一次枚举，判断代价都是`O(1)`。因此，总代价是`O(n^3)`。

<hr>

1140 Stone Game II

题意：877的变体。有n堆石头，每堆个数为`piles[i]`。两人轮流，每次可以拿`1<=X<=2M`堆石头，开始`M=1`。拿完之后，`M=max(M,X)`。拿完为止，问<b>先手是否必胜</b>。

难度：medium

解法：<b>一天到晚拿石头</b>，也是服了。肯定<b>DP</b>了，那么状态怎么定？比如我用`dp[i][j]`表示`[0:i+1]`堆，且最后一步拿了j堆的最优解。这样行吗？<b>不行。</b>因为你知道最后一步，但无法确定<b>第一步是谁拿的</b>，Alice还是Bob？即使求出结果，也<b>不知道属于谁</b>。因此需要反过来，用`dp[i][j]`表示`[i:n]`堆，且最后一步拿了j堆。这样的话，`dp[0][0]`就表示<b>初始状态</b>搜到最后的结果。这个逻辑<b>用循环有点难写</b>，建议<b>记忆化搜索</b>。当年好像直接<b>没做出来</b>，这次思路很快想到了。

<hr>

1143 Longest Common Subsequence

题意：最长公共子序列，<b>LCS问题</b>。

难度：medium

解法：没错，就是教科书的LCS问题。<b>DP</b>的最经典例子，总代价`O(n^2)`。

<hr>

1144 Decrease Elements To Make Array Zigzag

题意：给定数组nums，每次允许任选一个元素<b>-1</b>。请问至少多少次操作，能使数组变为<b>“大小大小”</b>或<b>“小大小大”</b>的交替形式。

难度：medium

解法：既然只有大小大小或者小大小大两种方式，那就<b>两种都试试</b>。比如abc三个元素，你可以把b变成`min(a,c)-1`，或者`max(a,c)+1`，这个操作是确定的，因此可以`O(1)`代价求出。这样，只需要两次`O(n)`代价的遍历，就能得到答案。你可能会想，对于abc，我能不能通过修改<b>两个元素</b>，而不是<b>只修改b</b>，得到更小的代价？答案是不能，也没必要，可以<b>想想为什么</b>。

<hr>

1145 Binary Tree Coloring Game

题意：给定n节点的二叉树，所有节点的值恰好是`1~n`，不重复。两人轮流给每个节点选值，要求各不相同。按照<b>红蓝红蓝</b>交替。除了第一次以外，之后选择的点，都必须和已涂色的点<b>相邻</b>。红找红，蓝找蓝。如果一方无法涂色，则<b>跳过</b>，如果双方无法涂色，则<b>结束</b>。请判断<b>后手是否必胜</b>。

难度：medium

解法：终于轮到<b>后手</b>了。既然要求选的点必须和之前相邻，这相当于是<b>洪泛</b>了，flooding。那比如先手<b>选了x</b>，x的子树有nx节点，则剩余部分有`n-nx`。则y可以选在x的父节点，如此的话，<b>剩余的`n-nx`都被y堵住</b>，因此也属于y了。所以，x不会选一个`nx<n-nx`的位置。那么x一定选根节点，y则选<b>左右子树</b>里<b>较大的一个</b>。那么，<b>如果左右子树一样大，y必输</b>。n是奇数，因此不可能平手。除了y必输的一种情况，其他的y必胜。因此，这题是个<b>坑爹智力题</b>。

<hr>

1146 Snapshot Array

题意：设计一个<b>数组</b>结构，支持类似快照功能。n元素，支持元素赋值，支持存储快照返回ID，支持获取特定`arr[i]`的对应`snap_id`的值。

难度：medium

解法：如果你要保证查询`O(1)`，那写入就很难做到`O(1)`。因为快照理论上应该<b>对所有元素都保存一份</b>，但这样<b>太浪费空间</b>。我们换种思维，只记录当前snap<b>修改了什么</b>。比如`snap_id=0`时，无事发生，那我什么都不记（当然，初始化时有0值，这个也算记录）。比如`snap_id=t`时，我把`arr[i]=x`，那我可以用`arr[i].append((t,x))`来表示这个修改。当我要查询快照记录时，则可以对`snap_id`进行二分搜索。这样能用`O(logn)`代价定位到<b>`<=snap_id`的最近记录</b>。修改代价为`O(1)`，查询代价为`O(logn)`，总体效率很好。

<hr>

1150 Check If a Number Is Majority Element in a Sorted Array

题意：给定有序数组nums，请判断某元素target是否为<b>众数</b>。

难度：easy

解法：付费题。可以二分搜索，用<b>bisect_left+bisect_right</b>快速找到边界，判断个数是否`>n/2`。

<hr>

1151 Minimum Swaps to Group All 1's Together

题意：给定01数组data，请求出最小的交换次数，使得所有1能<b>聚拢到一起</b>。

难度：medium

解法：付费题。很简单，统计1的个数，比如<b>总共k个</b>。那我就判断所有的k窗口里，<b>0个数的最小值</b>。这就是答案。

<hr>

1152 Analyze User Website Visit Pattern

题意：给定一些网站访问记录，按`(u,w,t)`格式，表示用户u在t时刻访问了w站。给定用户访问最多的<b>前3网站</b>，结果<b>升序</b>。如果存在多个则按<b>字典序升序</b>。

难度：medium

解法：付费题。题目描述很清晰，就是<b>排序</b>。tuple排序，结果也排序。

<hr>

1154 Day of the Year

题意：给定`YYYY-MM-DD`格式的日期，求出这是当年的第几天。

难度：easy

解法：也没什么技巧，按月份累加。

<hr>

1155 Number of Dice Rolls With Target Sum

题意：你有n个色子，每个是k面，也就是`1~k`。给定目标总和target，请求出摇n个色子，有<b>多少种结果</b>，加起来等于target。结果模`1e9+7`返回。

难度：medium

解法：<b>DP解法</b>，显然可以用`dp[i][j]`表示<b>i个色子和为j</b>的个数，剩下不说了。

<hr>

1156 Swap For Longest Repeated Character Substring

题意：给定字符串s，你可以选两个字符交换。请返回能得到的最长的<b>单值子串</b>长度。

难度：medium

解法：<b>滑动窗口</b>可以做，但又好像不是很方便。也可以统计<b>每个连续段</b>的字符个数，如果存在中间有个<b>单字符</b>的情况，尝试交换。总之，<b>题目不难</b>，但不论用什么办法都<b>有点点麻烦</b>。

<hr>

1160 Find Words That Can Be Formed by Characters

题意：给定字符chars和词表words。如果words中的词可以通过chars字符拼出（不能重复使用字符），则称为<b>好词</b>。请统计所有好词的长度之和。

难度：easy

解法：水题。哈希统计即可。

<hr>

1161 Maximum Level Sum of a Binary Tree

题意：给定二叉树，定义根节点<b>深度为1</b>，依次往下+1。对每层的节点求和，请返回单层总和最大的<b>对应层数x</b>。

难度：medium

解法：遍历求和即可，注意返回的是<b>层数</b>，不是总和。

<hr>

1162 As Far from Land as Possible

题意：给定n x n地形，0陆1水。请找出一个水格子，使其到达<b>最近的陆地最远</b>。返回对应距离，如果不存在则返回-1。

难度：medium

解法：不要从水格子去搜陆地，以<b>所有陆地格子</b>作为种子，<b>执行BFS</b>，去找水。

<hr>

1165 Single-Row Keyboard

题意：给定一个单排键盘，26个字母都在一排。从i移动到j，代价是`|i-j|`。开始你在0位置，请问给定单词word，移动手指的<b>代价总和</b>是多少？

难度：easy

解法：付费题。水题。

<hr>

1166 Design File System

题意：请设计一个建议的文件系统，处理<b>目录层次</b>。支持创建目录，并赋值；支持查询目录返回值，不存在则返回-1。创建目录需要保证<b>父目录已存在</b>，否则返回false。

难度：medium

解法：付费题。字符串处理，主要就是注意判断目录层次，检查父目录是否存在。后面还会有<b>读写文件</b>的设计题，比这个复杂。本身没有算法难度，用哈希表记录即可。

<hr>

1167 Minimum Cost to Connect Sticks

题意：你有一些棍子，长度为`sticks[i]`。连接长度x、y的棍子，代价为`x+y`。请问连到只剩一根棍子，<b>最小总代价</b>是多少？

难度：medium

解法：付费题。这显然类似<b>Huffman编码</b>，用最小堆处理。每次都选出最短的两根棍子，<b>贪心策略</b>。

<hr>

1170 Compare Strings by Frequency of the Smallest Character

题意：定义`f(s)`为字符串s中<b>最小字符</b>的频率。给定词表words和一些queries。针对每个查询，求出`f(q)<f(words[i])`的`words[i]`个数。

难度：medium

解法：<b>词表是固定的</b>，那么这个`f(w)`的统计不也是固定的吗？统计一次，<b>排序</b>。然后用`f(q)`进行二分查找，求个数就行了。总代价`O(nw*log(nw)+nq*log(nw))`。

<hr>

1171 Remove Zero Sum Consecutive Nodes from Linked List

题意：给定链表，请不断删除<b>累加为0的子链表</b>。返回最终结果。

难度：medium

解法：首先，你如果把<b>链表转成数组</b>，那就没什么难度了。但<b>原则上不允许</b>。实际上，可以针对<b>前缀和</b>做哈希统计。比如前缀和为x，存在两个点`p1、p2`，则代表<b>从`p1.next`到`p2`这段的和为0</b>，应该删掉。那么我记录了`p1`，就正好可以`p1.next=p2.next`了。注意<b>特殊case</b>，比如表头也删了。看了下我当年的代码，<b>思路正确</b>，但<b>写得挺难看的</b>。

<hr>

1175 Prime Arrangements

题意：给定`1~n`的排列，请求出<b>素数元素</b>恰好在<b>素数位置</b>的排列个数。下标按1开始，结果模`1e9+7`返回。

难度：easy

解法：数据范围不大，其实可以作为纯数学题处理。比如有p个素数，n-p个非素数，则<b>两者完全不相干</b>。结果不就是`p!(n-p)!`？n的范围很小，连<b>筛法</b>都不需要。

<hr>

1176 Diet Plan Performance

题意：一个人减肥，每天消耗卡路里是`calories[i]`。判断所有<b>k窗口的总和</b>，如果`<lower`，-1分；如果`>upper`，+1分。如果初始0分，请返回<b>最后总分</b>。

难度：easy

解法：付费题。水题。

<hr>

1177 Can Make Palindrome from Substring

题意：给定字符串s，和一些查询`q=[i,j,k]`。你可以针对s[i:j+1]子串做<b>任意排序</b>，替换其中<b>至多k个字符</b>。请判断能否得到一个回文串？针对每个查询，返回`true or false`。

难度：medium

解法：对于一个字符串，我们做哈希统计。只关心计数<b>有多少个奇数</b>，因为偶数就可以配对。比如我有cc个奇数，那么`max(cc-1,0)`个都需要<b>去掉</b>，才能得到回文串。每替换一个字符，我可以去掉两个奇数。因此，我需要替换`(max(cc-1,0)+1)/2`个字符。把这个<b>和k比较</b>即可。但这样还不行，因为代价是O(n^2)的，<b>会超时</b>。可以用<b>前缀和+位压缩</b>的方式，来高效统计<b>奇数的个数</b>。你看，是不是<b>瞬间高大上</b>了？其实不是前缀和，是<b>前缀异或</b>。总代价`O(n+qlog(int))`。

<hr>

1180 Count Substrings with Only One Distinct Letter

题意：给定字符串s，请求出单值子串的个数。

难度：easy

解法：付费题。水题。<b>数个数</b>，然后`n*(n+1)/2`。

<hr>

1181 Before and After Puzzle

题意：给定一些句子，按首尾词相连的方式，构造连接句子。语文里这叫<b>“顶真修辞”</b>。结果按<b>字典序</b>排序。

难度：medium

解法：付费题。亏我还记得顶真，<b>“从前有座山，山里有座庙”</b>之类的。本身思路很明确，对每个句子，记录它的首、尾词，作为<b>哈希key</b>。然后对<b>尾词</b>找匹配的<b>首词</b>，这样就可以<b>连句</b>了。

<hr>

1182 Shortest Distance to Target Color

题意：给定数组colors，其中有123三种值。给定一些查询`q=[i,c]`，请求出<b>距离i位置最近的c值</b>，给出<b>距离</b>，如果没有，则返回-1。

难度：medium

解法：付费题。对123都记录它们的位置，并保持有序，存放在`pos`数组中。那么查询`[i,c]`时，我针对`pos[c]`二分查找<b>i的位置</b>，用`bisect_left`找到<b>左右相邻的最近位置</b>即可。

<hr>

1184 Distance Between Bus Stops

题意：给定n个站点，形成<b>环路</b>。从`i`到`i+1`站的距离为`distance[i]`。如果可以两方向走，给定x、y站，请求出两者的最短距离。

难度：easy

解法：水题。

<hr>

1185 Day of the Week

题意：给定年月日，请求出<b>星期几</b>。

难度：easy

解法：我记得好像有个<b>神一般的一行公式</b>可以求这个。自己手写的话，好像不容易。特地看了下python的<b>库函数</b>实现，<b>这何止是复杂，摆烂吧。</b>以这个`(1 + 5((A−1) % 4) + 4((A−1) % 100) + 6((A−1) % 400)) % 7`<b>高斯公式</b>为起点，从1月1日开始数吧。

<hr>

1186 Maximum Subarray Sum with One Deletion

题意：给定数组nums，你可以选一个子数组，并删除其中<b>至多一个元素</b>，请求出能得到的<b>最大子数组和</b>。

难度：medium

解法：有<b>两种思路</b>。第一种，我选取一个子数组，想想从其中删除哪一个。肯定应该删最小的一个，因此我总需要获得当前子数组的最小值。这个思路应该可以，但我<b>没完全想清楚</b>。第二种，我选<b>一个，或者两个</b>子数组。如果选了两个，则中间<b>只能间隔一个元素</b>。我需要处理前缀max子数组、后缀max子数组，然后加起来。这个方法可以，思路也不难。总代价`O(n)`，额外空间也是`O(n)`。

<hr>

1189 Maximum Number of Balloons

题意：给定字符串，你可以选其中字符组成单词balloon。请问最多能组成多少个？

难度：easy

解法：水题，<b>计数</b>即可。

<hr>

1190 Reverse Substrings Between Each Pair of Parentheses

题意：给定一个包含<b>“()”和字母</b>的串，已知括号匹配。对于每个“(A)”，请将A的内容反转。括号可能存在多个<b>并列、嵌套</b>的情况。

难度：medium

解法：不用递归，用<b>栈</b>直接处理就行了。细节就不说了，很容易想。

<hr>

1191 K-Concatenation Maximum Sum

题意：给定数组arr和整数k，<b>将arr重复k次</b>，得到ak。请求出ak的最大子数组和，结果模`1e9+7`返回。

难度：medium

解法：首先，<b>如果arr的总和`>0`</b>，那我对于中间段，就应该全部算进去。对于结尾，则只取前缀max和后缀max。如果arr的总和`<=0`，则只能从`arr+arr`中找最大子数组，不能包含<b>一个完整的arr段</b>。总体上，这题挺麻烦的。每种case都不难，但<b>全考虑到</b>就很费劲。

<hr>

1196 How Many Apples Can You Put into the Basket

题意：给定数组arr，请从中选出总和不超过5000的元素，请问最多选几个？

难度：easy

解法：付费题。水题，<b>排序</b>即可。

<hr>

1197 Minimum Knight Moves

题意：给定一个无限大的棋盘，<b>马走日</b>。请问，从`(0,0)`出发，至少多少步可以到达`(x,y)`？

难度：medium

解法：付费题。<b>BFS</b>解决。对于无限大的棋盘，我们用<b>双向BFS</b>，效率能明显提高。

<hr>

1198 Find Smallest Common Element in All Rows

题意：给定m x n矩阵，已知每行都是有序的。请找出一个每行都存在的<b>最小公共值</b>。如果不存在，则返回-1。

难度：medium

解法：付费题。可以以<b>第0行</b>作为<b>基准</b>，对于`a[0][j]`，我都在其他所有行做二分搜索。这样，总的判断代价是O(mnlogn)。还可以用其他类似策略，总代价相同。大体思路，都是固定某1行，<b>搜索其他m-1行</b>。

<hr>

1200 Minimum Absolute Difference

题意：给定数组arr，请返回所有`i<j`，使得`|arr[i]-arr[j]|`最小。

难度：easy

解法：对`(arr[i],i)`排序，从<b>相邻元素</b>里找<b>最小差值</b>。
