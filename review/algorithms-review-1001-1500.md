# LeetCode 一句话题解 - 1001-1500

[返回目录](./README.md)

- [LeetCode 一句话题解 - 1001-1500](#leetcode-一句话题解---1001-1500)
  - [1001 - 1100](#1001---1100)

代码库地址：  
[https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/1001-1500](https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/1001-1500)

## 1001 - 1100

1002 Find Common Characters

题意：给定一个词表words，请统计在所有单词中都出现的字母，<b>顺序任意</b>。返回结果<b>包括字母种类和个数</b>，可以是多个。

难度：easy

解法：<b>哈希计数</b>，取min即可。

<hr>

1003 Check If Word Is Valid After Substitutions

题意：我们定义<b>一种操作</b>，在一个字符串的<b>任意位置</b>，插入“abc”。给定字符串s，请判断能否<b>从空串“”开始</b>，经过若干次操作得到s？

难度：medium

解法：乍一看，可能会想类似`dp[i][j]`的思路。其实仔细想想，这是个<b>栈操作</b>。比如“aabcbc”，那么当我<b>攒够一个abc</b>，我就可以把它<b>出栈</b>了。`[a,a,b,c]->[a]`，继续入栈bc，得到`[a,b,c]->[]`。按照这个思路，用一个栈处理整个字符串，如果最后能<b>清空整个栈</b>，则序列有效。奇怪的是，我以前的代码直接用的<b>暴力解法</b>，也过了。

<hr>

1004 Max Consecutive Ones III

题意：485的变体。给定01数组nums，如果你至多可以反转k个0，请问能得到的<b>最长连续1的个数</b>是多少？

难度：medium

解法：这题有两种思维，一种是想办法找出<b>应该反转0的位置</b>。这种很难，做不出来。另一种是找出一个窗口，使得窗口尽量长，且<b>窗口里有至多k个0</b>。你看，<b>滑动窗口</b>的思路就有了。这个滑动窗口<b>连dict都不需要</b>，因为我们只关心0的个数。

<hr>

1005 Maximize Sum Of Array After K Negations

题意：给定数组nums，你必须执行<b>k次操作</b>，每次任选一个元素乘以-1。请返回<b>最大的数组和</b>。

难度：easy

解法：根据<b>负数的个数</b>，分情况讨论。因为可以重复选同一个元素，那么<b>如果k很大</b>，我们可以浪费2m次操作，剩下k-2m次则用于<b>把负数变正</b>。

<hr>

1006 Clumsy Factorial

题意：阶乘知道吧？我们定义一种<b>奇怪的阶乘</b>`clumsy(n)=n*(n-1)/(n-2)+(n-3)-(n-4)*...`。但是这个式子依然按<b>正常的+-*/优先级</b>执行，除法以<b>整除</b>为准。给定n，请求出clumsy(n)的值。

难度：medium

解法：`a/b*c`、`+d-`，按照这两部分做<b>结合</b>。数据规模也不大，就这样<b>3131分组</b>，进行计算就行了。

<hr>

1007 Minimum Domino Rotations For Equal Row

题意：给定等长的数组tops、bottoms。每次允许你<b>任选位置i</b>，将`tops[i]`和`bottoms[i]`交换。请判断是否可能让tops或者bottoms变成<b>同一个值</b>。

难度：medium

解法：可以反过来想。如果能做到，则表示<b>某个值x</b>在<b>所有tops[i]或bottoms[i]都出现了</b>。因此，用哈希表记录每个值出现的位置。如果某值x出现在n个位置，则符合要求。对于<b>最小交换次数</b>，则考虑这个x所处的位置，<b>在tops居多，还是bottoms居多</b>。

<hr>

1008 Construct Binary Search Tree from Preorder Traversal

题意：给定前序遍历，请重建出一棵<b>二叉搜索树</b>。

难度：medium

解法：BST的中序遍历是有序的，因此你相当于有了<b>前序和中序</b>。剩下不说了。

<hr>

1009 Complement of Base 10 Integer

题意：给定整数n，请将其二进制表示进行01反转。

难度：easy

解法：水题。

<hr>

1010 Pairs of Songs With Total Durations Divisible by 60

题意：给定数组times，请找出其中`(times[i]+times[j])%60==0`的`(i,j)`对数。

难度：medium

解法：用哈希表，进行前缀计数。如果当前元素`times[i]%60==r`，则统计之前余数为`60-r`的个数。总代价O(n)。

<hr>

1011 Capacity To Ship Packages Within D Days

题意：有n件货物，重量为weigts[i]。如果每天运输的货物总量不能超过limit，且你需要在days天内，<b>按weights的顺序</b>运完。请问<b>limit最小值</b>是多少？

难度：medium

解法：首先，这个问题有<b>单调性</b>。因此可以用二分搜索limit的值，那么判断依据怎么定？判断依据应该是limit取某值x时，能否在days天完成运输。实际上，本题的关键在于“按weights的顺序”。<b>如果可以乱序</b>，这个问题就成了<b>背包问题</b>，那就难了。要求按weight顺序的话，<b>每次判断运送天数</b>，就很容易，可以用O(n)代价完成。这样，总代价就是O(nlog(int))。

<hr>

1013 Partition Array Into Three Parts With Equal Sum

题意：给定数组nums，请判断能否划分为<b>左中右三段</b>，使得三段的<b>子数组和都相等</b>。

难度：easy

解法：对于easy题，这题还是<b>稍难</b>的。我们<b>枚举j维度</b>，则`nums[j:n]`这段<b>后缀和</b>我们可以O(1)获取，比如值为sm。则我们在前缀`nums[0:j]`里，判断是否存在某个前缀和`nums[0:i]`等于sm。如果存在，且中段`nums[i:j]`恰好也等于sm，则<b>三等分</b>就找到了。这些<b>前缀、后缀和</b>都需要O(n)代价进行<b>预处理</b>，处理之后就可以O(1)查询了。枚举j维度代价是<b>O(n)</b>，每个位置的判断代价为<b>O(1)</b>，因此总代价是O(n)。

<hr>

1014 Best Sightseeing Pair

题意：给定数组nums，任选选取两个位置`i<j`，则得分为`nums[i]+nums[j]+i-j`。请求出<b>最大得分</b>。

难度：medium

解法：O(n^2)枚举的做法很简单，需要想想<b>优化</b>办法。一种方法是对数组先按值排序，然后直接<b>暴力枚举</b>。但是枚举时，可以加一点检查，<b>让循环尽早结束</b>。除此之外，想不出很高效的解法。看到评论区，有人说可以理解为`(nums[i]+i)+(nums[j]-j)`，这样就简单了。<b>确实。</b>

<hr>

1015 Smallest Integer Divisible by K

题意：给定正整数k，请求出一个最小的n位数，使得所有数位都是1，且这个数<b>被k整除</b>。返回n，如果不存在则返回-1。

难度：medium

解法：其实你可以理解为<b>余数</b>。比如从1开始，1、10、100、...每个<b>都对k取模</b>。这样我会得到一个余数序列，且这个序列<b>一定是循环的</b>。那么我可以按这个方式，进行<b>累加</b>。如果发现余数求和的序列，<b>能到达0</b>，则可以得出最小的n值。因为余数求和序列也<b>一定是循环的</b>，如果循环节不包括0，则表示这个数<b>永远不会被k整除</b>。

<hr>

1016 Binary String With Substrings Representing 1 To N

题意：给定01字符串s和一个整数n。请判断对于<b>`[1,n]`的所有数</b>，是否可以在s中找到它们的二进制表示。

难度：medium

解法：观察<b>数据范围</b>，可以发现n很大，但<b>s的长度不大</b>。那么我们可以枚举所有s的子串，并统计对应的整数值。检查统计结果是否<b>覆盖了`[1,n]`所有值</b>。这基本就是<b>暴力解法</b>了，但至少对于s的长度，是<b>可接受的</b>。看了下当年代码，我似乎写了个更暴力的解法，<b>竟然还过了</b>。

<hr>

1017 Convert to Base -2

题意：给定整数n，请转换为<b>-2进制</b>。

难度：medium

解法：<b>负数进制</b>，有意思。其实<b>千万不要想复杂</b>，还是按常规的<b>进制转换</b>的做法，<b>模r除r</b>，只不过这次`r=-2`。就这么简单。

<hr>

1018 Binary Prefix Divisible By 5

题意：给定01数组nums，我们用xi表示`nums[0:i+1]`构成的<b>二进制数</b>的值。请返回所有<b>xi被5整除</b>的对应位置i。

难度：easy

解法：水题。

<hr>

1019 Next Greater Node In Linked List

题意：给定单链表，对于每个节点，请找出它之后，<b>第一个大于它的值</b>。如果没有更大值，则按0处理。

难度：medium

解法：不论数组还是链表，其实无所谓。用一个<b>单调栈（或队列也行）</b>，可以处理这个问题。这个栈<b>单调递减</b>，比如当前元素是x，那么如果栈顶元素`y<x`，则表示<b>y的next greater</b>找到了。这时让y<b>出栈</b>。持续出栈，直到栈顶`y>=x`为止，这时<b>把x入栈</b>。按照这个逻辑，最后<b>留在栈中</b>的值，<b>都不存在next greater</b>，结果都按0处理。

<hr>

1020 Number of Enclaves

题意：给定m x n地形，0水1陆地。从任意陆地出发，可以按4邻接方向移动到<b>另一陆地或者出界</b>。请统计所有陆地格子中，<b>不能走出界</b>的个数。

难度：medium

解法：用<b>洪泛算法</b>，搜索<b>不和边界格子连通</b>的陆地个数。或者反过来想，从<b>边界的陆地</b>开始搜索。那么剩下<b>没有被搜到的个数</b>，就是答案。

<hr>

1021 Remove Outermost Parentheses

题意：给定一个<b>匹配的括号序列s</b>，如果找不出`s1+s2=s`，使得s1、s2都是匹配序列，则称s是一个<b>原始串</b>。现在给定s，将它划分为几个原始子串，并去掉每个子串的<b>最外层括号</b>。返回去掉后的剩余结果。

难度：easy

解法：题目讲得挺复杂，思路倒是不难。用一个栈进行模拟，<b>“(”入栈，“)”出栈</b>。当栈<b>恰好清空</b>，证明你找到了一个<b>原始串</b>，记录下对应的<b>左右边界</b>，把<b>边界的“(”和“)”</b>去掉即可。

<hr>

1022 Sum of Root To Leaf Binary Numbers

题意：给定二叉树，节点值都是0或1。从根到叶组成的路径表示一个<b>二进制数</b>。请求出所有<b>路径之和</b>。

难度：easy

解法：按题意，递归求和即可。

<hr>

1023 Camelcase Matching

题意：<b>驼峰命名法</b>，比如“HelloWorld”，HW大写。现在给定一个词表queries和一个模式串。请判断单词里的<b>大写字符</b>是否符合<b>给定模式</b>。符合的标准是，给定单词w和模式p，你可以在p中<b>插入小写字符</b>，<b>使其变为w</b>。

难度：medium

解法：其实就是<b>判断子序列</b>。但判断过程中，如果发现单词里的<b>大写字符没有匹配</b>，则不符合要求。因为你<b>只能插入小写字符</b>，大写必须全部匹配。

<hr>

1024 Video Stitching

题意：给定一些`[x,y]`形式的区间clips，请从其中选出最少的区间，使得拼起来能<b>完整覆盖`[0,t]`范围</b>。返回选出的<b>区间个数</b>。

难度：medium

解法：首先按`(x,y)`维度<b>排序</b>。接下里，O(n^2)的DP思路很容易想到了。对于`clips[i]`，枚举`0~i-1`，看是否满足`clips[j].y>=clips[i]`，如果满足，则`dp[i]=min(dp[i],dp[j]+1)`。我们只关心<b>最少用dp[i]步</b>能到达i位置。最后检查结果时，判断两个条件：<b>i位置</b>是否能到达，<b>右边界t</b>是否能覆盖`clips[i].y>=t`。那么<b>左边界0</b>怎么确定呢？左边界在DP计算时，已经确定过了。

<hr>

1025 Divisor Game

题意：给定整数n，玩一种游戏。两人轮流选一个<b>n的约数x，且x<n</b>，n变为<b>n-x</b>。如果一方<b>无法找到x</b>，则输掉游戏。请判断<b>先手</b>是否必胜？

难度：easy

解法：还是按照博弈的<b>基本思路</b>：定义<b>一步状态转移</b>关系`x->y`，如果<b>所有</b>y都输，则x输；如果<b>存在某个</b>y能赢，则选这条赢的路，x赢。照这个思路，搜索所有状态转移，用<b>DP思路</b>可以解决。对于一道easy题，这已经很难了。

<hr>

1026 Maximum Difference Between Node and Ancestor

题意：给定二叉树，请求出其中两节点a、b的<b>最大差值`|a.val-b.val|`</b>，且a是b的祖先节点。注意，是<b>祖先节点</b>，不一定是父节点。

难度：medium

解法：因为是祖先节点，我可以往下看。对于任何点p，p所在子树总有个<b>最小值、最大值</b>。那么我用`max_val`、`min_val`表示。则这个<b>子树之内</b>，答案只能是`|p.val-max_val|`、`|p.val-min_val|`其中之一。按这个思路，遍历整棵树即可。

<hr>

1027 Longest Arithmetic Subsequence

题意：给定数组nums，求出最长的<b>算术子序列</b>长度。算术意思是<b>等差数列</b>。

难度：medium

解法：很明显的<b>DP思路</b>，枚举两个维度`j<i`，则公差`d=nums[i]-nums[j]`。我可以用`dp[(i,d)]`表示以i位置为<b>终点</b>，公差为d的<b>等差数列的长度</b>。实际上dp数组的类型是`list[dict[int,int]]`，细节就不说了。为什么<b>倒推</b>，而不用正推呢？因为i之后的值，<b>你还不知道</b>，无法<b>复用子问题的结果</b>，这不符合DP的思维。

<hr>

1028 Recover a Tree From Preorder Traversal

题意：给定一种特殊的前序遍历。对于节点p，如果它深度为d，则输出d个`-`，再输出`p.val`。根节点的深度为0。如果节点只有<b>1个子节点</b>，则一定是<b>左节点</b>。按照这个遍历结果的字符串，重建整棵树。

难度：hard

解法：首先当然是字符串处理，解析成`[(深度,节点值)]`的格式。既然是前序遍历，那我们从深度变化，来判断是往下还是往上。比如`1-2--3--4-5--6--7`，处理后对应`[(0,1),(1,2),(2,3),(2,4),(1,5),(2,6),(2,7)]`。那么我们从i=0开始，根据i+1位置的深度，来判断我应该往下<b>1层</b>，还是往上<b>1或几层</b>。至于<b>左右节点</b>，如果左子树已经遍历了，就往右；否则，先创建左子树。总体上，不算特别难，但需要一点<b>脑力+体力</b>的一题。

<hr>

1029 Two City Scheduling

题意：有2n个人，每个人前往a城、b城的代价，分别是`costs[i]=[ai,bi]`。现在需要各n人前往两个城市，请求出<b>最小的总代价</b>。

难度：medium

解法：其实这题有点<b>脑筋急转弯</b>。如果你按<b>DP思路</b>做，也可以，但很复杂。我们考虑选出了n人去a城，n人去b城，则可以理解为`sum(所有a[i])-sum(没被选中的a[j])+sum(对应被选中的b[j])`。这其中`sum(a[i])`是固定值，因此我们尽可能让`sum(没被选中的a[j]-b[j])`<b>最大</b>，则总代价就<b>最小</b>。于是，你按a[i]-b[i]排序，选出<b>后n个值</b>，就是最大值了。对后n个，我们<b>取b城</b>；前n个，则<b>取a城</b>。代码非常简单，但思维并不容易。<b>有点坑人。</b>

<hr>

1030 Matrix Cells in Distance Order

题意：给定<b>行数列数n、m</b>，以及中心点`(r0,c0)`。请按照距离<b>从近到远</b>，给n*m个坐标排序。距离以Manhattan距离`|x1-x2|+|y1-y2|`为准。

难度：easy

解法：按题意实现即可，<b>排序</b>。

<hr>

1031 Maximum Sum of Two Non-Overlapping Subarrays

题意：给定数组nums和长度n1、n2。请在其中找出两个长度为n1、n2的<b>不重叠子数组</b>，使得<b>子数组和加起来</b>最大。

难度：medium

解法：按照<b>前缀max、后缀max</b>的方式，求出每个i位置的<b>子数组最大和</b>。针对n1、n2都求一次。然后按照<b>n1左n2右、n2左n1右</b>的方式求出最大值。思路不难，写起来还挺麻烦的。

<hr>

1033 Moving Stones Until Consecutive

题意：有三颗石头，位于`a<b<c`三个位置。每次操作，你可以选左右端点的一个，把石头移动到k位置，且满足`a<k<c,k!=b`。这个步骤必然会缩小范围，如果最终<b>abc挨在一起</b>，则操作结束。请求出你能执行的最大、最小操作次数。

难度：medium

解法：最大次数简单，我每次只移动一格，而且区间长度也至少-1。那我就每次-1，答案是`c-a-2`。<b>最小次数</b>，要想一下。比如abc，我拿a，则我肯定应该把a放到bc中间，这样就成了bac。为什么？因为这样我直接<b>消灭了一个区间</b>。因此，每次我都<b>消灭更长的区间</b>，也就是`max(ab,bc)`。其实<b>至多2次就能搞定</b>，想想为什么？这题总体上是个<b>智力题</b>。

<hr>

1034 Coloring A Border

题意：给定m x n矩阵grid，`grid[i][j]`的值表示颜色，想通颜色的4邻接格子组成一个<b>连通分量</b>。现在给定位置`(r,c)`，请将对应的连通分量的<b>边界</b>改为color颜色。

难度：medium

解法：洪泛算法，从`(r,c)`出发，<b>执行BFS</b>并且找出边界，修改值为color即可。

<hr>

1035 Uncrossed Lines

题意：给定数组nums1和nums2，你可以选定`nums1[i]`和`nums2[j]`连一条线，如果<b>两者的值相等</b>。每个元素不能发出<b>超过一条线</b>，且要求所有线不能<b>交叉</b>。请问至多能连几条线。

难度：medium

解法：重点是线不能<b>交叉</b>。也就是说，对于上一条线`(i1,j1)`，我们的下一条线`(i2,j2)`必须满足`i1<i2,j1<j2`。<b>贪心还是DP？</b>应该是<b>DP</b>。我们定义`dp[i][j]`表示`nums1[0:i+1]`和`nums2[0:j+1]`部分<b>最多能连线</b>的个数。剩下不用说了，这其实就是最长公共子序列，<b>LCS问题</b>。

<hr>

1037 Valid Boomerang

题意：给定三个点，判断是否<b>不共线</b>。

难度：easy

解法：水题。

<hr>

1038 Binary Search Tree to Greater Sum Tree

题意：把一个BST转化为<b>“较大树”</b>。意思是，每个节点的值都变为<b>本身+所有大于它的值之和</b>。

难度：medium

解法：有个<b>土办法</b>，就是做<b>中序遍历</b>。把节点都<b>放到数组里</b>，进行后缀累加。

<hr>

1039 Minimum Score Triangulation of Polygon

题意：<b>多边形</b>的<b>三角剖分</b>是图形学里的一种基本操作。给定n个顶点的<b>凸多边形</b>，每个点有个分值`values[i]`。现在需要将其划分为n-2个三角形，每个三角形的点都从n个点选取，且不存在<b>交叉边</b>。对于每个三角形，分值按照<b>三顶点分值`values[i]`的乘积</b>计算。总分是所有三角的<b>分值之和</b>。请求出最小总分。

难度：medium

解法：如果不知道这个概念，从<b>几何上</b>确实挺难理解。最好<b>用草稿纸画一下</b>。其实这题难点在于<b>怎么划分子问题</b>。比如我选了ijk三个点，分<b>三种情况</b>讨论。比如ijk相邻，则剩余的i~k是<b>一个子问题</b>；比如ij相邻，k不相邻，则剩余的i~k、j~k是<b>两个子问题</b>；比如ijk都不相邻，则剩余的i~j、j~k、k~i是<b>三个子问题</b>。n变形，这相当于一个<b>环形数组</b>。因此你用dp[i][j]表示子问题时，要注意i<=j、i>j的情况，两者其实是<b>对称的</b>。剩下的DP细节就不说了。<b>有难度</b>的一题，需要一点<b>几何思维</b>才能搞明白。对于每个dp[i][j]，需要枚举中间的k得到最优解，因此总代价是<b>O(n^3)</b>。用<b>三层循环</b>或者<b>记忆化搜索</b>都可以。

<hr>

1040 Moving Stones Until Consecutive II

题意：1033的变体。这次有<b>n个石头</b>，其他规则完全相同。返回最大、最小移动次数。

难度：medium

解法：既然1033题已经做了，而且是个<b>智力题</b>，那这次尝试用<b>相同思维</b>。游戏结束的条件是，n个石头完全<b>挨在一起</b>。<b>最大次数</b>，还是按照每次距离-1，这个总是可以办到的，和1033一样。最小次数，则可以考虑枚举两个位置i、j，但i、j距离<b>至少应该是n-1</b>，这样才能<b>容纳n个石头</b>。剩下工作，就是把(i,j)范围之外的石头<b>都搬进来</b>了。<b>这题挺难的。</b>

<hr>

1041 Robot Bounded In Circle

题意：机器人开始在`(0,0)`位置，朝向+y方向。三种命令，G前进1格、L左转、R右转。如果给定一个<b>指令序列s</b>，机器人不断<b>重复执行</b>这个序列。请判断机器人的路径是否构成一个<b>环路</b>。

难度：medium

解法：其实是个<b>智力题</b>，很坑爹的那种。我们只执行一次s，如果发现<b>方向变了</b>，则<b>一定会循环</b>。<b>仔细想想</b>为什么。如果方向不变，则判断发生的总位移`(x,y)`是否为0，<b>不为0则不循环</b>。其实<b>循环的逻辑</b>不难想，如果你转了<b>180度</b>，`(+x,+y)`就变成了`(-x,-y)`，两次回原点；如果你转了<b>90度</b>，则依次按照`(+x,+y),(+y,-x),(-x,-y),(-y,+x)`，四次回原点。总之，一定会循环的。

<hr>

1042 Flower Planting With No Adjacent

题意：n个节点的<b>无向图</b>，存在一些边`[x,y]`。已知每个点的度数不超过3。你可以用4种颜色给n个点着色，使得任意<b>两个相邻的点</b>不同色。请返回一种有效的<b>着色方案</b>。

难度：medium

解法：这就是著名的<b>四色定理</b>，讲的是地图上相邻的地块，最多用四种颜色就可以保证相邻颜色不冲突了。当然，<b>证明四色定理</b>曾经是一个<b>世界级难题</b>，但给出一个着色方案不算很难。直接<b>搜索+回溯</b>即可。因为颜色总数为4，且每个点的度数不超过3，即使失败了，<b>回溯的代价</b>也<b>不会很大</b>。看来这题曾经的难度是easy，后来改medium了。<b>这肯定不是easy。</b>

<hr>

1043 Partition Array for Maximum Sum

题意：给定数组arr，请将其划分为长度至多为k的子数组。定义每个子数组的得分为`max(sub)*len(sub)`，也就是<b>最大值乘以长度</b>。请求出<b>子数组得分总和的最大值</b>。

难度：medium

解法：DP的思路还是很容易看出的。对于arr[0:i+1]，我可以看看划分出几段。比如我从arr[j:i+1]划分一段，当然这个长度不能超过k。那么`dp[i]=max(dp[j]+max(arr[j:i+1])*(i-j+1))`。这样的话，总代价O(n^2)，答案就是`dp[n-1]`。在这里面，求`max(arr[j:i+1])`的操作，也可以通过<b>预计算</b>来提高效率，<b>预计算代价`O(n^2)`</b>，之后O(1)可查。

<hr>

1046 Last Stone Weight

题意：有n个石头，大小用`stones[i]`表示。每次选出最大的两个石头x、y。如果`x!=y`，则碰撞后剩余石头`|x-y|`；如果相等，则两个石头都消失。请求出<b>最终剩余石头</b>的大小。

难度：easy

解法：<b>最大堆</b>，每次取出两个元素。

<hr>

1047 Remove All Adjacent Duplicates In String

题意：给定字符串s，如果其中存在两个<b>相邻的相等字符</b>`s[i]==s[i+1]`，则<b>都移除</b>。持续移除，直到没有相邻的相等字符为止，返回最终结果。

难度：easy

解法：用<b>栈</b>。

<hr>

1048 Longest String Chain

题意：给定一个词表words，请从中选出一些词`w[i]`，使得每个`w[i]`都是`w[i+1]`的子序列，称为一个<b>“词链”</b>。请求出词链的<b>最大长度</b>。

难度：medium

解法：题目定义了一个predecessor概念，其实就是<b>子序列</b>。首先应该按<b>长度降序</b>进行排序。从0位置开始，定义`dp[i]`为以<b>i位置开始</b>的<b>最长词链长度</b>。则枚举`j=0~i-1`，如果`words[j]`是`words[i]`的子序列，则`dp[i]=max(dp[i],dp[j]+1)`，必须<b>按长度排序</b>，这个枚举方式才有效。看了下当年的代码，<b>写法略有不同</b>，但思路差不多。

<hr>

1049 Last Stone Weight II

题意：1046的变体。这次可以<b>任选两个石头碰撞</b>，不用选最大的两个。这次希望最后剩下的石头最小，或者全部消失。请求出最终剩下的<b>最小石头</b>的尺寸。

难度：medium

解法：想了下，<b>没什么好思路</b>。也不能<b>暴力搜</b>吧？其实有个思路，比如l<b>两个石头</b>`x>y`，碰撞后剩下的是`x-y`。如果我有<b>两堆石头</b>，<b>总量</b>分别是x和y呢？其实<b>可以证明</b>，碰撞后剩下的碎石头，总量也是`x-y`。明白这点，就可以转化为<b>01背包问题</b>了。怎么才能让最终剩余的石头最少？我将石头分为两堆，使得两堆的差值最小即可。因此，对于总和sum，我可以用<b>01背包</b>的解法，求出我能得到的最接近`sum/2`的值。剩下不说了。

<hr>

1051 Height Checker

题意：给定数组a，请比较`a`和`sorted(a)`<b>值不相等</b>的位置个数。

难度：easy

解法：水题。

<hr>

1052 Grumpy Bookstore Owner

题意：给定n分钟，每分钟有`customers[i]`个客人进店。grumpy[i]表示第i分钟的<b>怒气值</b>，0则表示客人<b>满意</b>，1不满意。如果允许你选择其中的<b>连续k分钟</b>，让怒气保持0。请求出最大的<b>满意客人个数</b>。

难度：medium

解法：题目讲得挺复杂，其实只考虑这k分钟就行。首先，我们对<b>所有`grumpy[i]==0`的位置</b>，求customers[i]之和，这个作为一个固定值。然后考虑所有长度为k个窗口，计算每个窗口里，因`grumpy[i]==1`而损失的客人。这个窗口是<b>滑动窗口</b>，且窗口大小<b>固定是k</b>，因此计算很容易，用<b>前缀和相减</b>即可。求出所有窗口中，<b>损失最大</b>的一个。我们挽回这个<b>最大损失</b>，就可以使<b>最多的顾客</b>满意了。总代价<b>O(n)</b>。

<hr>

1053 Previous Permutation With One Swap

题意：给定可能有重复元素的数组arr，请通过<b>一次交换</b>，得到字典序小于arr的最大数组。如果不存在，则返回原数组。

难度：medium

解法：一次交换，要求<b>largest smaller</b>。那么我们应该把交换尽量放在尾巴上。我们看个例子，`[1,6,3,5,7]`，那么357已经顺序，不可能更小，因此我<b>需要交换6</b>。6和谁换？应该和467里，<b>小于6且最大</b>的换，因此是`[1,5,3,6,7]`。总结思路，找出<b>第一个逆序元素</b>`a[i]>a[i+1]`，再从`[i+1,n-1]`里，找出<b>最后一个j</b>，使得`a[j]<a[i]`，交换`(a[i],a[j])`就是答案。总代价<b>O(n)</b>。

<hr>

1054 Distant Barcodes

题意：给定数组arr，请重排顺序，使得任意相邻元素都不相等。

难度：medium

解法：对元素进行计数，得到`(个数,值)`的统计。将统计放入一个<b>最大堆</b>，每次取出<b>个数最多</b>的元素，<b>拿走1个，设置cd=1</b>，cd过了才能重新放入堆中。实际上游戏里的<b>cd机制</b>就是这么实现的，用一个<b>冷却队列</b>，配合<b>计时机制</b>。不用<b>最大堆</b>的话，也可以用<b>哈希表+排序</b>实现，但方式更复杂，且难想。还是用<b>堆</b>吧。

<hr>

1055 Shortest Way to Form String

题意：给定字符串s和t，请从s中选出<b>最少的子序列</b>，使得这些<b>子序列相连</b>等于t。

难度：medium

解法：付费题。DP思路很容易想，不细说了。但这题是<b>贪心还是DP</b>？其实是<b>贪心</b>。比如`t[i:j]`是s的子序列，`t[i:j+1]`不是子序列。那我选`t[i:j]`就是按照<b>尽可能长</b>的原则。但如果我故意选`t[i:j-1]`，舍弃最后一个字符，我能得到<b>更优解</b>吗？答案是<b>不能</b>。对于下一段匹配，你<b>刚才舍弃的字符</b>，至多这次能用上，也可能用不上。用上了，你得到<b>相同的解</b>；用不上，你只能得到<b>更差的解</b>。因此，贪心思路是<b>最优的</b>。按照每次<b>尽可能多匹配</b>的原则，扫描t串即可。总代价`O(nt*ns)`，平均代价则<b>很接近`O(nt+ns)`</b>。

<hr>

1056 Confusing Number

题意：给定一个整数，如果旋转180度后，变为一个<b>不同但依然合法</b>的数，称为<b>“迷惑数”</b>。请判断给定数n是不是迷惑数。

难度：easy

解法：付费题。处理`16890`的情况即可，`25`不算，虽然在<b>七段数码管</b>里，25旋转也有效。

<hr>

1057 Campus Bikes

题意：二维平面上，有n个工人和m个自行车。我们按照`(工人-车的距离,工人编号,自行车编号)`的升序，给工人分配自行车。请返回长度n的数组，表示<b>第i个工人</b>分到的<b>自行车编号</b>。

难度：medium

解法：付费题。要注意，不是从0~n-1号工人依次分自行车，而是从<b>所有配对里</b>，找<b>距离最小</b>的。因此，理论上你需要从O(n*m)个组合里找。暴力解法，就是直接<b>枚举所有组合</b>，按给定的优先级进行<b>排序</b>。按这题的数据量，其实<b>这样就过了</b>。如果想<b>优化</b>，可以额外做一些<b>排序过滤</b>，提前筛选掉很多<b>无用的配对</b>。

<hr>

1058 Minimize Rounding Error to Meet Target

题意：给定一些浮点数prices，你可以对每个值取`floor`或者`ceil`。请问能否得到总和`target`？如果可以，请返回最小的<b>总舍入误差</b>。否则返回“-1”。

难度：medium

解法：对于floor和ceil，差值至多是1。因此，可以把所有元素都变为<b>“0或1”</b>这样处理，减掉一个<b>`floor(x)`的偏移量</b>。如果减去之后，target不在`[0,n]`范围内，则<b>无解</b>。难点在于求出<b>“总舍入误差”</b>，而且要求<b>最小</b>。因此，需要对<b>舍入部分做排序</b>。<b>靠近1</b>的取ceil，<b>靠近0</b>的取floor，这样总舍入误差就是最小的。这题还挺难，<b>思路不太好想</b>。

<hr>

1059 All Paths from Source Lead to Destination

题意：给定有向图和起点终点src、dst，请判断从src发出的路径，无论怎么走，最终<b>一定会停在dst</b>。

难度：medium

解法：付费题。意思就是<b>条条大路同罗马</b>。这个条件很严格，要求src和dst需要连通，且从src<b>可达的点</b>里，出度为0的只有dst一个。而且，<b>不能有环</b>。可以用<b>DFS或者拓扑排序</b>处理，建议DFS。执行DFS时，记录路径，如果路径里有<b>重复节点</b>，则表示有环。如果路径里的点已经在<b>其他路径</b>访问过了，也可以跳过。判断一下<b>出度为0的末端点</b>是否只有dst。

<hr>

1060 Missing Element in Sorted Array

题意：给定有序数组nums，从nums[0]开始，一直+1。请找出<b>第k个</b>缺失的值。比如`[4,7,9,10]`，则<b>第3个缺失值是8</b>，5、6、8。

难度：medium

解法：付费题。显然，O(n)的解法很直白，往下<b>数数</b>就行。那么如何<b>二分</b>呢？我们看看每个相邻元素`(nums[i],nums[i+1])`之间，<b>缺失了多少值</b>。得到一个缺失个数`miss_count`的统计，对这个做<b>前缀和</b>得到`miss_sm`。然后对这个`miss_sm`做二分搜索就行了，剩下不说了。实际写法更简单，直接用`a[mm]-a[ll]`就行了。

<hr>

1061 Lexicographically Smallest Equivalent String

题意：给定s1、s2等长字符串，其中`s1[i]-s2[i]`表示两个字符的等价关系，比如`a-b`表示ab等价。已知等价关系是对称、传递的，即`ab等价且bc等价->ac等价且ca等价`。给定s1、s2定义的等价关系，和一个字符串baseStr，请对baseStr做等价变换，得到<b>字典序最小</b>的结果。返回这个结果。

难度：medium

解法：题目是真的绕嘴，<b>完全不知所云</b>。其实看明白后，很容易想到<b>等价类、无向图连通分量</b>，因此用<b>并查集</b>。对于baseStr的<b>每个字符c</b>，都找出<b>和c等价的所有字符</b>中，<b>最小的一个</b>。所有字符都变为最小，总结果就是<b>字典序最小</b>。

<hr>

1062 Longest Repeating Substring

题意：给定字符串s，请找出其中最长的子串ss，使得ss在s中至少出现两次。位置可以<b>重叠</b>。

难度：medium

解法：付费题。直接<b>枚举i、j两个位置</b>进行匹配，看能匹配多长。总代价`O(n^2)`。

<hr>

1063 Number of Valid Subarrays

题意：给定数组nums，请求出符合条件的<b>子数组个数</b>，要求子数组的<b>0号元素是最小值</b>。

难度：hard

解法：付费题。我们考虑`nums[i]`，i位置往前<b>延伸多长</b>，`nums[i]`能保持最小值？那么直白的解法就是`O(n^2)`的枚举了。因此最优解必须是`O(n)`的。看例子，`[1,4,2,5,3]`，我用一个<b>递增的单调栈</b>。栈的变化情况是`[1]->[1,4]->[1,2]->[1,2,5]->[1,2,3]`。想想<b>4出栈的时候</b>，发生了什么？4遇到了2，因此<b>4不再是最小值</b>了，就出栈了，4对应的<b>边界</b>就找到了。比如<b>i元素的边界是j</b>，也就是说`i<j,nums[i]>nums[j]`（也可能`j==n`，出界了）。那么i元素总共对应了<b>`j-i`个子数组</b>。累加起来，总代价`O(n)`。

<hr>

1064 Fixed Point

题意：给定有序且无重复值的数组A，请找出第一个满足`A[i]=i`的位置i。如果不存在则返回-1。

难度：easy

解法：付费题。<b>二分搜索。</b>

<hr>

1065 Index Pairs of a String

题意：给定文本text和词表words，请找出所有`(i,j)`位置，使得`text[i:j+1]`是词表中的词。

难度：easy

解法：付费题。<b>暴力匹配</b>就行了。

<hr>

1066 Campus Bikes II

题意：1057的变体。这次分配自行车的目标，改为所有`工人-自行车`的<b>距离总和</b>最小。

难度：medium

解法：付费题。乍一想，应该很难。看数据范围<b>`<=10`</b>，说明确实很难。那就<b>暴力搜</b>？虽然是暴力搜，因为数据只有10，可以用<b>位压缩</b>提高效率，用`1<<nb-1`的掩码来表示<b>哪些自行车已经被分配</b>。除此之外，没什么特别技巧了。

<hr>

1071 Greatest Common Divisor of Strings

题意：给定字符串s和t，如果`s=t重复n次`，则称t是s的<b>“约数”</b>。现在给定s1、s2，请求出<b>“最大公约数”</b>，如果不存在则返回“”。

难度：easy

解法：题目难度既然是easy，那就可以<b>暴力匹配</b>了。对于每个串，找出最短的循环节t1、t2。因为是<b>最短循环节</b>，如果`t1!=t2`，则这个公约数<b>一定不存在</b>。如果相等，则考虑n1和n2的最大公约数。最终结果就是`t*gcd(n1,n2)`。对于<b>最短循环节</b>，高效的匹配算法是<b>KMP算法</b>。不想手写KMP的话，直接用`re.match`做暴力匹配就行了。

<hr>

1072 Flip Columns For Maximum Number of Equal Rows

题意：给定m x n的01矩阵，你可以任意选择某列，<b>反转整列的值</b>。请求出能得到的<b>整行值全0或全1</b>的最大行数。

难度：medium

解法：我们先假定某个第i1行变成全1了，这时<b>恰好某个i2行</b>也是全1。我在反转1列时，所有值都一起变，这代表i1行和i2行在任何时刻，都<b>长得一模一样</b>。因此，对于一个01串s，我用`1-s`表示取反结果。则当s变成全1，`1-s`也就成了全0。因此，我可以用<b>哈希表</b>，统计<b>每行的01字符串</b>的个数。比如`00101`有3个，`11010`有2个，那么我经过一些反转，就可以得到3个`11111`和2个`00000`，共5个。思路总结，就是`max(mm[s]+mm[inverse(s)])`。总代价<b>O(m*n)</b>。python是支持<b>大数运算</b>的，你甚至不需要字符串，直接<b>位操作</b>就行了。

<hr>

1073 Adding Two Negabinary Numbers

题意：给定两个-2进制的大数arr1、arr2，最高位在左边。请做<b>加法</b>。

难度：medium

解法：首先<b>反转一下</b>，最低位放左边。`1+1=2`，进位的话，`2*(-2)^k=-(-2)^(k+1)=(-2)^(k+2)+(-2)^(k+1)`，就按这个逻辑处理。当然还有一种<b>偷懒的办法</b>，就是转成10进制，再转回-2进制。对于python当然方便，因为<b>大数运算</b>是内部支持的。其他语言就不一定了。

<hr>

1074 Number of Submatrices That Sum to Target

题意：给定m x n矩阵和一个值target。请统计<b>子矩阵和</b>为target的个数。

难度：hard

解法：枚举子矩阵和，我们如果枚举<b>左上、右下</b>两个角，用<b>前缀和</b>的方式计算，总代价就是<b>O(n^4)</b>。难度hard，当然<b>不会这么简单</b>。因此，要优化。那么，我们枚举<b>行维度i1、i2</b>，这是O(n^2)，得到的就是一个<b>一维数组</b>。求一个数组里，<b>子数组和</b>为target的个数，这个<b>O(n)时间搞定</b>，会做吧？剩下不说了。所有这题关键，就是<b>问题转化的能力</b>。总代价<b>O(n^3)</b>。

<hr>

1078 Occurrences After Bigram

题意：给定一个句子和<b>a、b两个词</b>，如果句子中某词c按照<b>a、b、c</b>连续出现，返回所有这样的词c。

难度：easy

解法：水题。

<hr>

1079 Letter Tile Possibilities

题意：给定一些积木，积木上有字母`tiles[i]`。请求出用这些积木，能拼出的不同序列。可以<b>选部分或者全部，顺序任意</b>。

难度：medium

解法：显然，这个组合数<b>非常非常多</b>。数据稍微一大就<b>炸了</b>，因此给定的规模很小，直接<b>暴力搜</b>吧。很奇怪，我以前为什么写了个<b>这么麻烦的解法</b>。

<hr>

1080 Insufficient Nodes in Root to Leaf Paths

题意：给定二叉树，我们统计所有根到叶的路径。如果对于某节点p，所有<b>经过它的路径</b>，总和都小于limit，则称这个节点p<b>“不足”</b>。请<b>删除</b>所有不足的节点，返回修改后的二叉树。

难度：medium

解法：反过来，如果某条路径的`总和>=limit`，则路径上所有点都是<b>充足</b>的。那么我们可以递归一次，标记出所有的<b>充足点</b>。然后再递归一次，<b>从上到下</b>删除不足点。删除某点p，就等于<b>删除p的整个子树</b>。当然，这个思路也可以<b>一次递归完成</b>。

<hr>

1081 Smallest Subsequence of Distinct Characters

题意：给定字符串s，请找出一个<b>字典序最小</b>的子序列ss，使得ss包含了<b>s中的所有唯一值</b>，且<b>ss无重复字符</b>。

难度：medium

解法：三个要求：字典序最小、包含s的所有值、无重复值。对于26个字母，ss的最大长度也就26。那么我们不用想得很复杂。对应s的每个字符，我们总是比较当前字符如果<b>替换进去</b>，能否得到<b>字典序更小</b>的结果。能，我就放进去。比如`cbacdcbc`，依次判断的结果是`c->cb->cba->bac->bacd->acdb`，其中有两处没有替换，因为替换之后<b>字典序会变大</b>。匹配的总代价是<b>O(n*26)</b>，也等于O(n)。看了下我以前的代码，和上面这个思路<b>不一样</b>。

<hr>

1085 Sum of Digits in the Minimum Number

题意：给定数组nums，判断<b>最小元素</b>的<b>数位之和</b>是否为<b>奇数</b>。

难度：easy

解法：付费题。一句话给了<b>3个要素</b>，真简洁。

<hr>

1086 High Five

题意：给定一些`(学生ID,分数)`的记录，请返回每个学生<b>前5高</b>的分数的<b>均值</b>，按<b>ID升序</b>排列。

难度：easy

解法：付费题。题目很清晰，按要求实现即可。

<hr>

1087 Brace Expansion

题意：给定一种<b>语法</b>，对序列进行展开。用`{a,b}`表示一个含有a、b的集合，用`{a,b}{c,d}`表示ab集和cd集的<b>笛卡尔积</b>，结果为`["ac","ad","bc","bd"]`。给定一个序列，请按语法规则进行<b>展开</b>。给定序列不包含<b>嵌套括号</b>，结果按字典序升序排列。

难度：medium

解法：付费题。既然不包含<b>嵌套括号</b>，那问题就简单点。字符串处理+求笛卡尔积，形式上可以写一个DFS函数，用<b>搜索的思路</b>去做。

<hr>

1089 Duplicate Zeros

题意：给定数组nums，请将其中的0值复制一遍。比如`00`，则变成`0000`。非零元素需要按顺序后移，如果<b>位置不够，则丢弃</b>。请<b>就地修改</b>数组，不返回任何值。

难度：easy

解法：因为要移动非零元素，我们可以先<b>从前往后</b>，统计0的个数。这样就可以确定<b>偏移量</b>了。再<b>从后往前</b>，按偏移量，<b>`>n-1`位置</b>的元素丢掉。<b>在界内</b>的元素，依次填进去。

<hr>

1090 Largest Values From Labels

题意：有n件物品，各有类型`lables[i]`和价值`values[i]`。你需要从中选出<b>至多</b>`numWanted`件，且<b>同类型</b>不能超过`useLimit`件。请求出得到的<b>最大价值总和</b>。

难度：medium

解法：<b>看着很难，其实不难。</b>首先，我肯定应该选够`numWanted件`，<b>没理由少拿</b>。然后，<b>贪心还是DP？</b>应该是<b>贪心的</b>。我直接按`values`降序排列，<b>尽量拿大的</b>。同时，保证遵守`useLimit`的限制即可。

<hr>

1091 Shortest Path in Binary Matrix

题意：给定n x n的01矩阵。请找出一条<b>全0的8邻接</b>路径，从`(0,0)`出发到达`(n-1,n-1)`。

难度：medium

解法：最短路径，这好像直接<b>BFS</b>就行了。按照<b>0格子、8邻接</b>的要求，搜吧。如果希望快一点，还可以<b>双向BFS</b>。这题<b>单向BFS足够了</b>。

<hr>

1093 Statistics from a Large Sample

题意：给定一个`[0,255]`范围的抽样。值范围不大，但是<b>抽样个数非常多</b>。现在给定统计结果`count[i]`表示<b>i值的个数</b>。请求出min、max、mean、median、mode。<b>mode是众数</b>。

难度：medium

解法：这题出得很好，<b>统计学是个好东西</b>。min、max、mean、mode都不说了，很简单。中位数median，可以用`count[i]`计算<b>累加和</b>，看看<b>中间</b>落在<b>哪个值i</b>上。注意<b>特殊情况</b>，如果中间值恰好在<b>`i`、`i+1`的边界</b>，那就是`i+0.5`。

<hr>

1094 Car Pooling

题意：在数轴上，所有位置的<b>初始值为0</b>。给定一些区间`[x,y,val]`和一个capacity值，表示<b>给每个[x,y]区间+val</b>。如果给定的区间可能存在重叠，请判断是否存在某个区间的值<b>超过了capacity</b>。

难度：medium

解法：题目说的拼车问题，转成<b>数学模型</b>，就是<>如上所述。区间+val，这个可以转化成`[0,x-1,-val]`和`[0,y,+val]`两个操作。因此，你可以用<b>后缀和</b>处理，也可以用<b>树状数组</b>处理。x、y的<b>数据范围不超过1000</b>，因此建议用后缀和的方式，<b>简单易实现</b>。

<hr>

1096 Brace Expansion II

题意：1087的变体。给定一种<b>语法</b>，对序列进行展开。用`{a,b}`表示一个含有a、b的集合，用`{a,b}{c,d}`表示ab集和cd集的<b>笛卡尔积</b>，结果为`["ac","ad","bc","bd"]`。如果集合只有一个元素，<b>可以省略“{}”</b>现在给定一个这样的序列，请按如上规则，进行<b>递归展开</b>，返回最终结果。

难度：hard

解法：题目本身倒是定义明确，也没什么特别动脑的地方。因此hard主要体现<b>麻烦</b>。<b>字符串处理+递归解析</b>即可，很费劲的一道<b>体力题</b>。注意对结果进行<b>去重和排序</b>。

<hr>

1099 Two Sum Less Than K

题意：给定数组A和值k，请求出`i<j,A[i]+A[j]`能得到的最大值s，且`s<k`。返回s，如果不存在，则返回-1。

难度：easy

解法：付费题。排序之后，双指针从`i=0,j=n-1`向中间靠拢。排序代价为主，因此总代价`O(nlogn)`。

<hr>

1100 Find K-Length Substrings With No Repeated Characters

题意：给定字符串s，请统计长度为k，且没有重复字符的子串个数。

难度：medium

解法：付费题。这个滑动窗口的<b>大小是固定的</b>，因此非常简单。<b>滑动+统计</b>，看看<b>唯一值个数是否为k</b>就行了。
