# LeetCode 一句话题解 - 2001-2500

[返回目录](./README.md)

- [LeetCode 一句话题解 - 2001-2500](#leetcode-一句话题解---2001-2500)
  - [2001 - 2100](#2001---2100)
  - [2101 - 2200](#2101---2200)
  - [2201 - 2300](#2201---2300)
  - [2301 - 2400](#2301---2400)
  - [2401 - 2500](#2401---2500)

代码库地址：  
[https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/2001-2500](https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/2001-2500)

## 2001 - 2100

2001 Number of Pairs of Interchangeable Rectangles

题意：给定n个矩形的长和宽，如果长宽比相同，则视为<b>等比例</b>。请求出等比例的<b>矩形对数</b>。

难度：medium

解法：我在这题尝试打开了<b>Copilot</b>，然后<b>tab一下</b>就全文背诵了。不得不说<b>做题家就是这样被消灭的</b>。你做的事情如果<b>机械重复</b>，不管曾经这件事情多么<b>“脑力密集”</b>，现在都变成<b>体力活儿</b>了。回到这题，本身确实不难。针对`w/h`进行哈希计数，但注意用<b>最简分数</b>，而不要用<b>浮点值</b>，避免出现精度问题。写一个<b>gcd函数</b>，用于约分。统计对数，用`C(n,2)=n*(n-1)/2`计算。总代价`O(n)`。

<hr>

2002 Maximum Product of the Length of Two Palindromic Subsequences

题意：给定字符串s，请从中选出两个不相交（没有共用字符）的<b>回文子序列</b>，使得它们的长度`n1*n2`最大。

难度：medium

解法：在没看数据量时，就判断这题<b>比较难</b>，除了暴力搜好像没什么思路。一看数据量，<b>果然非常小，暴力搜吧。</b>在给定数据量下，用位操作<b>稍微提提速</b>也可以，但差别不大。总代价`O(2^n)`。

<hr>

2006 Count Number of Pairs With Absolute Difference K

题意：给定数组nums，请求出`|nums[i]-nums[j]|==k`的对数。

难度：easy

解法：水题，<b>哈希计数</b>即可。对于当前元素`nums[i]`，查询`mm[nums[i]-k]+mm[nums[i]+k]`，总代价`O(n)`。

<hr>

2011 Final Value of Variable After Performing Operations

题意：给定变量X，初始值为0。现在执行一些`++、--`操作，请求出最终值。

难度：easy

解法：水题。

<hr>

2013 Detect Squares

题意：请设计一个数据结构，可以向其中添加点`(x,y)`。给定一个查询点`(qx,qy)`，可以在其中查找三个点使得这四点组成一个xy轴对齐的<b>正方形</b>，并返回满足要求的<b>不同正方形的个数</b>。重复点视为不同点。

难度：medium

解法：对于给定点`(qx,qy)`作为一个角，我们可以尝试枚举<b>对角</b>`(x,y)`。那么剩余两个角就是确定的，`(qx,y)`和`(x,qy)`，而且`abs(qx-x)==abs(qy-y)`。枚举对角的代价是`O(n)`，剩余两个角都可以`O(1)`代价查出。对于点的存储，我们可以用<b>双层哈希表</b>，`mx[x][y]=cc`表示`(x,y)`的个数；`my[y][x]=cc`表示`(x,y)`的个数。这样我就能从x、y坐标快速找出<b>某个点的个数</b>。以本题的数据量，n个点进行m次`count()`查询，总代价是`O(mn)`，可以接受。对于某些编程语言，可以直接用`mm[(x,y)]`的形式进行哈希，这样就更方便了。

<hr>

2016 Maximum Difference Between Increasing Elements

题意：给定数组nums，如果`i<j,nums[i]<nums[j]`，请求出`max(nums[j]-nums[i])`。

难度：easy

解法：题意很明确，数据量也很小，<b>直接枚举</b>即可。总代价`O(n^2)`。当然，你如果想找个<b>优化解法</b>，也不难。我们找出<b>后缀max</b>，那么答案就是`max(后缀max-nums[i])`，总代价`O(n)`。反过来，用<b>前缀min</b>道理也是一样的。

<hr>

2022 Convert 1D Array Into 2D Array

题意：给定一维数组，请按照<b>行优先</b>顺序，转为m x n二维数组。

难度：easy

解法：这就是<b>reshape、resize</b>功能，<b>numpy</b>里的最常用功能。n维数组在计算机里存储，其实就是按`n-1、n-2、...、0`维这么存的。我们说<b>“行优先（row-major）”</b>其实指的是我`a[i][j]`<b>第一个下标</b>取的是<b>i行</b>。

<hr>

2023 Number of Pairs of Strings With Concatenation Equal to Target

题意：给定一组数字串nums，给定一个目标串target。请求出`nums[i]+nums[j]==target`的对数。

难度：medium

解法：其实是不是<b>数字串</b>完全<b>无所谓</b>。我们只关心<b>前缀匹配、后缀匹配</b>。我针对每个串，和target比较，判断是否为前缀、长度多少；是否为后缀、长度多少。那么对于<b>长度t的target</b>，我需要找出`pref+suf==target,len(pref)+len(suf)==t`这样的情况。针对前缀lp、后缀ls进行计数，然后求出`sum(mp[lp]*ms[t-lp])`，但是要减去<b>一种特殊情况</b>。就是一个串<b>同时是前缀、后缀</b>的情况，比如`'77'+'77'='7777'`。总代价`O(n)`。

<hr>

2024 Maximize the Confusion of an Exam

题意：给定一个长度为n的TF串。你可以选择至多k个值进行修改。请求出能得到的最长的<b>单值子串长度</b>。

难度：medium

解法：现在看来，一眼<b>滑动窗口</b>。但我当年好像想了很久才想明白。我们可以考虑把T改为F，找最长的F串；或者把F改为T，找最长的T串。总之，都是找<b>y个数不超过k个</b>的最长子串，把y改为x，就变成全x串。写一个`slide()`函数，然后执行两次`return max(slide(s,'T','F'),slide(s,'F','T'))`即可。总代价`O(n)`。

<hr>

2027 Minimum Moves to Convert String

题意：给定XO串s，每次你可以选<b>连续3个字符</b>转为O。请问至少多少次，能把s变成<b>全O</b>？

难度：easy

解法：水题。

<hr>

2028 Find Missing Observations

题意：你观察了`n+m`次<b>6面色子</b>的结果，但<b>n次记录丢失了</b>，只剩m次。你还记录了`n+m`次的<b>均值</b>。现在给定m次记录、平均值mean、n，请给出一种<b>可能的n次记录</b>。如果无解，则返回空数组。

难度：medium

解法：`mean*(n+m)-sum(rolls)`，这就是n次的总和。按这个总和，<b>平均分配一下</b>就行了。如果平均下来发现`<1`或者`>6`，则无解。总代价`O(n)`。其实基本算`O(1)`，只是最后<b>生成结果</b>需要`O(n)`代价。

<hr>

2032 Two Out of Three

题意：给定数组nums1、nums2、nums3，请求出至少在<b>其中两个数组</b>出现的值。

难度：easy

解法：先转为<b>集合</b>s1、s2、s3，然后`list((s1&s2)|(s2&s3)|(s3&s1))`。

<hr>

2033 Minimum Operations to Make a Uni-Value Grid

题意：给定m x n矩阵，每次你可以选任意元素，+x或-x。请问至少多少次操作，能把矩阵变为<b>单值</b>。返回最小次数，如果做不到则返回-1。

难度：medium

解法：比如我们选一个val，把所有元素都变为val。那么总代价就是`sum(|a[i][j]-val|)/x`，也就是<b>差值的绝对值求和</b>。如果你之前见过，可能知道这个的<b>最优解就是中位数</b>。不知道的话，就要<b>走点弯路</b>了。对于中位数，可以通过排序（或者quickSelect算法）求出。得到中位数以后，按照上面提到的公式，求出结果即可。总代价`O(mnlog(mn))`。此处还要注意，如果存在`(a[i][j]-min_val)%x!=0`，那就<b>无解</b>。因为你每次<b>只能`+-x`</b>。<b>一切变化</b>，都必须是x的倍数。

<hr>

2037 Minimum Number of Moves to Seat Everyone

题意：有n个同学和n个板凳。同学位置是`students[i]`，板凳位置是`seats[i]`。现在板凳位置固定，每次允许你选一个同学，移动`+-1`格。请问至少多少次，才能让每个同学各坐到一个板凳？

难度：easy

解法：把板凳按位置<b>排序</b>，把同学按位置<b>排序</b>，然后<b>按顺序分配</b>，计算距离即可。为什么<b>按顺序</b>就可以？因为你<b>交换</b>两个同学的位置，这个<b>“交叉分配”</b>只可能导致总距离<b>变大或者保持相同</b>，而<b>不可能变小</b>。总代价`O(nlogn)`。不用想复杂，easy难度这就够了。人生没有<b>难度标注</b>，但题目有，这本身就是重要提示。

<hr>

2038 Remove Colored Pieces if Both Neighbors are the Same Color

题意：有个长度为n的AB串，表示AB两种颜色的棋子。Alice和Bob轮流拿走棋子。如果存在AAA，则Alice拿走中间的A；如果存在BBB，则Bob拿走中间的B。如果某人<b>无法继续</b>，则另一方赢得比赛。请判断Alice是否必胜？

难度：medium

解法：这不太像个博弈论问题，因为A和B各自是<b>完全不相干</b>的。比如AAAAA、BBBB，那么A一定可以拿3次，B一定可以拿2次。各自做什么，都不会影响对方的决策。所以我在注释里写了句`# what's there to be optimal?`，这就没什么可“最优”的，对吧？统计双方能拿的个数，如果`ca>cb`，就是A赢，否则B赢。鉴定为专门<b>嘲讽智力题</b>的<b>智力题的智力题</b>，有一种<b>幽默的幽默感</b>。

<hr>

2039 The Time When the Network Becomes Idle

题意：有n个服务器组成的<b>全连通无向图</b>，编号`0~n-1`。已知<b>直连的两个服务器</b>uv之间，可以通过<b>1s</b>传递一次消息。0号是<b>主服务器</b>，其他都是<b>数据服务器</b>。在0时刻，所有数据服务器都向0号机发送请求，请求按照<b>各自的最短路径</b>前进，到达0号后，瞬间处理完。反馈消息按照<b>原路返回</b>，直到到达各自机器。已知每个数据服务器有等待时间`paitence[i]`，<b>每经过</b>`patience[i]`时间如果没有收到反馈，则重发一条，直到收到反馈为止。请求出所有消息都发完，所有服务器<b>变为空闲</b>的时刻。

难度：medium

解法：这题挺难，首先<b>读懂题目</b>就很费劲。当然这题本身也很有意义，这是在给你讲一个<b>广播网络、失败重传机制</b>的问题。这是计算机网络<b>实际处理的问题</b>。我忘了为什么给这题<b>点了个踩</b>，可能是嫌题目<b>太啰嗦了</b>，啰嗦得出奇。问题的大致模型，我想你已经看懂了。无向图，最短路径。<b>我发，你回。你还没回，我就一直发。</b>直到所有人都<b>发完了，回完了</b>。那么我们先通过BFS，把<b>单源最短路径</b>求出来。比如最短路径是5，耐心值是3。那么来回需要的时间是10，在10的过程中，我在[3,6,9]时刻进行了重发。按这个时间，分情况计算重传次数，以及最后一条消息的到达时间。就这都要分3种情况讨论，我懒得细说了，看代码吧。这个破题，明明是medium难度，复杂程度令人无语。<b>难怪我会点踩。</b>总代价`O(V+E)`。当然，还是要说一句，能把<b>计算机网络</b>学明白的人，都是<b>大佬</b>。实际的网络协议比这个还复杂一万倍，处理的各种<b>拥塞、限流、乱序、重传</b>等问题，难。

<hr>

2042 Check if Numbers Are Ascending in a Sentence

题意：给定一个英文句子，提取其中的整数，判断是否严格递增。

难度：easy

解法：<b>字符串处理</b>，找出其中的数。这个可以用<b>正则匹配</b>一次找出来。`re.findall(r'\d+',s)`，转为整数数组，判断递增即可。总代价`O(n)`。

<hr>

2043 Simple Bank System

题意：设计一个简易的<b>银行系统</b>，支持存款、取款、转账。有n个账户，用`balance[i]`表示。现在给定一些交易，如果交易不会导致透支，则执行并返回true；如果会透支，则忽略并返回false。

难度：medium

解法：<b>题意很明确</b>，按题意指定的方式，模拟整个过程即可。每种操作的代价都是`O(1)`。注意检查转出、取款时的<b>余额是否足够</b>，不够则返回false。


<hr>

2044 Count Number of Maximum Bitwise-OR Subsets

题意：给定数组nums，请求出其中子集的<b>最大按位或</b>的值max_or。并求出等于这个max_or的不同子集的个数。

难度：medium

解法：一眼暴力枚举，看了下数据量，果然猜对了。<b>暴力枚举</b>即可。总代价`O(2^n)`。

<hr>

2045 Second Minimum Time to Reach Destination

题意：有一个无向图，你需要从1点到达n点。给定一些边`[u,v]`，每条边的权重都是time，代表<b>time分钟</b>。但事情没这么简单，有红绿灯。你只能在绿灯时<b>开始移动</b>。且红绿灯<b>每change分钟</b>变一次，<b>0时刻</b>是绿灯。如果允许你在多次访问任意点、任意边，但不能违反<b>红绿灯规则</b>。请求出从1到达n的<b>第二短时间</b>。

难度：hard

解法：这题也相当复杂，已经加了个<b>红绿灯</b>，还让你求<b>第二短</b>。因为我可以反复访问任何点、任何边，我考虑用DFS去处理。但发现容易陷入死循环。既然DFS不好做，而且涉及最短路，那我就用<b>最小堆+BFS</b>好了。对于第二短，我们可以通过<b>修改终止条件</b>来满足。本来是<b>搜到就终止</b>，现在改成<b>搜到第二个就终止</b>。至于红绿灯等待问题，则可以通过判断当前时刻cur是不是红灯，如果是<b>红灯</b>，则要等待到<b>下一个绿灯</b>才能<b>出发</b>。因为我可以重复访问<b>任意点任意边</b>，这里就不需要<b>`visited`判断</b>了。总代价应该还是`O(V+E)`。因为我找的是<b>第二短路径</b>，至多比最短路径重复一遍，`*2`也还是<b>同复杂度</b>。这个hard是<b>真hard</b>，又难又麻烦。

<hr>

2046 Sort Linked List Already Sorted Using Absolute Values

题意：给定链表，这个链表按照<b>绝对值</b>升序排列。请将其按实际值升序排列。

难度：medium

解法：付费题。分离出<b>负数和非负数</b>两个链表l1、l2。那么结果就是`reverse(l1)+l2`。负数是<b>倒序</b>的，非负数是<b>顺序</b>的。那么我只需要O(n)操作，不用再进行排序。总代价`O(n)`。

<hr>

2047 Number of Valid Words in a Sentence

题意：给定一个英文句子，请判断其中合法单词的个数。合法单词可以是纯`a~z`，也可以<b>中间</b>带有`-`连字符，不能包含数字。注意句子末尾<b>可能有标点</b>，也可能没有。

难度：easy

解法：很无聊的一题。可以直接<b>正则匹配</b>，也可以split之后，手工检查。

<hr>

2049 Count Nodes With the Highest Score

题意：有一个二叉树，节点编号`0~n-1`。用`parents[i]`<b>父节点数组</b>的形式表示。其中0点是根，`parents[0]=-1`。现在我们考虑节点i，如果把i连接的边删除，则会分成几个不同的子树，我们把分成所有子树的节点个数乘起来，作为`scores[i]`。请求出`scores[i]==max(scores)`的个数。

难度：medium

解法：在给定的数据量下，我们需要一个`O(n)`的解法。其实很容易想，我先parents数组，把这个二叉树<b>重建起来</b>。然后用<b>二叉树</b>的形式，做<b>后序遍历</b>。统计出cc_left、cc_right，如果等于0表示<b>空子树</b>，忽略0值。那么<b>头顶</b>那棵<b>剩余的子树</b>，大小就是`n-cc_left-cc_right`。把其中的非零值乘起来，就是`scores[i]`。这个统计过程对于每个节点都是O(1)代价得到的，因此总代价`O(n)`。得到scores数组后，求`max_val`然后统计`==max_val`的个数即可。总代价`O(n)`。其实你也不需要构建二叉树，用<b>无向图</b>的形式，直接从0开始搜索，结果是一样的。

<hr>

2050 Parallel Courses III

题意：1136的变体。给定n门课，完成每个课的时间是`time[i]`。存在一些前置顺序`[x,y]`，表示必须<b>先完成x才能学y</b>。请求出至少多长时间，才能完成所有课。对于没有前置关系的课，你可以<b>同时学习多门</b>。

难度：hard

解法：这题的前两题我都没做，这是第三题了。就当一道<b>新题</b>吧。这题当然是个<b>有向图</b>的图论问题。有前置顺序，那很容易想到<b>拓扑排序</b>，先后关系嘛。我们给拓扑排序加一个time计算的逻辑。以<b>入度为0</b>的点作为<b>起始点</b>，起始`t=0`。随着往后走，累加`time[i]`<b>越变越大</b>。对于某个点`i`，可能存在<b>多个前置</b>，也就是通过<b>不同路径</b>到达`i`。那么不同路径的<b>路径和</b>当然<b>有大有小</b>，我们需要取这些路径的`max()`，也就是<b>最晚时间</b>。总结一下思路，就是<b>拓扑排序BFS+路径和取max</b>。总代价`O(V+E)`。

<hr>

2053 Kth Distinct String in an Array

题意：给定字符串数组arr，请按出现顺序，找出其中<b>第k个唯一值</b>。如果不足k个，则返回空串。

难度：easy

解法：先<b>哈希计数</b>，找出唯一值。然后再遍历一次，找出第k个唯一值。

<hr>

2054 Two Best Non-Overlapping Events

题意：给定一些事件，格式为`[s,e,v]`表示s开始、e结束、价值为v。请选出<b>至多两个</b>不重叠的事件，使得价值之和最大。

难度：medium

解法：先按照`[s,e]`二维进行<b>排序</b>，对于每个`[s[i],e[i]]`，我都按照`bisect_right(arr,e[i])`查找查找<b>最小的`s[j]`</b>。那么<b>从j以后的所有事件</b>，都不会产生冲突。可以用一个后缀max数组，记录v[j:n]的最大值。以`O(n)`代价进行预计算，之后可以`O(1)`查询。那么对于i位置，可得到的最大值就是`v[i]+max(v[j:n])`。排序和<b>n次二分查找</b>的代价都是O(nlogn)，因此总代价`O(nlogn)`。注意，题目说至多两个，还要考虑<b>一个事件</b>的情况。

<hr>

2057 Smallest Index With Equal Value

题意：给定数组nums，请找出最小的下标i，使得`i%10==nums[i]`。如果不存在则返回-1。

难度：easy

解法：水题。

<hr>

2058 Find the Minimum and Maximum Number of Nodes Between Critical Points

题意：给定链表，如果一个点<b>小于前后点</b>或者<b>大于前后点</b>，则称为<b>关键点</b>。请求出两个关键点的最大、最小距离。

难度：medium

解法：先找出关键点的位置`crits`。那么`min=min(crits[i]-crits[i-1])`，`max=crits[n-1]-crits[0]`。总代价`O(n)`。

<hr>

2062 Count Vowel Substrings of a String

题意：给定字符串s，请求出只包含`aeiou`且五个字符都有的子串的个数。

难度：easy

解法：以这个数据量，<b>直接枚举</b>也可以。如果要高效一点，那就滑动窗口+哈希计数吧。我选择直接枚举了，可以用位操作标记一下`aeiou`是否出现。总代价`O(n^2)`。

<hr>

2063 Vowels of All Substrings

题意：给定字符串s，请求出<b>所有子串</b>中，`aeiou`个数的总和。

难度：medium

解法：把问题<b>反过来看</b>，我们考虑每个`s[i]`在<b>多少个子串</b>中出现。比如`s[i]`，那么左边有`i`个，右边有`n-1-i`个，那么两边相乘，总共有`(i+1)*(n-i)`个子串。把所有元音的位置，按这个计算方式，累加起来，就是答案。总代价`O(n)`。这题的<b>思维</b>很好，一个问题你从<b>不同角度思考</b>，难度可能完全不同。

<hr>

2064 Minimized Maximum of Products Distributed to Any Store

题意：有n个商店，m种商品。m种商品的量分别是`quantities[i]`。你需要把所有商品分配到n个商店，要求每个商店只能有<b>一种商品</b>，数量是`stores[i]`，且要求`max(stores[i])`最小。请求出这个最小值。

难度：medium

解法：还是很经典的<b>minimax问题</b>，对这个`min(max(stores[i]))`直接做<b>二分搜索</b>。判断依据是，对于某个值x，我能否完成一种<b>分配方案</b>，使得`max(stores[i])<=x`。二分到<b>恰好x-1不行，x行</b>，则x就是答案。每次二分判断，相当于<b>尝试一次分配</b>，代价是`O(n)`。因此，总代价`O(nlog(int))`。

<hr>

2068 Check Whether Two Strings are Almost Equivalent

题意：给定字符串s1、s2，如果两者所有字符的频率之差都不超过3，则称为<b>接近</b>。请判断s1、s2是否接近。

难度：easy

解法：水题，按题意进行<b>哈希计数</b>即可。

<hr>

2070 Most Beautiful Item for Each Query

题意：有n件商品，每件有`[p,b]`代表价格和颜值。你需要回答m个查询，每个查询的格式为，“<b>价格不超过</b>q的商品，<b>最大颜值</b>是多少”。

难度：medium

解法：很简单，<b>按照p值升序排列</b>，然后<b>针对b值求前缀max</b>。对于每次查询，执行`i=bisect_right(arr,q)-1`。如果`i==-1`，则返回0；如果`i>=0`，则返回`前缀max[i]`的b值。总代价`O(nlogn)`。

<hr>

2073 Time Needed to Buy Tickets

题意：有n个人排队，0是队头，n-1是队尾。`tickets[i]`表示第i人需要买的票数。但有个奇怪的规则，每人每次只能买1张。如果还没买够，则需要移动到队尾再排一次；如果买够了，则离开。已知每次买票需要花`1s`，请问第k个人买完票需要多少秒？

难度：easy

解法：我忘了这个数学模型在哪儿看过，<b>很眼熟</b>。按这题easy难度，<b>直接模拟</b>也可以的。有没有<b>更聪明</b>的解法？我们看例子`[5,1,2,8]`，比如我考虑i=2的情况。我们按照一个个离队的情况考虑`[5,1,2,8]->[4,1,7]->[3,6]->[3]->[]`。因此，其实我们可以将值进行排序。算算每个人离队时，总共花了多少秒。每次累加，就是`差值*剩余轮数`这么累加。但是最后一轮不能加满，因为第i人<b>不一定在队尾</b>，可能提前离开的。这个解法可以`O(nlogn)`解决。如果是纯模拟，总代价则是`O(n*max(tickets))。`我补了一份<b>优化解法</b>，AC验证过了。

<hr>

2074 Reverse Nodes in Even Length Groups

题意：给定链表，按照长度`1,2,3,...`进行分组。把所有<b>长度偶数</b>的组反转，返回调整后的链表。

难度：medium

解法：题意很明确，按要求处理即可。注意<b>边界case</b>。

<hr>

2078 Two Furthest Houses With Different Colors

题意：给定数组nums，请找出`(i,j)`，使得`nums[i]!=nums[j]`且`|i-j|`最大。返回这个最大差值。

难度：easy

解法：数据量很小，<b>直接枚举</b>即可。

<hr>

2079 Watering Plants

题意：有n个朵花，分别在`i=0,1,2,...,n-1`位置。-1位置有水源，你有一个容量`capacity`的水壶。每朵花需要的水量是`plants[i]`。现在从-1位置满水壶出发，<b>依次</b>给每朵花浇水。如果你的水不够了，则需要返回-1处装满水，而且不允许提前返回。如果移动1格需要1时间，请计算浇完所有花的<b>总时间</b>。

难度：medium

解法：题目<b>非常具体</b>，按题意模拟即可。整个过程是<b>100%确定的</b>，没有需要思考的事。总代价`O(n)`。

<hr>

2083 Substrings That Begin and End With the Same Letter

题意：给定字符串s，请求出开头结尾是<b>同一字符</b>的子串个数。

难度：medium

解法：付费题。单字符也算，这就有n个。然后考虑每种字符的出现次数cc。那么总共有`C(cc,2)=cc*(cc-1)/2`。因此，答案就是`n+sum(cc*(cc-1)/2)`。对于medium难度，这算是水题了。总代价`O(n)`。

<hr>

2085 Count Common Words With One Occurrence

题意：给定两个词表words1、words2，请求出在两个词表中都出现1次的单词。

难度：easy

解法：进行<b>哈希计数</b>，得到mm1、mm2，找出`mm1[w]==1,mm2[w]==1`的情况。总代价`O(n)`。

<hr>

2087 Minimum Cost Homecoming of a Robot in a Grid

题意：有一个m x n矩阵，机器人从`(sx,sy)`出发，要到达`(ex,ey)`。可以上下左右走，移动到i行代价为`rowCosts[i]`，移动到j列代价为`colCosts[j]`。请求出最小的总代价。

难度：medium

解法：这题太扯了，鉴定为<b>脑筋急转弯</b>。直接从sx到ex，从sy到ey即可。总代价`O(m+n)`。

<hr>

2088 Count Fertile Pyramids in a Land

题意：给定m x n的01矩阵，在其中统计正金字塔、倒金字塔的个数。金字塔按照`1,3,5,...`这样对称排列，<b>从上到下或者从下到上</b>。

难度：hard

解法：我们先考虑暴力枚举。如果我以每个`a[i][j]`为塔尖，向上或者向下枚举，那么一次枚举的代价就是`O(n^2)`，这太慢了。必然要减少重复计算，这就考虑到DP思想了。比如我考虑`dp[i][j]`为以`(i,j)`为塔尖的倒金字塔的最大层数。那么如果`a[i][j]==0`，则`dp[i][j]=0`；如果`a[i][j]==1`，则`dp[i][j]=min(dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1])+1`。你看，这个递推是`O(1)`的，这样总代价就降到`O(n^2)`了。正金字塔、倒金字塔的计算，都采用这个方式，不过<b>递推方向</b>是反过来的。看了下我<b>以前的代码</b>，和这个思路类似，但不完全相同。我也看不懂到底在做什么。

<hr>

2089 Find Target Indices After Sorting Array

题意：给定数组nums和目标值target。请将nums排序后，返回target值所有位置，升序排列。

难度：easy

解法：<b>先排序，然后二分查找</b>即可。顺序查找也行，反正<b>排序的代价</b>占大头。总代价`O(nlogn)`。

<hr>

2091 Removing Minimum and Maximum From Array

题意：给定数组nums，所有值都不同。请先找出min和max，然后删除它们。但要求必须从nums开头、结尾不断删除元素，不能直接删除这两个值。请求出最小的删除次数。

难度：medium

解法：找出min和max对应的位置i、j，不妨假设`i<j`。那么答案就是`min(j+1,n-i,i+1+n-j)`。要么从左，要么从右，要么两边删。总代价`O(n)`。

<hr>

2094 Finding 3-Digit Even Numbers

题意：给定数组digits，元素都是0~9的数字，可能有重复。请从中选出3个，组成<b>`>=100`的3位偶数</b>。请返回所有可能的<b>唯一值</b>，按<b>升序</b>排列。

难度：easy

解法：不要直接暴力搜索，先把digits转化为<b>哈希计数</b>，而且计数超过3就按3处理，因为你<b>只需要3位数</b>。接下来，搜索枚举即可。注意最后一位是<b>偶数</b>。结果按`sorted(set())`处理。

<hr>

2095 Delete the Middle Node of a Linked List

题意：给定n长度链表，删除中间节点。中点按照`floor(n/2)`处理。

难度：medium

解法：可以用<b>快慢指针</b>的方法定位到中点，或者说<b>中点的前一点</b>。这个更方便删除。总代价`O(n)`。

<hr>

2096 Step-By-Step Directions From a Binary Tree Node to Another

题意：给定二叉树和其中两个节点s、t。请求出从s到t的路径，用`ULR`表示<b>上左右</b>。

难度：medium

解法：首先，这个路径是<b>唯一的</b>，不存在“最短路”的说法，除非你走重复路。我们可以通过遍历，分别得到<b>从根到s、从根到t</b>的两条路径ps、pt。那么ps、pt的公共前缀部分，你可以删掉。比如例子`ps=0010,pt=011101`，公共前缀是`0`，这个删掉。剩下部分是`ps=010,pt=11101`，你需要`UUU`，然后`RRRLR`。那么答案就是`UUURRRLR`。看懂这个例子，就知道该怎么做了。总代价`O(n)`。

<hr>

2097 Valid Arrangement of Pairs

题意：给定一些数对`(x,y)`，请将其排序，使得相邻的数对都满足`y[i]==x[i+1]`，也就是<b>“首尾相接”</b>。给定数据保证<b>一定有解</b>。

难度：hard

解法：起初我以为是个<b>图论题</b>，但看了<b>数据量</b>，想了下思路，又觉得不是。后来想了下，还是图论。比如我从某点出发，走一条路径。如果能把<b>所有边都用完</b>，这就是答案。这就是<b>欧拉路径</b>，每条边恰好用一次。查了资料又想了想，最后用了一个<b>特殊判定条件</b>`outd[x]-ind[x]==1`，<b>出度-入度等于1</b>。满足这个条件的点，可以作为<b>遍历的起点</b>。但这样的点不一定存在，比如一个环路就不存在这种点，这时我们<b>随便选一个点</b>就行了。剩下就是常规的<b>有向图遍历</b>了。因为这个遍历是一定会成功的，因此<b>只搜索不回溯</b>。一边遍历，<b>一边删除图中的边</b>，并把边加入<b>结果集res</b>中。这叫<b>不走回头路</b>。遍历完成时，图<b>删光了</b>，结果也<b>填满了</b>。总代价`O(n)`。这题确实难，主要难点在于你首先要<b>建图</b>，然后得知道从<b>哪个点</b>开始遍历。

<hr>

2099 Find Subsequence of Length K With the Largest Sum

题意：给定数组nums，请找出长度为k的子序列，使得求和最大。返回<b>子序列</b>。

难度：easy

解法：先按照`(val,i)`排序，找出<b>k个最大的值</b>。把值取出来，再按照`(i,val)`排序，把顺序还原过来。这样就得到按<b>原顺序排列</b>的<b>最大的k个值</b>了。总代价`O(nlogn)`。

## 2101 - 2200

2102 Sequentially Ordinal Rank Tracker

题意：请设计一个数据结构，可以添加格式为`[名称,分数]`的数据，且第i次查询时，返回按`[-分数,+名称]`顺序的第i个值。

难度：hard

解法：需求本身很明确，那么关键就是<b>存储和排序</b>的<b>效率</b>了。分数降序、名称升序。如果我们直接以数组存储，插入有序，则插入代价是`O(n)`，查询`O(1)`。太慢，会超时。如果顺序插入，每次执行快速选择算法，则插入`O(1)`，查询`O(n)`。还是太慢。既然我们需要查询第i个，那么我们可以考虑用堆，但又<b>不能丢失数据</b>。因此，用两个堆，<b>最大堆+最小堆</b>。最大堆存前i个，最小堆存剩余的。我们总是保持最大堆的元素数量等于`i+1`，这样堆顶元素就是我们要的结果。插入过程中，左手倒右手，保持两个堆的大小顺序，以及最大堆的元素个数即可。这样插入代价是`O(logn)`，查询代价`O(1)`。讲了这么多，一看我的老代码，居然是有序插入的解法。就这居然还过了，看来<b>测试数据比较水</b>。看了下评论区，很多人都想到了<b>两个堆的解法</b>。

<hr>

2103 Rings and Rods

题意：有一些红绿蓝的环，套在10个柱子上。按照类似`R3`的格式，表示红环在3号柱子上。现在给定一个这样的字符串，请求出<b>集齐了3种颜色</b>的柱子的个数。

难度：easy

解法：水题，字符串解析即可。

<hr>

2104 Sum of Subarray Ranges

题意：给定一个数组，我们定义它的<b>范围</b>为`max(a)-min(a)`。给定数组nums，请求出它的所有子数组的<b>范围之和</b>。

难度：medium

解法：首先，`O(n^2)`的解法非常容易。我们用max、min两个值，枚举i位置，随着j向前移动，不断更新最大最小值，并累加`max-min`。每次更新的代价是O(1)，因此总代价`O(n^2)`。这也符合题目的暗示，但这题如果要动动脑子，应该能在`O(n)`时间，用类似<b>单调栈</b>的思路解决。往下读题目，果然有这句话。可以参考之前<b>“Next Greater Element”</b>的做法，细节就不说了。对于每个nums[i]，我们考虑它左边、右边第一个`>=它`的元素<b>有多远</b>，那么它就能做<b>多大范围的max</b>。对于min值，反之亦然。总代价`O(n)`。不过我写了个`O(n)`的版本，结果始终不对。可能有些细节没想明白。

<hr>

2108 Find First Palindromic String in the Array

题意：给定一些字符串words，找出第一个回文串。

难度：easy

解法：水题。

<hr>

2109 Adding Spaces to a String

题意：给定一个字符串s，和一些位置spaces。请在对应位置<b>插入空格</b>，返回修改的字符串。

难度：medium

解法：思路上没有难度，唯一的问题就是<b>字符串比较长</b>。你要考虑<b>插入移位</b>的问题。这个也好办，我们<b>从后往前</b>插入，这样每次移位的代价就是`O(1)`，而不是`O(n)`了。对于每个字符，注意计算好它的<b>偏移量</b>，比如前面有<b>k个空格</b>，那么偏移量就是<b>+k</b>。总代价`O(n)`。

<hr>

2110 Number of Smooth Descent Periods of a Stock

题意：给定数组prices，请求出`长度>=1`的<b>公差为-1</b>的<b>等差数列</b>个数。

难度：medium

解法：对于长度为n的等差数列，从中可以找出`n*(n+1)/2`个子数列。按这个方式统计求和即可。总代价`O(n)`。

<hr>

2113 Elements in Array After Removing and Replacing Elements

题意：给定一个数组nums，长度n。我们按照<b>周期2n</b>做一个循环操作。前n次，逐个从开头删除元素；后n次，逐个把刚才删除的元素依次补回来。比如`[1,2,3]`按照`[1,2,3]->[2,3]->[3]->[]->[1]->[1,2]->[1,2,3]`循环变化。0时刻数组保持完整，给定一些查询，按照`[t,i]`格式，请求出t时刻第i个元素的值。如果i越界，则返回-1。

难度：medium

解法：付费题。既然是<b>周期变化</b>，而且这个变化也不复杂，<b>找找规律</b>即可。你甚至<b>直接`O(n)`代价模拟</b>也是可以的。

<hr>

2114 Maximum Number of Words Found in Sentences

题意：给定一些英文句子，请求出单词的最大个数。

难度：easy

解法：水题，`len(split())`即可。

<hr>

2115 Find All Possible Recipes from Given Supplies

题意：做菜，有<b>菜谱和材料</b>，菜谱可能包含<b>其他菜谱</b>。现在给定一些<b>材料</b>，不限量供应。请问你能做出多少道菜？

难度：medium

解法：显然，是个<b>有向图的搜索问题</b>。那么应该<b>正搜还是反搜</b>？其实都可以，但更建议反搜。我们可以建立`材料->菜谱`反向图，然后从<b>给定的材料</b>作为搜索起点。执行BFS，总是把入度为0的节点加入队列，继续搜索。如果一个<b>菜谱的入度为0</b>，则代表<b>材料集齐了</b>。对于`A->B,B->A`这种情况，我们无所谓。因为入度始终不为0，<b>成环了</b>。总结一下，就是建立反向图，执行<b>类似拓扑排序</b>的算法。总代价`O(E)`。

<hr>

2119 A Number After a Double Reversal

题意：给定整数，将其数位反转再反转。反转时去掉前置0，请判断反转两次是否能与自身。

难度：easy

解法：水题，看<b>末尾有没有0</b>就行了。

<hr>

2120 Execution of All Suffix Instructions Staying in a Grid

题意：给定一个n x n网格，机器人从`[sx,sy]`出发。有一个长度为m的指令序列，机器人可以从第i个开始执行，<b>直到末尾</b>。但如果执行到某条会导致<b>出界</b>，则<b>停止</b>。针对每个执行i，请求出<b>从这条开始</b>，能执行的指令条数。

难度：medium

解法：题目问的是后缀，我们显然应该后后往前倒推。比如我考虑第i条指令执行的最终位置是`[xi,yi]`，第i-1条是L向左，那是不是代表第i-1条的最终位置就是`[xi,yi-1]`？并不是，你需要考虑<b>在中途</b>，是否有可能出界。因此我们要考虑的，其实是`minx、maxx、miny、maxy`。或者说，要记录机器人到达过的，最上、最下、最左、最右的<b>具体位置</b>，不仅是min、max值。然后根据第i-1条指令，比较是否越界。这样总体代价可以做到`O(m)`。不过越想越觉得<b>费劲</b>，最终还是放弃了。暴力解法，总代价`O(m^2)`直接模拟搞定。

<hr>

2124 Check if All A's Appears Before All B's

题意：给定一个ab串，请判断是否存在b在a前面的情况。

难度：easy

解法：水题，判断<b>“ba”</b>是否存在即可，总代价`O(n)`。

<hr>

2125 Number of Laser Beams in a Bank

题意：给定m x n的01矩阵bank，求出每行1的个数，去掉0值，得到数组nums。求出`sum(nums[i]*nums[i+1])`。

难度：medium

解法：题目其实非常简单，但描述<b>太啰嗦且充满迷惑性</b>。我直接把<b>关键思路</b>翻译出来，不写原题目了。总代价`O(mn)`。

<hr>

2126 Destroying Asteroids

题意：给定一些小行星。如果`星球质量>=小行星质量`，则可以<b>吃掉它</b>，否则就会被摧毁。如果可以<b>调整顺序</b>，请问星球能否吃掉所有小行星？

难度：medium

解法：排序即可。这个模型就是那个<b>Hero War游戏</b>的基本模型。`if x>=y: x+=y`，这样。

<hr>

2129 Capitalize the Title

题意：给定一些单词，`长度<3`则转小写；`长度>=3`则首字母大写。

难度：easy

解法：水题。

<hr>

2130 Maximum Twin Sum of a Linked List

题意：给定长度n的节点，n为偶数。我们定义`(1,n)(2,n-1),...`为<b>双子节点</b>，节点相加称为双子和。请求出最大双子和。

难度：medium

解法：可以在中点处分成两个链表，把<b>后半部分反转</b>。当然，也可以用一个<b>额外数组</b>保存求和，这样就不用反转链表了。总代价`O(n)`。

<hr>

2133 Check if Every Row and Column Contains All Numbers

题意：给定n x n方阵，请判断每行每列是否都包含了`1~n`。

难度：easy

解法：这个不是<b>幻方</b>，幻方还要求<b>两个对角线</b>。按要求检查即可。

<hr>

2134 Minimum Swaps to Group All 1's Together II

题意：1151的变体。给定一个01循环数组，你可以交换<b>任意元素任意次</b>。请问至少多少次，能<b>把1聚到一起</b>？

难度：medium

解法：这题我闹了个乌龙，把题读错了，以为交换必须是相邻的。循环数组，也就是说<b>类似`1100111`这种</b>也满足要求。因此，这等效于<b>把0聚到一起</b>。其实很简单，我们考虑1的个数n1、0的个数n0，`n0+n1==n`。那么我找<b>n1大小</b>的<b>1窗口</b>，我们希望窗口中<b>尽量都是1</b>。那么，其中<b>有多少个0</b>，我就要<b>交换多少次</b>。对0的情况，思路相同，反之亦然。因此，答案就是`min(min(n1窗口中0的个数),min(n0窗口中1的个数))`。总代价`O(n)`。

<hr>

2136 Earliest Possible Day of Full Bloom

题意：你有n盆花需要种。每盆分别需要`plantTime[i]`种植和`growTime[i]`自己生长。种植期间，你可以<b>分散时间</b>，但不能同一天种植多盆花。如果你可以合理安排顺序，请求出<b>所有花都开放</b>的最早时间。

难度：hard

解法：这个模型和打印机工作、任务调度的模型有点像。一般的原则是<b>小任务优先</b>。如果你先处理<b>繁重的大任务</b>，那更多的小任务就需要<b>等很久</b>。但要注意，这个<b>排序</b>是有讲究的。应该按`(-生长时间,+种植时间)`排序，我考虑了几种策略，这个策略是<b>试出来的</b>。<b>生长时间降序</b>，这样可以让生长时间更长的，先种下去。种植时间升序，这个就是<b>小任务优先</b>的原则。总代价`O(nlogn)`。这题很容易想到排序，但<b>排序策略</b>有点难想。hard就是难在这儿了。

<hr>

2138 Divide a String Into Groups of Size k

题意：给定字符串，请分成<b>长度k</b>的多个子串，如果最后一个不足k字符，则填充字符fill。

难度：easy

解法：水题。

<hr>

2139 Minimum Moves to Reach Target Score

题意：从1开始，每次你可以选择`+1`或者`*2`。`+1`次数无限，`*2`<b>至多k次</b>。请求出得到目标值target的最小次数。

难度：medium

解法：我们从target出发，<b>反着搜</b>。那么`-1`次数无限，`/2`至多k次。可以用`(当前值,剩余/2次数,已用次数)`表示搜索状态，<b>执行BFS</b>。剩下就不用说了。总代价介于`O(target)`到`O(log(target))`之间。

<hr>

2140 Solving Questions With Brainpower

题意：有n个问题，你需要<b>依次</b>回答。每个问题得分为points[i]，但如果你选择i问题，则需要跳过随后的`brainpower[i]`个问题。现在给定格式为`[points,brainpower]`的数据，请选择问题，使得<b>总分最大</b>。返回总分。

难度：medium

解法：显然题目要求你给出`O(n)`解法。那么我们考虑第i个问题，既然我需要跳过之后的b[i]个，那我肯定关心从`i+b[i]+1`到`n-1`这些问题，我能得到的最大总分，于是<b>DP思路</b>就有了。定义`dp[i]`为`p[i:n]`中，我们能得到的最大总分。那么`dp[i]=max(p[i]+dp[i+b[i]+1],dp[i+1])`，<b>从后往前</b>递推。

<hr>

2144 Minimum Cost of Buying Candies With Discount

题意：有n个糖果，如果你买2个，则可以免费拿走1个。但要求拿走糖果的价格，不能超过min(买的糖果)。请求出能<b>买走所有糖果</b>，需要准备的<b>最少金额</b>。

难度：easy

解法：排序，然后按照<b>买3、2拿1</b>的方式，三个一组这样处理。总代价`O(nlogn)`。

<hr>

2148 Count Elements With Strictly Smaller and Greater Elements 

题意：给定数组nums，请求出其中<b>非最大值、最小值</b>的元素个数。

难度：easy

解法：水题。

<hr>

2149 Rearrange Array Elements by Sign

题意：给定数组nums，长度2n，有n正n负。请进行排序，使得数组按照<b>“正负正负...”</b>交替顺序，且正数、负数内部均按照原本的<b>先后顺序</b>。

难度：medium

解法：题目还特地提示你，<b>不用in-place</b>。出题人算是<b>很厚道</b>了，不浪费大家的脑细胞。用一个<b>辅助数组</b>来存放即可。

<hr>

2150 Find All Lonely Numbers in the Array

题意：给定数组nums，请找出其中所有的孤独值x。要求是，`x`出现一次，且`x+1`、`x-1`没有出现。返回所有值。

难度：medium

解法：<b>哈希计数</b>，遍历两次即可。对于medium难度，这题有点过于简单了。

<hr>

2154 Keep Multiplying Found Values by Two

题意：给定数组nums，从original开始，不断在nums中查找这个值。如果存在，则`*2`继续找；如果不存在，则停止。请返回第一个不存在的值。

难度：easy

解法：存入<b>哈希表</b>再找就行了。

<hr>

2155 All Divisions With the Highest Score of a Binary Array

题意：给定01数组nums，允许你从`i~[0,n]`任意位置将数组分为左右两部分，两部分均<b>允许为空</b>。我们定义得分为`左边0的个数+右边1的个数`，请求出所有能得到<b>最大分数</b>的<b>i的位置</b>。

难度：medium

解法：我们先统计出<b>0的总数、1的总数</b>。然后从i=0开始，逐步右移。一边移动一边更新左0右1的统计。一边更新统计，一边比较得出max值并记录下标。单次更新的代价是`O(1)`，因此遍历的总代价是`O(n)`。

<hr>

2160 Minimum Sum of Four Digit Number After Splitting Digits

题意：给定四位数，请从中选数，组成两个整数，使得<b>和最小</b>。数位顺序可以随意调整。

难度：easy

解法：水题。

<hr>

2161 Partition Array According to Given Pivot

题意：给定数组nums和一个阈值pivot。请对nums排序，使得小于、等于、大于pivot的元素按照前中后顺序排列。要求三组中，每组的内部保持<b>原有顺序</b>。

难度：medium

解法：方法很多，比如你可以先统计三组的数量`n1、n2、n3`，算好<b>偏移量</b>。然后再遍历一次，把元素放入对应组的对应位置。你也可以<b>遍历三次</b>，每次处理一组。总之，都是需要一个<b>额外数组</b>作为<b>临时存放</b>的。总代价`O(n)`。

<hr>

2164 Sort Even and Odd Indices Independently

题意：给定数组nums，请对<b>奇数位置</b>降序排列，<b>偶数位置</b>升序排列。

难度：easy

解法：这个用python的slicing写法相当方便，属于<b>语法糖</b>的完美应用。`a[0::2]=sorted(a[0::2]) a[1::2]=sorted(a[1::2],reverse=True)`。

<hr>

2165 Smallest Value of the Rearranged Number

题意：给定整数num，请重排数位，使得值最小。不能有<b>前置0</b>。

难度：medium

解法：考虑下<b>正数、负数</b>各应该怎么处理。举例子，`10086、-9870`。

<hr>

2169 Count Operations to Obtain Zero

题意：给定整数x、y，如果`x>=y`，则`x-=y`，<b>反之亦然</b>。经过多少步，其中一个可以变为0？

难度：easy

解法：水题，直接按题意计算即可。

<hr>

2176 Count Equal and Divisible Pairs in an Array

题意：给定数组nums和整数k，请求出`nums[i]==nums[j]`且`(i*j)%k==0`的`(i,j)`对数。

难度：easy

解法：数据量很小，直接枚举也行。总代价`O(n^2)`。

<hr>

2177 Find Three Consecutive Integers That Sum to a Given Number

题意：给定整数nums，请找出<b>连续的3个数</b>，加起来等于num。如果不存在，则返回空数组。

难度：medium

解法：水题，而且<b>低质量</b>。

<hr>

2178 Maximum Split of Positive Even Integers

题意：给定一个值sm，请求出一种求和方式，使得求和等于sm，且所有数都是<b>不同的偶数</b>，而且<b>元素个数最多</b>。

难度：medium

解法：其实按照<b>贪心原则</b>考虑就行了，我按照`2,4,6,8,...`这样慢慢加`+2`，加到<b>总和超过sm</b>，就不能加了。剩下就不用说了，用一点点数学，可以`O(1)`求出这个最大值。当然，<b>最终结果的规模</b>是`O(sqrt(sm))`的。

<hr>

2180 Count Integers With Even Digit Sum

题意：给定整数n，请求出`[1,n]`内，<b>数位和是偶数</b>的个数。

难度：easy

解法：数据范围很小，<b>直接枚举</b>也行。总代价`O(nlogn)`。如果数据范围很大的话，这题还是有点难度的，会变成一个<b>数位DP题</b>。

<hr>

2181 Merge Nodes in Between Zeros

题意：给定链表，请把其中<b>连续的非零节点</b>，合并为一个节点，节点值等于<b>求和</b>。所有合并的节点<b>连起来</b>，作为一个新链表返回。

难度：medium

解法：题目很清晰，按要求实现即可。总代价`O(n)`。

<hr>

2182 Construct String With Repeat Limit

题意：给定字符串s和整数k。你可以从s中选出字符，调整顺序，得到一个串t。要求t中不能有<b>连续k个相同字符</b>，且t的<b>字典序最大</b>。返回t。

难度：medium

解法：我们先对s进行<b>字符统计</b>，然后按<b>贪心原则</b>，<b>从大到小</b>取字符即可。代码实现要<b>注意一些细节</b>，比如<b>字典序大</b>的字符，应该<b>尽快用完</b>。总代价`O(n)`。

<hr>

2185 Counting Words With a Given Prefix

题意：给定词表words和前缀pref，请求出匹配前缀pref的单词个数。

难度：easy

解法：水题。

<hr>

2186 Minimum Number of Steps to Make Two Strings Anagram II

题意：1347的变体。给定字符串s和t，每次你可以给s或t添加一个字符。请问多少次操作可以使s和t互为anagram？

难度：medium

解法：这次是添加字符，那么我们对s和t做<b>哈希计数</b>，得到ms、mt。对于每个字符c，我们都取`mx=max(ms[c],mt[c])`，给两边<b>补足</b>到这个max值。补的个数`2*mx-ms[c]-mt[c]`，就是要<b>添加的次数</b>，<b>求和</b>就是最终答案。总代价`O(n)`。

<hr>

2190 Most Frequent Number Following Key In an Array

题意：给定数组nums和值key。请求出在key值<b>下一个位置</b>出现的值里，<b>频率最高</b>的值。

难度：easy

解法：水题，但是题目<b>不知所云</b>，加大了理解成本。

<hr>

2191 Sort the Jumbled Numbers

题意：给定一种`0~9`的<b>映射方式</b>，请将数组nums中元素的值映射，并按照<b>映射后的值</b>，进行排序。返回新顺序下<b>nums排序结果</b>。

难度：medium

解法：x变为`tp=(mapped(x),x)`，<b>排序</b>后取出`tp[1]`。总代价`O(nlogn)`。

<hr>

2192 All Ancestors of a Node in a Directed Acyclic Graph

题意：给定<b>有向无环图</b>，节点编号为`0~n-1`。给定其中的边`[x,y]`，请求出每个点i的<b>所有祖先节点</b>。如果从j<b>存在路径</b>到达i，则j为i的<b>祖先</b>。

难度：medium

解法：因为是DAG，就不存在环了。那么我们应该怎么搜，才不会做<b>重复计算</b>（至少不能<b>低效重复</b>）？答案是用<b>拓扑排序</b>的思路。我们从<b>入度为0</b>的点开始，执行BFS。这次要额外加上一个<b>祖先点集ancestor</b>。用`(x点,x的祖先点集)`作为搜索方式。那么对于`x->y`，我<b>删除这条边</b>，给`ind[y]-=1`，同时`ancestor[y]|=ancestor[x]`。但是注意，只有在`ind[y]==0`的情况下，我才<b>把y加入队列</b>。这样，随着拓扑往下走，<b>祖先点集</b>也通过<b>求并集，越变越大</b>。总代价`O(V^2+E)`。这个`O(V^2)`是免不了的，因为<b>结果集</b>就有这么大。

<hr>

2194 Cells in a Range on an Excel Sheet

题意：按照<b>Office Excel</b>的行列命名方式，给定左上、右下坐标，请按照<b>列优先</b>的顺序，返回所有格子坐标。

难度：easy

解法：<b>格式转换</b>，然后循环遍历即可。

<hr>

2196 Create Binary Tree From Descriptions

题意：给定一些格式为`[父节点值,节点值,是否左指针]`，请重建整个二叉树。已知二叉树的所有节点值都唯一。

难度：medium

解法：对`值->节点`做好映射，然后按照父子关系、左右指针，一个个拼起来。没有父节点的，就是<b>根</b>。总代价`O(n)`。

<hr>

2200 Find All K-Distant Indices in an Array

题意：给定数组nums，整数值key和k。请找出所有下标i，使得在`[i-k,i+k]`范围内，存在`nums[j]==key`。返回所有i值，升序排列。

难度：easy

解法：先找出所有<b>key值的出现位置</b>，得到数组ai。然后i=[0,n-1],j=[0,len(ai)-1]。<b>双指针向前</b>，比较`i`值和`ai[j]`值是否在`[-k,+k]`范围内。总代价`O(n)`。

## 2201 - 2300

2201 Count Artifacts That Can Be Extracted

题意：给定n x n地图，其中一些<b>矩形区域</b>里有宝贝。给定这些矩形区域的左上、右下坐标`artifacts`和你要挖开的一些坐标`dig`。矩形区域<b>互不重叠</b>。如果矩形区域<b>所有格子</b>都被挖开，则可以得到宝贝。请求出你能得到的宝贝数量。

难度：medium

解法：方法很多，主要思路就是做一个`格子->宝贝`的映射，这样当你挖开`(x,y)`位置，可以把对应宝贝的`格子计数-1`。如果减到0，就代表这个宝贝<b>挖到了</b>。总代价`O(n^2+na+nd)`。

<hr>

2206 Divide Array Into Equal Pairs

题意：给定数组nums，长度2n。请判断能否分为n对，使得每对的元素相等，类似`(x,x),(y,y)...`这样。

难度：easy

解法：水题。<b>哈希计数</b>，如果<b>计数都是偶数</b>，就可以。

<hr>

2210 Count Hills and Valleys in an Array

题意：给定nums，如果i位置的左右第一个不等于`nums[i]`的值，都小于`nums[i]`，则称为<b>山顶</b>。同理，如果都大于`nums[i]`，则称为<b>山谷</b>。请统计山顶、山谷的总数。

难度：easy

解法：数据量很小，直接`O(n^2)`枚举也行。

<hr>

2215 Find the Difference of Two Arrays

题意：给定数组nums1、nums2，请求出nums1中出现，但nums2中未出现的值；以及nums2中出现，但nums1中未出现的值。均返回<b>唯一值</b>。

难度：easy

解法：其实就是<b>集合的减法</b>。类似`list(set(a)-set(b))`这样。

<hr>

2220 Minimum Bit Flips to Convert Number

题意：给定整数x和y，请求出反转二进制位，从x变成y的反转次数。

难度：easy

解法：`countOne(x^y)`。

<hr>

2221 Find Triangular Sum of an Array

题意：给定数组nums，不断执行相邻元素求和`(nums[i]+nums[i+1])%10`，每次求和元素个数-1，直到最后<b>只剩一个值</b>。返回最终结果。

难度：medium

解法：稍微做一下推算，不难求出<b>每个元素</b>总共被<b>加了多少次</b>。其实就是<b>杨辉三角，二项式定理</b>。这题求的是`C(n,k)%10`，因为10是合数，<b>乘法逆元</b>不一定存在的。所以还是用笨办法，直接<b>累加求和</b>好了。总代价`O(n^2)`。

<hr>

2222 Number of Ways to Select Buildings

题意：给定长度为n的01串s，你需要选出长度3的子序列，使得子序列等于010或101。请问有多少种选法？

难度：medium

解法：有好几种思路，比如我统计出<b>所有`0`的位置p0</b>。然后再遍历一次，如果我遇到`1`，则`1`的左边x个`0`，右边y个`0`，就就有`x*y`种组合。随着向右移动，这个更新的代价是`O(1)`，总代价`O(n)`可以求出`010`的个数。对于`101`的情况，思路完全相同，只不过01反过来。还有一种“考虑<b>i位置之前有多少个0/1</b>”的计数方式，这种思路更类似<b>DP</b>，但总体上差不多，代价也是`O(n)`。

<hr>

2224 Minimum Number of Operations to Convert Time

题意：给定格式为`HH:MM`的两个时间t1、t2。你需要把t1变为t2，每次你可以增加1、5、15、60分钟。请问<b>至少几次</b>能变过来？

难度：easy

解法：注意考虑越过`00:00`的情况，比如从23点到2点。这个<b>不需要做搜索</b>，按贪心原则，+1h、+15m、+5m、+1m这样处理就行了。

<hr>

2225 Find Players With Zero or One Losses

题意：给定一些比赛结果`matches`，以`[x,y]`表示<b>x赢y</b>一次。请统计<b>0次失败、1次失败</b>的队伍列表，按升序排列。

难度：medium

解法：题意很明确，按要求统计，然后对结果排序即可。其实<b>顺序枚举</b>就行，结果本来就是有序的。总代价`O(n+nm)`。

<hr>

2231 Largest Number After Digit Swaps by Parity

题意：给定整数num，你可以把<b>同偶</b>或者<b>同奇</b>的数位交换。请求出能得到的最大数。

难度：easy

解法：那就分别对值为<b>偶数、奇数</b>的数位按<b>降序排列</b>。

<hr>

2232 Minimize Result by Adding Parentheses to Expression

题意：给定一个格式为`x+y`的算式，其中x、y都是整数，你可以在其中添加一个括号，使得<b>结果最小</b>。比如`12+34`，结果为46，但如果变为`1(2+3)4`，则表示`1*(2+3)*4`，结果为20。请返回变换后的<b>算式</b>。

难度：medium

解法：虽然这种奇怪的写法，并不符合实际的<b>算式规则</b>，但我们姑且按题目说的做吧。以这个数据量，直接<b>暴力搜索</b>，找到最小的结果就行了。或者说，枚举<b>两个括号</b>的位置，然后计算结果。总代价`O(n^2*n)=O(n^3)`。

<hr>

2235 Add Two Integers

题意：给定x、y，请求出`x+y`。

难度：easy

解法：水题，<b>令人震惊</b>的水题。

<hr>

2236 Root Equals Sum of Children

题意：给定三节点的二叉树，请判断`root.val`是否等于`left.val+right.val`。

难度：easy

解法：水题，可能和2235是同一个作者。

<hr>

2239 Find Closest Number to Zero

题意：给定数组nums，请找出<b>和0最接近的值</b>。如果有多个，则返回较大值。

难度：easy

解法：数组是无序的，那就按照`abs(x)`比较即可。总代价`O(n)`。

<hr>

2240 Number of Ways to Buy Pens and Pencils

题意：你有total的钱，钢笔cost1一个，铅笔cost2一个。请计算你可以买钢笔、铅笔的个数`(n1,n2)`的种类数。你不用花光所有钱。

难度：medium

解法：`n1*cost1+n2*cost2<=total`的整数解个数，这算是个最基础的<b>线性规划</b>问题了。当然，没必要想复杂。直接<b>一层循环，枚举求和</b>就行了。总代价`O(total/max(cost1,cost2))`，线性的。

<hr>

2243 Calculate Digit Sum of a String

题意：给定<b>数字串s</b>，按照每k个一组，计算<b>数位和</b>。结果连起来，重复这个过程，直到长度不超过k。返回最终结果。

难度：easy

解法：题意很明确，按描述实现即可。

<hr>

2244 Minimum Rounds to Complete All Tasks

题意：给定n个任务，每个的难度为`tasks[i]`。每次你可以选<b>2个或3个</b>同难度的任务完成。请问至少多少次，能完成所有任务？如果不可能完成，则返回-1。

难度：medium

解法：对难度值进行<b>哈希计数</b>，如果<b>计数为1</b>，则不可能完成。其他情况，按`(cc+2)/3`整除处理，结果累加。总代价`O(n)`。

<hr>

2248 Intersection of Multiple Arrays

题意：给定一些无序数组，请返回所有数组的<b>公共值</b>，按<b>升序</b>排列。

难度：easy

解法：转为<b>集合set()</b>，然后求<b>交集&</b>即可。

<hr>

2249 Count Lattice Points Inside a Circle

题意：给定一些圆的圆心和半径`[x,y,r]`，请判断其中包含的<b>整点</b>个数，在边缘上也算。对于被多个圆包含的点，只算一次。

难度：medium

解法：既然是<b>求并集</b>，那我们就不好用<b>纯数学</b>的解法了。还是要<b>枚举具体的点</b>，用集合做一下<b>判重</b>。在给定数据量下，一个`O(nr^2)`的<b>暴力解法</b>勉强可以接受。对于每个圆，我们直接把包含在内的点存入<b>集合</b>，最后统计`len(st)`就是答案。判定依据就是`dx^2+dy^2<=r^2`。总代价`O(nr^2)`。

<hr>

2255 Count Prefixes of a Given String

题意：给定词表words和字符串s。请判断words中，是<b>s前缀</b>的词的个数。

难度：easy

解法：水题。

<hr>

2257 Count Unguarded Cells in the Grid

题意：有一个m x n地图，其中部分格子有<b>守卫或者墙</b>，其余是空地。守卫位置是`guards[i]`，墙的位置是`walls[i]`。已知守卫可以监视上下左右四个方向，但如果<b>被墙挡住</b>，则视野受阻。请求出<b>没有守卫看到</b>的空地格子的数量。

难度：medium

解法：以<b>所有守卫</b>的位置为<b>起点</b>，按<b>上下左右</b>四个方向，<b>执行BFS</b>。如果搜到了墙，则停止<b>这个方向</b>的搜素。这就好比在某位置发出<b>四条激光</b>，看激光能往前走多远。这个激光是<b>不能转向、反弹的</b>。搜索结束后，<b>没有被搜到</b>的空地，就是守卫看不到的。总代价`O(mn)`。

<hr>

2259 Remove Digit From Number to Maximize Result

题意：给定数字串num和一个数位d。请从num中删除一个d，使得结果最大。

难度：easy

解法：数据很小，随便怎么处理都行。比如<b>枚举所有删法</b>，求出最大的一个。

<hr>

2260 Minimum Consecutive Cards to Pick Up

题意：给定数组nums，请找出两个下标(i,j)，使得`nums[i]==nums[j]`，且`|i-j|`最小。返回`|i-j|+1`。如果不存在，则返回-1。

难度：medium

解法：题目的意思<b>翻译过来</b>，就是如上所述。可以用<b>哈希表</b>，记录每个值最后出现的位置，也就是`mm[nums[i]]=i`。那么对于<b>重复出现</b>的值，则可以查出<b>上次出现</b>的位置j，找出`min(i-j+1)`即可。总代价`O(n)`。

<hr>

2261 K Divisible Elements Subarrays

题意：给定数组nums，请求出<b>至多包含k个p的倍数</b>的子数组的个数。

难度：medium

解法：至多，k个，p的倍数。三个要求，求子数组的个数。看起来还是<b>滑动窗口</b>的思路。那就滑动窗口吧。对了，<b>数据规模很小</b>，因此无需滑动窗口，直接`O(n^2)`枚举，用<b>前缀和</b>思路，可以做到`O(1)`代价判断一个子数组。这样的总代价是`O(n^2)`。如果用滑动窗口解法，则复杂度是`O(n)`。

<hr>

2264 Largest 3-Same-Digit Number in String

题意：给定一个数字串num，请找出其中最大的<b>三连数字</b>。比如`777、999`这样。

难度：easy

解法：水题。

<hr>

2265 Count Nodes Equal to Average of Subtree

题意：给定二叉树，请统计`节点值=mean(对应子树所有节点值)`的节点的个数。计算均值时，除法以<b>整除</b>为准。

难度：medium

解法：通过<b>后序遍历</b>，对子树<b>求和</b>，除以<b>节点个数</b>就得到了均值。判断均值和节点值是否相等。总代价`O(n)`。

<hr>

2269 Find the K-Beauty of a Number

题意：给定整数num和k。如果把num视为字符串，找出其中的<b>k长度子串</b>，且得到的值恰好也是<b>num的约数</b>的个数。

难度：easy

解法：不用做字符串操作，用`/10%10`的做法就可以。

<hr>

2273 Find Resultant Array After Removing Anagrams

题意：给定一个词表words，不断从中找出`(w[i-1],w[i])`，如果两者互为anagram，则删除`w[i]`。返回删除完成后的结果。

难度：easy

解法：判断anagram的方法，就是`sorted(s)==sorted(t)`。找出<b>连续的互为anagram</b>的一组词，只保留<b>每组的第一个</b>。总代价`O(n)`。

<hr>

2274 Maximum Consecutive Floors Without Special Floors

题意：给定一个房子，`[bottom,top]`楼层中，有一些`special[i]`层作为休闲用途。请求出<b>连续的不含休闲楼层的</b>最大层数。

难度：medium

解法：要么就是`special[i]-special[i-1]`，要么就是`bottom、top`和`special`两端的距离。总代价`O(n)`。

<hr>

2275 Largest Combination With Bitwise AND Greater Than Zero

题意：给定数组nums，请从其中选出元素，做<b>按位与</b>。要求结果大于0，请求出能选出的最大元素个数。

难度：medium

解法：需要一个`O(n)`的解法，当然不能暴力搜。乍一想，没什么好思路。那么我们<b>按位考虑</b>，比如某位`1<<i`，有nums中，有`cc[i]`个元素的<b>第i位是1</b>，那么答案其实就是`max(cc[i])`，就这么简单。当然，<b>想明白这个逻辑</b>，就没那么简单。为什么是<b>取max</b>，而不能是<b>加法</b>？我们考虑，比如随便<b>选k个元素</b>，按位与之后，结果的第i位是1。那么必有`k<=cc[i]`。因为你至多只能找到`cc[i]`个元素，使得这位等于1。既然<b>最大</b>只能到`cc[i]`，那<b>最大的最大</b>，也就是`max(cc[i])`了。挺难想的。总代价`O(nlog(int))`。

<hr>

2278 Percentage of Letter in String

题意：给定字符串s和字符c，请统计c在s中的百分比。精确到1%。

难度：easy

解法：水题。

<hr>

2279 Maximum Bags With Full Capacity of Rocks

题意：给定n个包，每个的容量是`capacity[i]`，已经装了`rocks[i]`个石头。如果你还有额外k个石头，可以装进包里。请问<b>至多</b>可以把几个包<b>装满</b>？

难度：medium

解法：按照`capacity[i]-rocks[i]`<b>升序排列</b>，那么靠前的就是剩余空间最小的。优先把<b>剩余空间少的</b>装满即可。总代价`O(nlogn)`。

<hr>

2283 Check if Number Has Equal Digit Count and Digit Value

题意：给定数字串num，请判断每个位置i是否恰好<b>出现`num[i]`次</b>。

难度：easy

解法：倒是挺奇怪的要求，按题目要求判断吧。

<hr>

2284 Sender With Largest Word Count

题意：有n条消息，消息内容为`messages[i]`，发送者为`senders[i]`。请统计<b>消息单词总数</b>最多的发送者。

难度：medium

解法：思路很直白。`split()`然后<b>统计个数</b>。用<b>哈希表</b>，按`senders[i]`名称累加，找出最大值即可。总代价`O(n)`。

<hr>

2285 Maximum Total Importance of Roads

题意：给定n个点组成的无向图，你需要给`0~n-1`这些点分配权值`vals=1~n`。对于一条边`[x,y]`，我们定义边的权值为`vals[x]+vals[y]`。请求出所有边的<b>权值之和</b>的最大值。

难度：medium

解法：按照<b>贪心原则</b>，一个点的<b>度数越大</b>，我们就应该给它<b>越高的权值</b>。因此，统计所有点的度数，<b>按度数</b>升序排列。然后<b>依次分配</b>`1~n`的权值。按分配的值，计算所有边的权值之和。总代价`O(VlogV+E)`。

<hr>

2287 Rearrange Characters to Make Target String

题意：给定字符串s和target。你可以从s中<b>选取字符并排序</b>，请问能拼出多少个target？

难度：easy

解法：<b>哈希计数</b>得到ms和mt，对于每个字符c，取`min(ms[c]//mt[c])`就是结果，<b>`//`表示整除</b>。总代价`O(ns+nt)`。

<hr>

2290 Minimum Obstacle Removal to Reach Corner

题意：给定一个m x n地图，你从`(0,0)`出发，要到达`(m-1,n-1)`。中间可能存在一些墙。你可以<b>挖穿</b>墙格子，来通过障碍。请问至少挖多少个墙，才能到达终点？

难度：hard

解法：很容易想到<b>BFS</b>的思路，那么对于空地，我们无障碍通过；对于墙格子，我们要<b>挖一下</b>才能过。因此，可以用`(当前位置,挖掘次数)`作为搜索状态，执行BFS。当到达<b>墙</b>的时候，<b>次数+1</b>；到达<b>空地</b>的时候，<b>次数保持不变</b>。对于hard难度，这题的<b>思维难度</b>其实还好。如果希望效率更高，可以选择<b>双向BFS</b>，实现更麻烦点就是了。

<hr>

2293 Min Max Game

题意：给定数组nums，对于奇数位置，取`max(nums[2i],nums[2i+1])`；对于偶数位置，取`min(nums[2i],nums[2i+1])`。不断执行这个变换，直到剩1个元素。返回<b>最终剩下的元素</b>。

难度：easy

解法：题意很明确，<b>直接模拟</b>即可。总代价`O(nlogn)`。

<hr>

2294 Partition Array Such That Maximum Difference Is K

题意：给定数组nums，将其<b>划分</b>为几个子序列，使得对于每个子序列ss，`max(ss)-min(ss)<=k`。请求出子序列的<b>最小个数</b>。

难度：medium

解法：既然是`max-min`，而且是子序列。那我们就<b>无所谓顺序</b>了。我们不妨把nums排序，得到`sorted_nums`。每次取<b>尽可能长的一段</b>，使的`sorted_nums[j]-sorted_nums[i]`<b>恰好不超过k</b>，这个边界可以通过<b>二分搜索</b>快速找到，当然<b>顺序枚举</b>也行。ij走到最后，划分也就完成了。总代价`O(nlogn+n)=O(nlogn)`。<b>代码非常简短</b>，比思路讲解简单多了。

<hr>

2295 Replace Elements in an Array

题意：给定数组nums，你需要执行m次形如`[x,y]`的操作，表示把x值都替换为y值。返回最终的数组。已知每个x都存在于nums中，且<b>每个y都不存在</b>于nums中。

难度：medium

解法：显然，如果你每次都以O(n)代价替换，那就太慢了。有没有更高效的做法？有，而且关键就在于y值都不存在于nums中。这点很重要。比如`[3,2,5,7]`，把7替换为3。这就导致<b>3出现了重复值</b>。这样就没法高效实现了。如果全程都能<b>保证唯一值</b>，那么我们每次变换都可以做到严格`O(1)`。只要我做好`i<->nums[i]`的<b>双向映射</b>，就可以了。总代价`O(n+m)`。

<hr>

2299 Strong Password Checker II

题意：420的变体。一个密码如果包含大写、小写、数字、特殊符号，则称为<b>强密码</b>。给定密码`password`，请判断是否够强。

难度：easy

解法：420挺麻烦，是个<b>最短编辑距离</b>的hard问题。这题是水题。按照题意，检查各种字符是否出现即可。不要用<b>正则魔法</b>，正则<b>非常不适合</b>这个场景。不但很难写，而且效率低下。

## 2301 - 2400

2303 Calculate Amount Paid in Taxes

题意：按照<b>阶梯税率</b>，和收入，计算缴税金额。

难度：easy

解法：这个和现实生活的<b>个人所得税</b>计算是一样的，阶梯税率。类似`0~x`以下税率tx；`x~y`税率ty；`y~z`税率tz，以此类推。

<hr>

2304 Minimum Path Cost in a Grid

题意：给定m x n的矩阵，你从0行出发，到达m-1行。可以从任意列到达任意列，但每次必须<b>行+1向下走</b>。mn个格子分配了`0~mn-1`的不同值。已知<b>编号i的格子</b>到达<b>下一行第j列</b>的代价是`moveCost[i][j]`。请求出从第0行到第m-1行的最小代价。

难度：medium

解法：题目描述虽然<b>看起来很复杂</b>，其实依然是典型的`dp[i][j]`的思路。对于每个位置`(i,j)`，`dp[i][j]=min(dp[i-1][k]+cost[grid[i-1][k]][j]),k=0~n-1`。总代价`O(mn^2)`。

<hr>

2305 Fair Distribution of Cookies

题意：有n包糖果，每包有`cookies[i]`个。你需要把n包分给k个小朋友，一包糖果<b>不能拆开</b>。请求出单人分到<b>最多糖果的最小值</b>。

难度：medium

解法：虽然是个<b>minimax问题</b>，然因为分配顺序不是依次，而是<b>任意顺序</b>。我们不好用<b>二分思路</b>做。既然n非常小，那可以直接<b>暴力搜索</b>。至多8包糖果，即使`2^8`也是很小的。可以用一些<b>位操作</b>或<b>剪枝策略</b>来进一步提高效率。总代价`O(2^n)`。

<hr>

2309 Greatest English Letter in Upper and Lower Case

题意：给定字符串s，请找出其中<b>大小写都出现</b>的最大字母。

难度：easy

解法：水题。

<hr>

2315 Count Asterisks

题意：给定字符串s，每两个`|`之间的内容忽略掉，统计剩余部分里，`*`的个数。

难度：easy

解法：按题意做<b>字符串解析</b>即可。对`|`按照<b>奇偶</b>处理即可。

<hr>

2317 Maximum XOR After Operations 

题意：给定数组nums，每次你可以任选i、x，执行`nums[i]&=(nums[i]^x)`。经过任意次操作后，请求出<b>所有元素异或</b>的最大值。

难度：medium

解法：<b>智力题</b>，其实结果就是`or(nums)`。你把所有<b>出现过的1</b>拼起来，这就是最好结果了。<b>想想为什么。</b>总代价`O(n)`。

<hr>

2319 Check if Matrix Is X-Matrix

题意：给定一个n x n方阵，如果所有对角线、反对角线之外的元素都是0；且两对角线元素都非0，则称为<b>X矩阵</b>。请判断是否为X矩阵。

难度：easy

解法：水题。

<hr>

2325 Decode the Message

题意：一种简单的<b>替换加密</b>。给定key，将其中a~z第一次出现的顺序，作为一个长度26的串s1。令`s2='abcd...yz'`。则`s2->s1`就是加密映射，`s1->s2`就是解密映射。其余非字母的字符，都保持原样。给定一条加密信息message，请执行解密。比如加密`abc->cab`，则`bb a`加密后变成`aa c`。

难度：easy

解法：虽然<b>有点繁琐</b>，但题意也很明确。按要求实现即可。

<hr>

2326 Spiral Matrix IV

题意：54的变体。给定链表，请将其元素值，按照<b>m x n矩阵顺时针螺旋遍历</b>的方式，填入矩阵。如果元素数量不够mn个，则用-1补充。

难度：medium

解法：还是<b>螺旋遍历</b>，按题意模拟即可。总代价`O(mn)`。

<hr>

2331 Evaluate Boolean Binary Tree

题意：给定二叉树，我们定义叶节点的0假1真，非叶节点的2或3与。请按<b>布尔逻辑</b>的方式，计算<b>整棵树对应的表达式</b>的值。

难度：easy

解法：<b>后序遍历</b>，递归计算即可。

<hr>

2335 Minimum Amount of Time to Fill Cups

题意：你有冷、温、热水x、y、z杯需要填满。每次，你可以<b>选两种各填一杯</b>，或者只填一杯。请问至少多少次可以填满？

难度：easy

解法：不妨假设`x<=y<=z`，那么如果`x+y<=z`，就是`z`次。如果`x+y>z`，就是先变成`(x-z/2,y-(z+1)/2,0)`，然后再经过`max(x-z/2,y-(z+1)/2)`次。总之是个稍稍动脑的<b>数学题</b>。对于给定的小数据量，<b>直接模拟</b>也是可以的。

<hr>

2336 Smallest Number in Infinite Set

题意：给定正整数集S，请设计一个数据结构模拟S。支持`popSmallest()`弹出集合中最小元素，和`addBack(x)`把x值放回去。

难度：medium

解法：比如我们用一个<b>哈希表</b>`popped`表示已经弹出的元素。那addBack()就搞定了。怎么`popSmallest()`？用一个计数cur表示<b>当前最小值</b>。那么如果`addBack(x)`的x值小于cur，则`cur=x`。调用popSmallest()时，返回`cur`，并枚举从`cur+1`开始，直到找出<b>第一个不在popped当中</b>的值。这会导致偶尔`O(n)`，但<b>均摊`O(1)`</b>的代价。属于可以接受的程度。总结一下，`addBack()`代价`O(1)`，`popSmallest()`代价均摊`O(1)`。现在讲的这个思路，和我<b>以前写的代码</b>不一样，忘了以前是怎么想的了。

<hr>

2337 Move Pieces to Obtain a String

题意：给定两个串s和t。都由“LR_”组成，其中`L`棋子只能<b>左移</b>，`R`棋子只能<b>右移</b>，`_`表示空位。移动棋子不能导致<b>越过、交叉</b>。请判断s能否通过移动，变成t？

难度：medium

解法：这题看似有点难，但不要<b>想复杂</b>了。我们从s变成t，那么L、R的<b>个数、先后顺序</b>肯定要相同。而且，t中的<b>L位置</b>，必须`<=`s中的<b>L位置</b>。为什么？因为L<b>只能左移</b>，那位置就不可能变大。对于R位置的情况，反之亦然。按这个逻辑，总代价`O(n)`可以完成判断。至于<b>空位`_`</b>，是可以忽略掉的。

<hr>

2341 Maximum Number of Pairs in Array

题意：给定数组nums，不断从中选出两个相同的值`(x,x)`删除。请返回找到的对数，以及剩余的元素。

难度：easy

解法：进行哈希计数，如果计数是<b>奇数</b>，则剩1个；如果计数是<b>偶数</b>，则删光。对数的个数为`sum(cc[x]//2)`。总代价`O(n)`。

<hr>

2342 Max Sum of a Pair With Equal Sum of Digits

题意：给定数组nums，请找出两个位置`(i,j)`，使得`nums[i]`和`nums[j]`的<b>数位和</b>相等。求出`max(nums[i]+nums[j])`。如果找不出两个元素，则返回-1。

难度：medium

解法：对每个元素求数位和，作为<b>哈希key</b>进行归类。求出每个归类级最大的两个值相加，求max就是最终结果。如果找出<b>前2大元素</b>时用了排序，总代价就是`O(nlogn)`，否则就是`O(n)`。

<hr>

2347 Best Poker Hand

题意：给定五张牌的<b>数字、花色</b>，按照<b>同花、三个、一对、单张</b>的优先级，判断满足哪一种。

难度：easy

解法：<b>有点繁琐</b>，按题意判断吧。

<hr>

2348 Number of Zero-Filled Subarrays

题意：给定数组nums，请统计全0的子数组个数。

难度：medium

解法：统计<b>连续0的个数</b>cc，然后`sum(cc*(cc+1)/2)`即可。总代价`O(n)`。

<hr>

2350 Shortest Impossible Sequence of Rolls

题意：给定一个长度n，值为`1~k`的数组`rolls`。请求出一个最小长度m，使得存在某个长度m的子序列ss，ss在rolls中<b>没有出现</b>。

难度：hard

解法：注意读题，是<b>没有出现</b>。也就是说，对于<b>任何</b>长度`1~m-1`的<b>子序列</b>，在rolls中都能找到。<b>长度t</b>的不同子序列，总共有`k^t`个，这个数量是<b>指数级</b>的。因此<b>答案一定非常小</b>。那么是否需要递归搜索？<b>不需要。</b>比如我走了一段，发现1~k值都出现过了。可以重复，可以乱序，但必须<b>凑齐</b>。这代表<b>长度1的1~k</b>我已经凑齐了，我<b>继续凑下一组</b>就行了。这样，一个<b>for循环+一个set</b>就搞定了。代码非常简洁，<b>思路有点难想</b>。鉴定为90%的<b>智力题</b>。

<hr>

2351 First Letter to Appear Twice

题意：给定字符串s，请找出第一个<b>出现两次</b>的字符。

难度：easy

解法：水题。

<hr>

2352 Equal Row and Column Pairs

题意：给定n x n矩阵，请找出<b>相等的i行、j列</b>。统计`(i,j)`对数。

难度：medium

解法：判断数组相等，这个代价肯定是`O(n)`。而且比较麻烦，不如用哈希的办法，把行、列都转化为字符串，然后存入<b>哈希表</b>。<b>序列化</b>的代价是`O(n^2)`。存入哈希表后，判断比较的代价也是`O(n*n)=O(n^2)`。因此，总代价`O(n^2)`。也可以用其他方式进行哈希，比如自己设计<b>哈希key、哈希算法</b>等等。

<hr>

2357 Make Array Zero by Subtracting Equal Amounts

题意：给定数组nums，每次你需要找出最小的正值x，把`所有正值-x`。请问多少次操作后，nums所有值都变为0？

难度：easy

解法：水题，其实就是`len(set([x for x in nums if x > 0]))`。

<hr>

2358 Maximum Number of Groups Entering a Competition

题意：给定n个学生的成绩`grades`。你需要将他们分为多个组，要求第`i`组的<b>成绩总和、人数</b>都<b>小于</b>第`i+1`组。请问至多能分为几个组。

难度：medium

解法：其实<b>这题很扯</b>，和`grades`的值完全无关，你可以无视数据。只关心n就行了。按照1、2、3这样分，卡看能分几组。这个可以直接用公式得出，总代价`O(1)`。当然，你也可以二分搜出这个值。鉴定为<b>智力题</b>。

<hr>

2363 Merge Similar Items

题意：给定两组物品items1、items2，格式为`[v,w]`表示价值和重量。请按价值<b>归类</b>，按重量<b>求和</b>。结果<b>按价值升序排列</b>。

难度：easy

解法：按题意处理即可。总代价`O(nlogn)`。

<hr>

2365 Task Scheduler II

题意：621的变体。给定n件任务`tasks`，你必须依次完成，不能调整顺序。同类型的任务之间，必须至少间隔`space`天。如果间隔时间还没到，则需要休息。请计算完成<b>所有任务</b>需要的天数。

难度：medium

解法：因为<b>顺序不能调整</b>，问题就比较简单了。对于<b>当前时间`t`</b>，当前任务`tasks[i]`。我们用一个哈希表记录`任务类型->最近完成时间`的映射关系。如果`t-mm[tasks[i]]<space`，则需要休息。休息的意思就是`t=mm[tasks[i]]+space`。按这个逻辑处理，最终得到的<b>t值</b>就是答案。总代价`O(n)`。

<hr>

2367 Number of Arithmetic Triplets

题意：给定严格递增的数组nums和公差diff，请找出`(i,j,k)`三元组，使得对应元素构成等差数列。

难度：easy

解法：因为<b>公差diff是固定的</b>，枚举i位置，后面的jk直接通过<b>哈希表</b>查出就行了。总代价`O(n)`。

<hr>

2368 Reachable Nodes With Restrictions

题意：给定一棵树，`n`个点、`n-1`条边。但其中某些点restricted是禁区。请求出从<b>0点</b>出发，不经过任何禁区，能访问到的点的个数。

难度：medium

解法：首先把restricted转为<b>集合</b>。从0开始执行BFS，遇到<b>禁区点</b>就<b>停止前进</b>。<b>能搜到的所有点</b>，就是答案。用BFS、DFS都行，目的就是<b>图遍历</b>。总代价`O(n)`。

<hr>

2369 Check if There is a Valid Partition For The Array

题意：请将数组nums<b>划分</b>为子数组，要求每个子数组满足三种情况之一：`[x,x]`，`[x,x,x]`，`[x,x+1,x+2]`。请判断是否能找出一种有效的划分？

难度：medium

解法：不要被一些<b>奇怪的边界case</b>，比如`[4,4,4,5,6,7,8,8]`这样的搞晕了。我们用<b>DP思路</b>，考虑`dp[i]`和`dp[i-2]`或者`dp[i-3]`的关系。再考虑最后2个、3个元素是否符合题目要求。这样的<b>递推关系是线性的</b>，因此总代价`O(n)`。最终答案就是`dp[n]`。

<hr>

2373 Largest Local Values in a Matrix

题意：给定`n x n`方阵，请求出每个`3 x 3`矩阵的<b>最大值</b>。返回`(n-2) x (n-2)`的结果。

难度：easy

解法：数据量比较小，直接`3 x 3`这么求max就行了。

<hr>

2375 Construct Smallest Number From DI String

题意：给定一个数字串num，我们用I、D表示相邻数位的比较结果，I增D减。已知num中1~9数字至多使用一次，给定一个ID串pattern，请求出符合pattern的<b>字典序最小</b>的num串。

难度：medium

解法：因为`1~9`至多使用一次，这决定了<b>数据量一定非常小</b>。在小数据量下，<b>随便怎么处理</b>都行，比如<b>搜索回溯</b>。总代价`O(n!)`，实际<b>远小于这个值</b>。

<hr>

2379 Minimum Recolors to Get K Consecutive Black Blocks

题意：给定BW串s，表示<b>黑白色</b>。每次你可以选择一个W变成B，请问至少多少次操作，可以得到一个<b>长度k的B串</b>？

难度：easy

解法：之前遇到过类似的题了，之前是medium难度，这题直接easy了。我们考虑每个k窗口，看其中有多少个W。那么答案就是`min(k窗口中W的个数)`。移动窗口的代价是`O(1)`，因此总代价`O(n)`。

<hr>

2380 Time Needed to Rearrange a Binary String

题意：给定01串s，每次操作时，所有`01`<b>同时被替换</b>为`10`。请问经过多少次操作，s中不存在`01`？

难度：medium

解法：<b>直接模拟</b>的话，总代价`O(n^2)`，而且很容易理解。那么怎么在`O(n)`时间完成计算呢？看了下以前的代码，我应该是没想出来。现在尝试想了10分钟，有点思路了。比如`0110101`，每次变换，左侧的0都会向右移动1格。直到0都移到右侧，就完成了。那么我们可以考虑每个0的<b>实际位置x</b>和<b>应该的位置y</b>之间的距离，也就是`y-x`。答案就是`max(y-x)`。以前那份代码，我应该是<b>看了提示</b>才写出来的。现在总算能独立想出来了。总代价`O(n)`。

<hr>

2383 Minimum Hours of Training to Win a Competition

题意：有n个敌人要<b>依次</b>击败，每个敌人需要的能量`eg[i]`和经验`ep[i]`。为了击败敌人，你的当前能量、经验都必须严格大于敌人。击败后，`能量-=eg[i]`，`经验+=ep[i]`。如果你的初始值是(ieg,iep)，且你可以分配一些技能点给能量和经验，每个技能点+1。为了击败所有敌人，请求出最少需要的技能点。

难度：easy

解法：对于easy难度，这题算有点难了。能量按`sum(eg[i])+1`处理。对于经验，如果`cur_ep<=ep[i]`，则补充`ep[i]+1-cur_ep`点经验。总代价`O(n)`。

<hr>

2385 Amount of Time for Binary Tree to Be Infected

题意：给定二叉树，所有节点值都不同。从值为start的节点开始，病毒每1个时间单位，<b>扩散1条边</b>。请问多长时间能感染整棵树。

难度：medium

解法：如果是<b>无向图</b>的话，很显然这就是<b>BFS</b>。现在形式是一棵二叉树，则要考虑<b>递归的写法</b>。我用了个比较奇怪的方法。先遍历一次，求出所有节点的<b>深度</b>。然后求start节点和所有节点的<b>LCA路径</b>，最近公共祖先。必然存在一个点，和start节点的LCA是根节点，且<b>路径最长</b>。如果这棵树比较平衡，则总代价接近`O(nlogn)`。但如果树严重倾斜的话，则代价就变成了`O(n^2)`。因此这个解法不太好，<b>不够健壮</b>。倒不如先转化成<b>无向图，再做BFS</b>。这样虽然稍麻烦，但思路非常直白。

<hr>

2389 Longest Subsequence With Limited Sum

题意：给定数组nums，你可以从中选出<b>子序列</b>。有m个查询，对于每个查询q，请求出你能得到的nums的<b>最长子序列</b>，使得<b>序列和</b>不超过q。返回序列长度。

难度：easy

解法：题目<b>看起来很复杂</b>，想明白了就很简单。<b>子序列</b>，和不超过q，还要<b>尽量长</b>。按<b>贪心原则</b>，我们把nums排序，取前面的值，这样总和就可以<b>尽量小</b>，数量就可以<b>尽量多</b>。计算`sorted_nums`的<b>前缀和</b>，然后对前缀和<b>二分搜索</b>，`bisect_right`找q值的位置。虽然这题确实不难，但对于easy难度，这算很复杂了。总代价`O((n+m)logn)`。我觉得这题可以定medium难度了。

<hr>

2390 Removing Stars From a String

题意：给定字符串s，如果其中存在`*`，则移除星星左边最接近的<b>非星字符</b>。重复这个过程直到不存在星星为止，返回结果。

难度：medium

解法：用<b>栈</b>处理，遇到`*`就`pop()`。

<hr>

2391 Minimum Amount of Time to Collect Garbage

题意：给定n个房子，编号`0~n-1`。每个房子可能有MPG三种垃圾，表示金属、纸、玻璃。比如`MGG`表示<b>一个金属两个玻璃</b>。三辆卡车从0位置出发，移动1单位或者收1个垃圾，耗时1分钟。从`i`到`i+1`房子的距离为`travel[i]`。如果同一时间只有一辆卡车可以工作，请求出收完所有垃圾的<b>最少时间</b>。

难度：medium

解法：这题的题目描述挺费解的，但题目其实非常简单。一道纯粹的<b>模拟题</b>，而且还是<b>单线程模拟</b>。你可以把`M、P、G`的情况单独处理，如果某种垃圾没有出现，那直接就<b>等于0</b>。注意，对于存在的垃圾，你必须<b>从0位置出发</b>，即使0位置没有垃圾。计算方式就是`距离总和+垃圾个数`。总代价`O(n)`。

<hr>

2392 Build a Matrix With Conditions

题意：给定整数k，你需要构建一个k x k方阵。方阵包含`1~k`<b>恰好一次</b>，其余值都是0。你还有nr个行条件rowConditions`[x,y]`，表示x值出现在y值上面；nc个列条件colConditions`[x,y]`，表示x值出现在y值左边。

难度：hard

解法：首先我们脑子里可以考虑类似八皇后那样的摆放方式，也就是`1~k`<b>不同行、不同列</b>。好像一个<b>对角矩阵经过乱序</b>的那种状态。那么我们实际上要找出的是<b>两个`1~k`的排列</b>，分别对应从上到下的<b>行顺序</b>、从左到右的<b>列顺序</b>。这个<b>顺序怎么求</b>？我们针对rowConditions、colConditions分别构建有向图gr、gc。对gr、gc各做一次<b>拓扑排序</b>即可。得到的<b>拓扑顺序</b>就是我们要找的顺序。举例，比如得到的顺序分别是`rowOrder=[3,4,2,1],colOrder=[2,1,4,3]`，那么我们以1下标为准，1234的对应位置分别是`(4,2),(3,1),(1,4),(2,3)`。仔细想想这个例子，你就明白了。这题hard主要在于要<b>考虑的事很多，一环套一环</b>。不过每件事单独看，都不算很难。总代价`O(nr+nc+n)`，每个步骤都是<b>线性</b>的。

<hr>

2395 Find Subarrays With Equal Sum

题意：给定数组nums，请判断是否存在两个<b>长度为2</b>的子数组，<b>和相同</b>。

难度：easy

解法：水题。

<hr>

2396 Strictly Palindromic Number

题意：给定整数n，如果n在`2~n-2`进制下，都是<b>回文数</b>，则称为<b>严格回文数</b>。请判断n是否为严格回文数。

难度：medium

解法：n在`n-1`进制下，等于11，这肯定是回文数。所以题目才说`n-2`。做一次进制转换的代价是`O(logn)`，那总代价就是`O(nlogn)`。实际上<b>这个要求超级严格</b>，基本没几个数能满足的。所以很难跑完`n-3`次进制转换的。另外，你有没有想过，这个<b>根本不可能满足</b>？我也是刚刚想到。这个出题人一定<b>觉得自己很聪明</b>。

<hr>

2397 Maximum Rows Covered by Columns

题意：给定m x n的01矩阵mat，你需要从中选择k列。对于某行i，如果i行的所有1都被你选中了，则称<b>第i行被覆盖了</b>。现在请设计策略，使得<b>被覆盖的行最多</b>。对于没有1的行，默认就是被覆盖的。返回最大的覆盖行数。

难度：medium

解法：我想了想各种不同的方法，<b>贪心？DP？</b>好像都不行。看了下数据量，直接<b>暴力枚举</b>吧。因为<b>`m、n`很小</b>，全过程都可以通过<b>位运算</b>实现，具体怎么做就不说了。总代价`O(m*2^n)`。

<hr>

2399 Check Distances Between Same Letters

题意：给定字符串s，其中每种字母都出现了两次。给定一个distance数组，定义了a-z每种字母的<b>两字符出现的距离</b>。请检查`s`中的距离是否和`distance[i]`符合。如果某种字符没有出现，则忽略它。

难度：easy

解法：用<b>哈希表</b>记录字符出现位置，计算距离，然后和对应的`distance[i]`比较即可。如果<b>全部匹配</b>，就是true；否则，就是false。

## 2401 - 2500

2401 Longest Nice Subarray

题意：给定数组nums，如果一个子数组的任意两个元素，<b>按位与</b>都等于0，则称为<b>好子数组</b>。请求出好子数组的最大长度。

难度：medium

解法：这题有点巧妙。如果任何两个元素，都满足`x&y==0`，这表示这些元素互相没有<b>共同的二进制1位</b>。因此，我们把不同位置上的1分开考虑。比如`11100`，相当于`(2,3,4)`三位是1。那么我们对一个子数组的元素，做一下<b>“1位”</b>的计数。如果存在>=2的计数，必然存在两个元素<b>在某位都是1</b>，那它们的<b>按位与必然非0</b>。有了这个判断，我们按照<b>双指针+滑动窗口</b>的思路，做计数。i前进<b>扩大窗口</b>，如果<b>计数出现了2</b>，就要j前进来<b>缩小窗口</b>。总代价`O(nlog(int))`。这题挺难的，这个思路<b>不能说很难，但很巧妙</b>。如果想不到，那就很难搞出来。

<hr>

2404 Most Frequent Even Element

题意：给定数组，返回频率最高的偶数。如果有多个，则返回最小的。如果不存在，则返回-1。

难度：easy

解法：水题。

<hr>

2405 Optimal Partition of String

题意：给定字符串，请将其<b>划分</b>为多个子串，使得每个子串都不存在<b>重复字符</b>。请求出<b>最小的</b>子串个数。

难度：medium

解法：一看就是<b>贪心原则</b>。为什么？比如`s1+s2`，那我如果把`s1`的最后字符拿给`s2`，<b>并不会减少子串个数</b>，反而可能让`s2`出现重复。也就是说，非贪心策略只会导致<b>相同或更坏</b>的结果。因此<b>贪心是对的</b>。从0位置开始，总是尝试找出<b>最长的不重复子串</b>。一直<b>找到结尾</b>，看能分出几个。判重用一个<b>哈希表</b>就可以了，也可以用一个`(1<<26)-1`的位掩码，用位操作的方式做同样的事情。总代价`O(n)`。

<hr>

2406 Divide Intervals Into Minimum Number of Groups

题意：有n个区间，你需要将其分为几个组，使得每个区间属于1个组，且每组内的区间都不相交。注意，边界相邻也算相交，比如`[1,3]`和`[3,6]`。

难度：medium

解法：这题有两种思路，一种简单一种复杂。先说复杂的，比如我对区间<b>排序</b>，然后每次<b>找一组区间</b>，互不相交。说实话，<b>我不知道怎么找</b>，这思路不行。再说简单的，比如我只考虑某个值x被这些区间覆盖了几次。比如覆盖了5次，那我是不是必须有5组？因此，覆盖了`max(覆盖次数)`次，我就需要这么多组。就这么简单，一堆区间，求<b>最大覆盖次数</b>，这个用<b>树状数组</b>，或者<b>后缀累加</b>的方式，都可以求出。如果不知道<b>具体做法</b>，可以参考我的代码。用树状数组，总代价`O(nlogn)`；用后缀累加，总代价`O(n)`。

<hr>

2409 Count Days Spent Together

题意：给定两个人在一个城市的<b>到达、离开</b>时间，格式为`MM-DD`。请计算两人同在这座城市的天数。

难度：easy

解法：做<b>日期解析</b>，转为天数区间`[x1,y1]、[x2,y2]`，求交集长度。

<hr>

2410 Maximum Matching of Players With Trainers

题意：给定n个运动员和m个陪练。运动员能力为`players[i]`，陪练能力为`trainers[j]`。如果<b>陪练能力不低于运动员</b>，则可以和运动员进行训练。训练时，`运动员<->陪练`关系需要<b>一对一</b>。请求出能组成的训练对子的<b>最大个数</b>。

难度：medium

解法：看这个关系，应该是标准的<b>二部图最大匹配问题</b>。但是，我们<b>不要用图论</b>方式解决，因为很复杂。既然这是数值、数组，那我完全可以用<b>排序、单调性解决</b>。对players、trainers排序，i、j双指针从0开始。如果`players[i]<=trainers[j]`，则`i+=1 j+=1`；否则，`j+=1`。就这么简单，和图论没有半毛钱关系。总代价`O(nlogn)`。

<hr>

2413 Smallest Even Multiple

题意：给定整数n，请返回最小的偶数x，使得x是n的倍数。

难度：easy

解法：水题，水得有点惊人。

<hr>

2414 Length of the Longest Alphabetical Continuous Substring

题意：我们定义形如`abcd...xyz`这样的串为<b>连续串</b>。给定字符串s，请找出其中最长的<b>连续子串长度</b>。

难度：medium

解法：水题，这题定为medium难度不合理。总代价`O(n)`。

<hr>

2415 Reverse Odd Levels of Binary Tree

题意：给定一个<b>满二叉树</b>，请将奇数层的节点反转。以根节点为0层，往下<b>逐层+1</b>。

难度：medium

解法：还是<b>交换节点值</b>比较容易，如果交换指针，容易搞得比较杂乱。可以用任意方式遍历，把每层节点依次放到一起，然后<b>把值反转一下</b>。也可以在递归过程中，直接传参`r1、r2`，时刻保持`r1、r2`在<b>镜像对称的位置</b>，这样直接交换两个值就可以了。总代价`O(n)`。

<hr>

2418 Sort the People

题意：给定n个人的姓名和身高，请按<b>身高降序排列</b>，返回对应的姓名列表。

难度：easy

解法：这种<b>多维排序</b>，取<b>某字段</b>，或者做<b>什么什么变换</b>，都是数据分析里的基本操作。要熟练掌握的。总代价`O(nlogn)`。

<hr>

2419 Longest Subarray With Maximum Bitwise AND

题意：给定数组nums，请求出一个最长的子数组，使得<b>子数组的按位与</b>取得<b>最大值</b>。

难度：medium

解法：<b>按位与，最大值</b>，听起来很复杂。其实这题是个<b>智力题</b>，坑人的。比如有两个不同值x、y，那么`x&y`<b>最好的情况</b>就是`min(x,y)`，也可能比这个更小。那我既然要找<b>最大的按位与</b>结果。你想想最大值什么？一定是`max(nums)`。因此，答案就是先求出`max_val`，然后找出`max_val`的<b>连续出现</b>的最大次数。鉴定为<b>坑爹的智力题</b>。

<hr>

2423 Remove Letter To Equalize Frequency

题意：给定字符串word，请判断能否<b>删除一个字符</b>，使得所有字符的<b>频率相等</b>。

难度：easy

解法：水题，<b>统计频率</b>即可。

<hr>

2424 Longest Uploaded Prefix

题意：给定n个数据，编号1~n，你可以按乱序上传。请设计一个数据结构，支持`upload(x)`，上传x号数据；支持`longest()`，统计当前`1~k`号已上传的最大k值。

难度：medium

解法：用<b>哈希表</b>记录已上传的数据编号，再用一个值`k`记录当前的`1~k-1`<b>最长前缀值</b>。那么当我们上传的`x==k`时，从`k+1`遍历，直到找到<b>第一个还没上传的编号</b>为止。这个操作可能导致单次`O(n)`，但<b>均摊代价</b>是`O(1)`的。

<hr>

2425 Bitwise XOR of All Pairings

题意：给定数组nums1、nums2，我们把所有`nums1[i]^nums2[j]`的结果，再求一次<b>异或</b>。请求出最终结果。

难度：medium

解法：异或完了再异或，那么这些异或是可以<b>交换、结合、分配</b>的。因此，这个问题其实是`nums1[i]`和`nums2[j]`在整个式子里<b>出现了多少次</b>。奇数次，等于自身；偶数次，等于0。其实很简单，`nums1[i]`出现了n2次；`nums2[j]`出现了n1次。只要考虑`n1、n2`的<b>奇偶性</b>就行了。剩下就不用说了。总代价`O(n1+n2)`。实在不喜欢这种<b>无聊的智力题</b>。

<hr>

2427 Number of Common Factors

题意：给定整数a、b，求<b>公约数</b>的个数。

难度：easy

解法：也就是<b>最大公约数</b>的<b>约数个数</b>。

<hr>

2428 Maximum Sum of an Hourglass

题意：给定m x n矩阵，请求出其中按照313排列的<b>“工”字型</b>的最大元素和。

难度：medium

解法：那就<b>按这个形状求和</b>，枚举就行了。总代价`O(mn)`。

<hr>

2432 The Employee That Worked on the Longest Task

题意：有n个工人<b>依次</b>执行任务。给定n个人的完成时间，每个人都从上一个人完成后开始工作。请求出<b>执行任务时间最长</b>的工人的ID，如果存在多个，则返回最小ID。已知1号工人从<b>0时刻</b>开始执行。

难度：easy

解法：水题。

<hr>

2433 Find The Original Array of Prefix Xor

题意：给定数组nums，你知道每个前缀`pref[i]=xor(nums[0:i+1])`的值。请求出<b>原数组</b>。

难度：medium

解法：水题，`nums[i]=pref[i]^pref[i-1]`。总代价`O(n)`。

<hr>

2437 Number of Valid Clock Times

题意：给定一个`HH:MM`格式的时间，其中可能包含`?`表示的<b>未知值</b>。请判断有多少种可能的<b>有效时间</b>。

难度：easy

解法：`00:00`到`23:59`。对于`?`直接<b>搜索</b>就行了。<b>搜索空间</b>非常小，不存在效率问题。

<hr>

2441 Largest Positive Integer That Exists With Its Negative

题意：给定数组nums，请求出<b>最大的正数k</b>，使得`+-k`都在nums中。

难度：easy

解法：水题。

<hr>

2442 Count Number of Distinct Integers After Reverse Operations

题意：给定数组nums，请将所有元素进行<b>数位反转</b>，得到`nums_rev`。求出`nums+nums_rev`的唯一值个数。

难度：medium

解法：题意很清晰，照做就行了。求<b>唯一值个数</b>，可以直接`len(set())`。总代价`O(nlog(int))`，数位反转的代价不是`O(1)`，而是`O(log(int))`。

<hr>

2444 Count Subarrays With Fixed Bounds

题意：给定数组nums，和最小最大值`minK、maxK`。请求出最小值为minK，最大值为maxK的子数组的个数。

难度：hard

解法：这题挺麻烦，主要是<b>思路有点难</b>，代码也有复杂。首先，你是不是想到<b>滑动窗口</b>了？恭喜，想对了。但不能直接滑动窗口，你需要先去掉`<minK || >maxK`的界外的值。把`[minK,maxK]`范围内的值留下来。这样你会得到<b>一些片段</b>。对于<b>每个片段</b>，再做滑动窗口，求出<b>至少包含一个minK和maxK值</b>的窗口。我的代码里，对`minK==maxK`的情况做了<b>特殊处理</b>，其实这个<b>不必要</b>。和`!=`的情况逻辑完全一样，没必要浪费代码。总代价`O(n)`。

<hr>

2446 Determine if Two Events Have Conflict

题意：有两个事件`[start1,end1]、[start2,end2]`，其中的时间格式为`HH:MM`。请判断两者是否有重叠。<b>端点相交</b>也算重叠。

难度：easy

解法：把时间转换为整数，然后按<b>区间求交</b>处理即可。

<hr>

2447 Number of Subarrays With GCD Equal to K

题意：给定数组nums，请求出子数组的<b>最大公约数</b>为k的个数。

难度：medium

解法：这好像想不出什么高效的做法，因为`gcd()`这个运算是不可逆的。你很难找到一个<b>逆运算</b>给它变回去。如果要用<b>滑动窗口</b>思路，要求我们做的运算<b>存在逆运算</b>，比如<b>加减、异或</b>之类的。直接`O(n^2)`枚举吧。

<hr>

2449 Minimum Number of Operations to Make Arrays Similar

题意：给定数组nums、target。你希望通过变化，把`sorted(nums)`变成`sorted(target)`，也就是元素值相同，但顺序可以不同。每次操作，你可以任选`nums[i]+=2`且`nums[j]-=2`，但不能单独修改一个元素。请求出<b>最小的修改次数</b>。

难度：hard

解法：<b>智力题</b>，挺难想的。首先，因为是`+-2`，奇偶性是不变的。那么我们可以把所有奇数、所有偶数<b>分开处理</b>。比如<b>我们考虑奇数</b>，得到no、to两个数组。那么我们把`no[i]-to[i]`，但我们只考虑<b>其中的正值</b>。为什么？因为`正值的和+负值的和`<b>一定等于0</b>。题目要<b>保证有解</b>，这个条件必须满足。我们要变换的次数，就是`sum(no[i]-to[i])/2`，其中`no[i]>to[i]`。偶数的情况，思路完全相同。总代价`O(n)`。实现没有难度，难度<b>都在思路上</b>。

<hr>

2451 Odd String Difference

题意：给定一些字符串words，对每个串计算相邻字符之差，得到一些数组。这些数组中，只有一个长得不一样。请找出对应的这个`words[i]`。

难度：easy

解法：<b>略繁琐</b>，但没有难度。按题意实现即可。

<hr>

2452 Words Within Two Edits of Dictionary

题意：给定一个词表dictionary，和一些查询queries。请找出查询中，所所有和<b>词表中某词，编辑距离不超过2</b>的单词。已知所有词的长度都相同，因此编辑只涉及<b>修改字符</b>。

难度：medium

解法：暴力解法，就是做`O(nq*nd)`的枚举，<b>两层循环</b>逐个检查。还有一种方法，以`dictionary`中的所有词<b>作为起点，执行BFS</b>。做至多2次编辑。这样<b>搜出来的所有词</b>，如果命中了`queries`中的查询词，就是我们要找的答案。讲道理，这个解法的代价有`O(nd^3)`，可能<b>还不如暴力解法</b>。

<hr>

2455 Average Value of Even Numbers That Are Divisible by Three

题意：给定数组，请求出其中<b>6的倍数</b>的平均值。计算平均值用<b>整除</b>。

难度：easy

解法：水题。

<hr>

2460 Apply Operations to an Array

题意：给定数组nums，对`i=0~n-2`位置，<b>依次</b>执行操作。如果`nums[i]==nums[i+1]`，则变为`(2*nums[i],0)`，否则不变。返回最终结果。

难度：easy

解法：水题，注意是<b>依次执行</b>，不是同时。

<hr>

2465 Number of Distinct Averages

题意：给定数组nums，长度2n。请执行n次操作，每次都从nums中删除`max、min`，并计算`(max+min)/2`。请统计n个结果中的<b>唯一值个数</b>。

难度：easy

解法：将nums<b>排序</b>，每次都从<b>头尾</b>取两个元素就是`max`和`min`。结果存入哈希表，统计唯一值个数。总代价`O(nlogn)`。

<hr>

2466 Count Ways To Build Good Strings

题意：给定一个空串，每次你可以添加`zero个0`，或者`one个1`。请问通过两种操作，能得到多少种长度在`[low,high]`范围的01串？结果模`1e9+7`返回。

难度：medium

解法：很明确的<b>线性DP</b>思路，`dp[i]=dp[i-zero]+dp[i-one]`。求和`sum(dp[low:high+1])`就是答案。总代价`O(n)`。

<hr>

2469 Convert the Temperature

题意：给定<b>摄氏度</b>，转为<b>开</b>和<b>华氏度</b>。

难度：easy

解法：这属于常识题了。华氏`f=1.8c+32`，开氏`k=c+273.15`。<b>热力学计算</b>都是以<b>开氏温度</b>为准的。

<hr>

2471 Minimum Number of Operations to Sort a Binary Tree by Level

题意：给定二叉树，每次你可以选<b>同层的两个节点</b>，交换它们的值。请问至少多少次操作，<b>每层的值</b>都变得有序？

难度：medium

解法：首先要明白，各层之间是<b>互不相干</b>的。因此我们可以把每层考虑成<b>一个数组</b>。问题就成了一个数组，至少多少次交换能变得有序？比如`a=[3,2,1,5,4]`，每次我都把<b>排第i的值</b>换到<b>第i位置</b>。经过<b>至多`n-1`</b>次，可以做到有序。至少多少次？那就看<b>实际交换了</b>。这个例子里，`32154->12354->12345`，交换两次就够了。所以这个问题其实分解为<b>两个子问题</b>，第一是<b>遍历每层</b>，得到一个数组；第二是把数组<b>弄成有序的</b>。总代价`O(n)`。

<hr>

2475 Number of Unequal Triplets in Array

题意：给定数组nums，请求出(i,j,k)三元组的个数，使得对应元素值<b>各不相同</b>。

难度：easy

解法：数据量很小，<b>直接枚举ijk</b>也可以。总代价`O(n^3)`。稍微高效点的办法，就是<b>枚举ij</b>，然后用哈希表查询剩余元素里，不等于`nums[i]`和`nums[j]`的个数。总代价`O(n^2)`。再聪明点的办法，就是枚举j，然后用前后缀<b>两个哈希表</b>，查询不等于`nums[j]`的个数，两者相乘。再减去`nums[i]==nums[k]`的情况。总代价甚至可以降到`O(n)`。我说这个想表达什么呢？想表达，没有必要为一个<b>简单的任务</b>，做<b>过度优化</b>，浪费时间和脑细胞。

<hr>

2477 Minimum Fuel Cost to Report to the Capital

题意：给定n个城市，编号`0~n-1`，其中0是首都。路网构成了<b>一棵树</b>。现在所有城市的代表要去首都开会。行进过程中，可以选择自己的车，也可以搭别人的车<b>一起拼车</b>。车前进1条件，耗油1个单位。如果每辆车有`seats`个座位，请求出所有<b>`n-1`个代表</b>到达首都的<b>最小总耗油</b>。

难度：medium

解法：这题有点难，主要难在怎么处理<b>拼车问题</b>。比如n-1个人出发，<b>中途</b>肯定会有人改为<b>和其他人拼车</b>，而不再自己开车。比如有7个人一条路，但车只有3个座位，那就依然需要`ceil(7/3)=3`辆车才够用。这题我想了很久，最后想明白了。我怎么搜？当然要<b>从0开始搜</b>。但我需要知道在某个点汇集了<b>多少人</b>，根据多少人计算<b>多少辆车</b>，然后才知道<b>用多少油</b>。注意，<b>“汇集”</b>，这就是<b>后序遍历</b>。按这个思路继续往下，想就有答案了。我觉得这题算是hard，<b>思路很难想</b>。总代价`O(n)`。

<hr>

2481 Minimum Cuts to Divide a Circle

题意：给定一个圆，你可以任意画直径、半径线。请问至少几条线，能把圆等分<b>n个扇形</b>。

难度：easy

解法：带一点几何思维的<b>智力题</b>。想想n是<b>奇数偶数</b>的情况就明白了。

<hr>

2482 Difference Between Ones and Zeros in Row and Column

题意：给定m x n的01矩阵grid，我们定义`r1、c1、r0、c0`为行1、列1、行0、列0的个数。定义`diff[i][j]=r1[i]+c1[j]-r0[i]-c0[j]`。请求出矩阵diff。

难度：medium

解法：题意非常明确，按要求实现即可。总代价`O(mn)`。

<hr>

2483 Minimum Penalty for a Shop

题意：给定一个YN串，表示yes or no，第i时刻有<b>客人、没客人</b>。现在请决定<b>关门时间t</b>。如果`<t`时刻没客人，则扣1分；如果`>=t`时刻有客人，则扣1分。请选择最小的t值，使得<b>总扣分最少</b>。

难度：medium

解法：其实相当于统计<b>前缀N+后缀Y</b>的个数。用`cn、cy`两个变量，随着`i`移动，更新`cn、cy`的值。单次更新的代价是`O(1)`。求出`min(cn+cy)`即可。总代价`O(n)`。

<hr>

2485 Find the Pivot Integer

题意：给定整数n，请求出一个x，使得`sum(1~x)==sum(x~n)`。如果不存在，则返回-1。

难度：easy

解法：水题，<b>二分搜索</b>即可。就不要想`O(1)`的<b>纯数学解</b>了，没必要。

<hr>

2486 Append Characters to String to Make Subsequence

题意：给定字符串s和t，你可以在s末尾添加任意字符。请问至少添加几个字符，使得<b>t是s的子序列</b>？

难度：medium

解法：判定子序列的算法是`O(n)`的。那么在判定过程中，如果我们发现t<b>还剩一些字符</b>在s中<b>没匹配到</b>。那么剩多少个，就添加多少个。总代价`O(ns+nt)`。

<hr>

2487 Remove Nodes From Linked List

题意：给定链表，对于<b>每个节点p</b>，如果<b>p右侧</b>存在某点q，满足`p.val<q.val`，则删除p。返回修改后的链表。

难度：medium

解法：这其实就是个<b>单调栈</b>（或者单调队列也行）。你可以把节点放入栈中，如果`top.val<cur.val`，则`top`要<b>弹出</b>。最后把<b>剩余的节点</b>拼成一个链表。出栈的节点，则删除掉。总代价`O(n)`。

<hr>

2490 Circular Sentence

题意：给定一个英文句子，请判断<b>前词的尾字母</b>是否等于<b>后词的首字母</b>，包括n-1词和0词。

难度：easy

解法：这叫<b>顶针续麻</b>，字头咬字尾。先`split()`，然后逐个判断即可。总代价`O(n)`。

<hr>

2491 Divide Players Into Teams of Equal Skill

题意：有n个玩家，n为偶数。请分为`n/2`组，每组2人。已知每人的水平为`skill[i]`。要求每组的<b>skill之和相等</b>，请求出每组的<b>技能乘积</b>之和，`sum(skill[x]*skill[y])`。如果无法满足要求，则返回-1。

难度：medium

解法：`sm=sum(skill)/(n/2)`就是<b>每组的技能之和</b>。有了这个sm，分组就简单了。对于值x，我在skill里寻找sm-x的玩家分为一组。如果<b>找不到</b>，则<b>无法完成分组</b>。一边分组，一边累加`x*(sm-x)`即可。总代价`O(n)`。除此之外，分组还有一种办法，就是先对`skill`<b>排序</b>，按照<b>大小搭配</b>分组。这个很好理解，当前的`max+min`<b>一定等于sm</b>。如果不等于，则无法完成分组。

<hr>

2492 Minimum Score of a Path Between Two Cities

题意：给定一个<b>带权无向图</b>，节点编号`1~n`。边的格式为`[x,y,w]`，表示xy连通，距离为w。现在我们定义一条路径的分值为路径上`min(边的距离)`，也就是其中最短边的距离。请求出<b>从1到n的路径</b>的最小分值。

难度：medium

解法：这题也是搜索，但不是针对点，而是<b>针对边</b>进行搜索。搜索过程中，我们总是取`min(w)`，最小的边权重。注意，我们可能为了找一条<b>最小边</b>而<b>绕远路</b>。因此，不能以<b>到达n</b>作为<b>搜索终点</b>，而是应该把<b>所有边都遍历一次</b>。总代价`O(E)`。

<hr>

2496 Maximum Value of a String in an Array

题意：给定字符串s，如果全是数字，则分值为`int(s)`；否则分值为`len(s)`。给定一些字符串strs，请求出其中的<b>最大分值</b>。

难度：easy

解法：水题。

<hr>

2498 Frog Jump II

题意：403的变体。给定n个石头的位置`stones[i]`，升序排列。青蛙从0号位置出发，想要跳过去再跳回来。也就是到达`stones[n-1]`再返回`stones[0]`。要求跳的过程中，不能重复落在某个`stones[i]`上。每次跳跃`i->j`的距离为`|stones[i]-stones[j]|`。请求出`max(|stones[i]-stones[j]|)`的最小值。

难度：medium

解法：minimax问题，你是不是考虑<b>二分搜索</b>一个值x，使得`max(|...|)<=x`？不对，这么搞<b>很费劲</b>。其实这题也是个<b>智力题</b>，而且<b>很坑人</b>。有两个关键思路：第一，你<b>至多跳2格</b>，如果你跳了3格，一定不是最优解；第二，你<b>不用考虑往回跳</b>，只要<b>划分</b>出两个从`0`到`n-1`的子序列就行。因此，你选的路其实是固定的两条：`0,1,3,5,...`和`0,2,4,6,...`。那么为什么<b>至多跳2格</b>呢？这个很重要。看例子，比如`[0,1,2,3,4]`，我选了`0->3->4`，返回我可以选`4->2->1->0`。问题在哪儿？问题在于我如果把`1或2`放在`0->3`之间，结果<b>可能会变好</b>，至少<b>不会变差</b>。这个<b>直觉上</b>是对的，但<b>严格证明</b>就没那么简单。总之，如果你想通了（或者你相信了）这点，这个`O(n)`的解法就有了。我当时没完全想明白，所以这份代码不能算<b>独立完成</b>的，至少我参考了网上讨论。这题是个<b>难题</b>，不完全算是智力题吧。因为这个思维过程，还是<b>有章法可循</b>的。

<hr>

2500 Delete Greatest Value in Each Row

题意：给定m x n矩阵，每次从<b>每行</b>删除一个<b>最大值</b>，并把`max(这些最大值)`加到结果中。返回最终结果。

难度：easy

解法：把每行都<b>排序</b>，这样就<b>不用去找</b>最大值了。剩下<b>按题意实现</b>即可。总代价`O(mnlogn)`。
