# LeetCode 一句话题解 - 2001-2500

[返回目录](./README.md)

- [LeetCode 一句话题解 - 2001-2500](#leetcode-一句话题解---2001-2500)
  - [2001 - 2100](#2001---2100)
  - [2101 - 2200](#2101---2200)
  - [2201 - 2300](#2201---2300)

代码库地址：  
[https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/2001-2500](https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/2001-2500)

## 2001 - 2100

2001 Number of Pairs of Interchangeable Rectangles

题意：给定n个矩形的长和宽，如果长宽比相同，则视为<b>等比例</b>。请求出等比例的<b>矩形对数</b>。

难度：medium

解法：我在这题尝试打开了<b>Copilot</b>，然后<b>tab一下</b>就全文背诵了。不得不说<b>做题家就是这样被消灭的</b>。你做的事情如果<b>机械重复</b>，不管曾经这件事情多么<b>“脑力密集”</b>，现在都变成<b>体力活儿</b>了。回到这题，本身确实不难。针对`w/h`进行哈希计数，但注意用<b>最简分数</b>，而不要用<b>浮点值</b>，避免出现精度问题。写一个<b>gcd函数</b>，用于约分。统计对数，用`C(n,2)=n*(n-1)/2`计算。总代价`O(n)`。

<hr>

2002 Maximum Product of the Length of Two Palindromic Subsequences

题意：给定字符串s，请从中选出两个不相交（没有共用字符）的<b>回文子序列</b>，使得它们的长度`n1*n2`最大。

难度：medium

解法：在没看数据量时，就判断这题<b>比较难</b>，除了暴力搜好像没什么思路。一看数据量，<b>果然非常小，暴力搜吧。</b>在给定数据量下，用位操作<b>稍微提提速</b>也可以，但差别不大。总代价`O(2^n)`。

<hr>

2006 Count Number of Pairs With Absolute Difference K

题意：给定数组nums，请求出`|nums[i]-nums[j]|==k`的对数。

难度：easy

解法：水题，<b>哈希计数</b>即可。对于当前元素`nums[i]`，查询`mm[nums[i]-k]+mm[nums[i]+k]`，总代价`O(n)`。

<hr>

2011 Final Value of Variable After Performing Operations

题意：给定变量X，初始值为0。现在执行一些`++、--`操作，请求出最终值。

难度：easy

解法：水题。

<hr>

2013 Detect Squares

题意：请设计一个数据结构，可以向其中添加点`(x,y)`。给定一个查询点`(qx,qy)`，可以在其中查找三个点使得这四点组成一个xy轴对齐的<b>正方形</b>，并返回满足要求的<b>不同正方形的个数</b>。重复点视为不同点。

难度：medium

解法：对于给定点`(qx,qy)`作为一个角，我们可以尝试枚举<b>对角</b>`(x,y)`。那么剩余两个角就是确定的，`(qx,y)`和`(x,qy)`，而且`abs(qx-x)==abs(qy-y)`。枚举对角的代价是`O(n)`，剩余两个角都可以`O(1)`代价查出。对于点的存储，我们可以用<b>双层哈希表</b>，`mx[x][y]=cc`表示`(x,y)`的个数；`my[y][x]=cc`表示`(x,y)`的个数。这样我就能从x、y坐标快速找出<b>某个点的个数</b>。以本题的数据量，n个点进行m次`count()`查询，总代价是`O(mn)`，可以接受。对于某些编程语言，可以直接用`mm[(x,y)]`的形式进行哈希，这样就更方便了。

<hr>

2016 Maximum Difference Between Increasing Elements

题意：给定数组nums，如果`i<j,nums[i]<nums[j]`，请求出`max(nums[j]-nums[i])`。

难度：easy

解法：题意很明确，数据量也很小，<b>直接枚举</b>即可。总代价`O(n^2)`。当然，你如果想找个<b>优化解法</b>，也不难。我们找出<b>后缀max</b>，那么答案就是`max(后缀max-nums[i])`，总代价`O(n)`。反过来，用<b>前缀min</b>道理也是一样的。

<hr>

2022 Convert 1D Array Into 2D Array

题意：给定一维数组，请按照<b>行优先</b>顺序，转为m x n二维数组。

难度：easy

解法：这就是<b>reshape、resize</b>功能，<b>numpy</b>里的最常用功能。n维数组在计算机里存储，其实就是按`n-1、n-2、...、0`维这么存的。我们说<b>“行优先（row-major）”</b>其实指的是我`a[i][j]`<b>第一个下标</b>取的是<b>i行</b>。

<hr>

2023 Number of Pairs of Strings With Concatenation Equal to Target

题意：给定一组数字串nums，给定一个目标串target。请求出`nums[i]+nums[j]==target`的对数。

难度：medium

解法：其实是不是<b>数字串</b>完全<b>无所谓</b>。我们只关心<b>前缀匹配、后缀匹配</b>。我针对每个串，和target比较，判断是否为前缀、长度多少；是否为后缀、长度多少。那么对于<b>长度t的target</b>，我需要找出`pref+suf==target,len(pref)+len(suf)==t`这样的情况。针对前缀lp、后缀ls进行计数，然后求出`sum(mp[lp]*ms[t-lp])`，但是要减去<b>一种特殊情况</b>。就是一个串<b>同时是前缀、后缀</b>的情况，比如`'77'+'77'='7777'`。总代价`O(n)`。

<hr>

2024 Maximize the Confusion of an Exam

题意：给定一个长度为n的TF串。你可以选择至多k个值进行修改。请求出能得到的最长的<b>单值子串长度</b>。

难度：medium

解法：现在看来，一眼<b>滑动窗口</b>。但我当年好像想了很久才想明白。我们可以考虑把T改为F，找最长的F串；或者把F改为T，找最长的T串。总之，都是找<b>y个数不超过k个</b>的最长子串，把y改为x，就变成全x串。写一个`slide()`函数，然后执行两次`return max(slide(s,'T','F'),slide(s,'F','T'))`即可。总代价`O(n)`。

<hr>

2027 Minimum Moves to Convert String

题意：给定XO串s，每次你可以选<b>连续3个字符</b>转为O。请问至少多少次，能把s变成<b>全O</b>？

难度：easy

解法：水题。

<hr>

2028 Find Missing Observations

题意：你观察了`n+m`次<b>6面色子</b>的结果，但<b>n次记录丢失了</b>，只剩m次。你还记录了`n+m`次的<b>均值</b>。现在给定m次记录、平均值mean、n，请给出一种<b>可能的n次记录</b>。如果无解，则返回空数组。

难度：medium

解法：`mean*(n+m)-sum(rolls)`，这就是n次的总和。按这个总和，<b>平均分配一下</b>就行了。如果平均下来发现`<1`或者`>6`，则无解。总代价`O(n)`。其实基本算`O(1)`，只是最后<b>生成结果</b>需要`O(n)`代价。

<hr>

2032 Two Out of Three

题意：给定数组nums1、nums2、nums3，请求出至少在<b>其中两个数组</b>出现的值。

难度：easy

解法：先转为<b>集合</b>s1、s2、s3，然后`list((s1&s2)|(s2&s3)|(s3&s1))`。

<hr>

2033 Minimum Operations to Make a Uni-Value Grid

题意：给定m x n矩阵，每次你可以选任意元素，+x或-x。请问至少多少次操作，能把矩阵变为<b>单值</b>。返回最小次数，如果做不到则返回-1。

难度：medium

解法：比如我们选一个val，把所有元素都变为val。那么总代价就是`sum(|a[i][j]-val|)/x`，也就是<b>差值的绝对值求和</b>。如果你之前见过，可能知道这个的<b>最优解就是中位数</b>。不知道的话，就要<b>走点弯路</b>了。对于中位数，可以通过排序（或者quickSelect算法）求出。得到中位数以后，按照上面提到的公式，求出结果即可。总代价`O(mnlog(mn))`。此处还要注意，如果存在`(a[i][j]-min_val)%x!=0`，那就<b>无解</b>。因为你每次<b>只能`+-x`</b>。<b>一切变化</b>，都必须是x的倍数。

<hr>

2037 Minimum Number of Moves to Seat Everyone

题意：有n个同学和n个板凳。同学位置是`students[i]`，板凳位置是`seats[i]`。现在板凳位置固定，每次允许你选一个同学，移动`+-1`格。请问至少多少次，才能让每个同学各坐到一个板凳？

难度：easy

解法：把板凳按位置<b>排序</b>，把同学按位置<b>排序</b>，然后<b>按顺序分配</b>，计算距离即可。为什么<b>按顺序</b>就可以？因为你<b>交换</b>两个同学的位置，这个<b>“交叉分配”</b>只可能导致总距离<b>变大或者保持相同</b>，而<b>不可能变小</b>。总代价`O(nlogn)`。不用想复杂，easy难度这就够了。人生没有<b>难度标注</b>，但题目有，这本身就是重要提示。

<hr>

2038 Remove Colored Pieces if Both Neighbors are the Same Color

题意：有个长度为n的AB串，表示AB两种颜色的棋子。Alice和Bob轮流拿走棋子。如果存在AAA，则Alice拿走中间的A；如果存在BBB，则Bob拿走中间的B。如果某人<b>无法继续</b>，则另一方赢得比赛。请判断Alice是否必胜？

难度：medium

解法：这不太像个博弈论问题，因为A和B各自是<b>完全不相干</b>的。比如AAAAA、BBBB，那么A一定可以拿3次，B一定可以拿2次。各自做什么，都不会影响对方的决策。所以我在注释里写了句`# what's there to be optimal?`，这就没什么可“最优”的，对吧？统计双方能拿的个数，如果`ca>cb`，就是A赢，否则B赢。鉴定为专门<b>嘲讽智力题</b>的<b>智力题的智力题</b>，有一种<b>幽默的幽默感</b>。

<hr>

2039 The Time When the Network Becomes Idle

题意：有n个服务器组成的<b>全连通无向图</b>，编号`0~n-1`。已知<b>直连的两个服务器</b>uv之间，可以通过<b>1s</b>传递一次消息。0号是<b>主服务器</b>，其他都是<b>数据服务器</b>。在0时刻，所有数据服务器都向0号机发送请求，请求按照<b>各自的最短路径</b>前进，到达0号后，瞬间处理完。反馈消息按照<b>原路返回</b>，直到到达各自机器。已知每个数据服务器有等待时间`paitence[i]`，<b>每经过</b>`patience[i]`时间如果没有收到反馈，则重发一条，直到收到反馈为止。请求出所有消息都发完，所有服务器<b>变为空闲</b>的时刻。

难度：medium

解法：这题挺难，首先<b>读懂题目</b>就很费劲。当然这题本身也很有意义，这是在给你讲一个<b>广播网络、失败重传机制</b>的问题。这是计算机网络<b>实际处理的问题</b>。我忘了为什么给这题<b>点了个踩</b>，可能是嫌题目<b>太啰嗦了</b>，啰嗦得出奇。问题的大致模型，我想你已经看懂了。无向图，最短路径。<b>我发，你回。你还没回，我就一直发。</b>直到所有人都<b>发完了，回完了</b>。那么我们先通过BFS，把<b>单源最短路径</b>求出来。比如最短路径是5，耐心值是3。那么来回需要的时间是10，在10的过程中，我在[3,6,9]时刻进行了重发。按这个时间，分情况计算重传次数，以及最后一条消息的到达时间。就这都要分3种情况讨论，我懒得细说了，看代码吧。这个破题，明明是medium难度，复杂程度令人无语。<b>难怪我会点踩。</b>总代价`O(V+E)`。当然，还是要说一句，能把<b>计算机网络</b>学明白的人，都是<b>大佬</b>。实际的网络协议比这个还复杂一万倍，处理的各种<b>拥塞、限流、乱序、重传</b>等问题，难。

<hr>

2042 Check if Numbers Are Ascending in a Sentence

题意：给定一个英文句子，提取其中的整数，判断是否严格递增。

难度：easy

解法：<b>字符串处理</b>，找出其中的数。这个可以用<b>正则匹配</b>一次找出来。`re.findall(r'\d+',s)`，转为整数数组，判断递增即可。总代价`O(n)`。

<hr>

2043 Simple Bank System

题意：设计一个简易的<b>银行系统</b>，支持存款、取款、转账。有n个账户，用`balance[i]`表示。现在给定一些交易，如果交易不会导致透支，则执行并返回true；如果会透支，则忽略并返回false。

难度：medium

解法：<b>题意很明确</b>，按题意指定的方式，模拟整个过程即可。每种操作的代价都是`O(1)`。注意检查转出、取款时的<b>余额是否足够</b>，不够则返回false。


<hr>

2044 Count Number of Maximum Bitwise-OR Subsets

题意：给定数组nums，请求出其中子集的<b>最大按位或</b>的值max_or。并求出等于这个max_or的不同子集的个数。

难度：medium

解法：一眼暴力枚举，看了下数据量，果然猜对了。<b>暴力枚举</b>即可。总代价`O(2^n)`。

<hr>

2045 Second Minimum Time to Reach Destination

题意：有一个无向图，你需要从1点到达n点。给定一些边`[u,v]`，每条边的权重都是time，代表<b>time分钟</b>。但事情没这么简单，有红绿灯。你只能在绿灯时<b>开始移动</b>。且红绿灯<b>每change分钟</b>变一次，<b>0时刻</b>是绿灯。如果允许你在多次访问任意点、任意边，但不能违反<b>红绿灯规则</b>。请求出从1到达n的<b>第二短时间</b>。

难度：hard

解法：这题也相当复杂，已经加了个<b>红绿灯</b>，还让你求<b>第二短</b>。因为我可以反复访问任何点、任何边，我考虑用DFS去处理。但发现容易陷入死循环。既然DFS不好做，而且涉及最短路，那我就用<b>最小堆+BFS</b>好了。对于第二短，我们可以通过<b>修改终止条件</b>来满足。本来是<b>搜到就终止</b>，现在改成<b>搜到第二个就终止</b>。至于红绿灯等待问题，则可以通过判断当前时刻cur是不是红灯，如果是<b>红灯</b>，则要等待到<b>下一个绿灯</b>才能<b>出发</b>。因为我可以重复访问<b>任意点任意边</b>，这里就不需要<b>`visited`判断</b>了。总代价应该还是`O(V+E)`。因为我找的是<b>第二短路径</b>，至多比最短路径重复一遍，`*2`也还是<b>同复杂度</b>。这个hard是<b>真hard</b>，又难又麻烦。

<hr>

2046 Sort Linked List Already Sorted Using Absolute Values

题意：给定链表，这个链表按照<b>绝对值</b>升序排列。请将其按实际值升序排列。

难度：medium

解法：付费题。分离出<b>负数和非负数</b>两个链表l1、l2。那么结果就是`reverse(l1)+l2`。负数是<b>倒序</b>的，非负数是<b>顺序</b>的。那么我只需要O(n)操作，不用再进行排序。总代价`O(n)`。

<hr>

2047 Number of Valid Words in a Sentence

题意：给定一个英文句子，请判断其中合法单词的个数。合法单词可以是纯`a~z`，也可以<b>中间</b>带有`-`连字符，不能包含数字。注意句子末尾<b>可能有标点</b>，也可能没有。

难度：easy

解法：很无聊的一题。可以直接<b>正则匹配</b>，也可以split之后，手工检查。

<hr>

2049 Count Nodes With the Highest Score

题意：有一个二叉树，节点编号`0~n-1`。用`parents[i]`<b>父节点数组</b>的形式表示。其中0点是根，`parents[0]=-1`。现在我们考虑节点i，如果把i连接的边删除，则会分成几个不同的子树，我们把分成所有子树的节点个数乘起来，作为`scores[i]`。请求出`scores[i]==max(scores)`的个数。

难度：medium

解法：在给定的数据量下，我们需要一个`O(n)`的解法。其实很容易想，我先parents数组，把这个二叉树<b>重建起来</b>。然后用<b>二叉树</b>的形式，做<b>后序遍历</b>。统计出cc_left、cc_right，如果等于0表示<b>空子树</b>，忽略0值。那么<b>头顶</b>那棵<b>剩余的子树</b>，大小就是`n-cc_left-cc_right`。把其中的非零值乘起来，就是`scores[i]`。这个统计过程对于每个节点都是O(1)代价得到的，因此总代价`O(n)`。得到scores数组后，求`max_val`然后统计`==max_val`的个数即可。总代价`O(n)`。其实你也不需要构建二叉树，用<b>无向图</b>的形式，直接从0开始搜索，结果是一样的。

<hr>

2050 Parallel Courses III

题意：1136的变体。给定n门课，完成每个课的时间是`time[i]`。存在一些前置顺序`[x,y]`，表示必须<b>先完成x才能学y</b>。请求出至少多长时间，才能完成所有课。对于没有前置关系的课，你可以<b>同时学习多门</b>。

难度：hard

解法：这题的前两题我都没做，这是第三题了。就当一道<b>新题</b>吧。这题当然是个<b>有向图</b>的图论问题。有前置顺序，那很容易想到<b>拓扑排序</b>，先后关系嘛。我们给拓扑排序加一个time计算的逻辑。以<b>入度为0</b>的点作为<b>起始点</b>，起始`t=0`。随着往后走，累加`time[i]`<b>越变越大</b>。对于某个点`i`，可能存在<b>多个前置</b>，也就是通过<b>不同路径</b>到达`i`。那么不同路径的<b>路径和</b>当然<b>有大有小</b>，我们需要取这些路径的`max()`，也就是<b>最晚时间</b>。总结一下思路，就是<b>拓扑排序BFS+路径和取max</b>。总代价`O(V+E)`。

<hr>

2053 Kth Distinct String in an Array

题意：给定字符串数组arr，请按出现顺序，找出其中<b>第k个唯一值</b>。如果不足k个，则返回空串。

难度：easy

解法：先<b>哈希计数</b>，找出唯一值。然后再遍历一次，找出第k个唯一值。

<hr>

2054 Two Best Non-Overlapping Events

题意：给定一些事件，格式为`[s,e,v]`表示s开始、e结束、价值为v。请选出<b>至多两个</b>不重叠的事件，使得价值之和最大。

难度：medium

解法：先按照`[s,e]`二维进行<b>排序</b>，对于每个`[s[i],e[i]]`，我都按照`bisect_right(arr,e[i])`查找查找<b>最小的`s[j]`</b>。那么<b>从j以后的所有事件</b>，都不会产生冲突。可以用一个后缀max数组，记录v[j:n]的最大值。以`O(n)`代价进行预计算，之后可以`O(1)`查询。那么对于i位置，可得到的最大值就是`v[i]+max(v[j:n])`。排序和<b>n次二分查找</b>的代价都是O(nlogn)，因此总代价`O(nlogn)`。注意，题目说至多两个，还要考虑<b>一个事件</b>的情况。

<hr>

2057 Smallest Index With Equal Value

题意：给定数组nums，请找出最小的下标i，使得`i%10==nums[i]`。如果不存在则返回-1。

难度：easy

解法：水题。

<hr>

2058 Find the Minimum and Maximum Number of Nodes Between Critical Points

题意：给定链表，如果一个点<b>小于前后点</b>或者<b>大于前后点</b>，则称为<b>关键点</b>。请求出两个关键点的最大、最小距离。

难度：medium

解法：先找出关键点的位置`crits`。那么`min=min(crits[i]-crits[i-1])`，`max=crits[n-1]-crits[0]`。总代价`O(n)`。

<hr>

2062 Count Vowel Substrings of a String

题意：给定字符串s，请求出只包含`aeiou`且五个字符都有的子串的个数。

难度：easy

解法：以这个数据量，<b>直接枚举</b>也可以。如果要高效一点，那就滑动窗口+哈希计数吧。我选择直接枚举了，可以用位操作标记一下`aeiou`是否出现。总代价`O(n^2)`。

<hr>

2063 Vowels of All Substrings

题意：给定字符串s，请求出<b>所有子串</b>中，`aeiou`个数的总和。

难度：medium

解法：把问题<b>反过来看</b>，我们考虑每个`s[i]`在<b>多少个子串</b>中出现。比如`s[i]`，那么左边有`i`个，右边有`n-1-i`个，那么两边相乘，总共有`(i+1)*(n-i)`个子串。把所有元音的位置，按这个计算方式，累加起来，就是答案。总代价`O(n)`。这题的<b>思维</b>很好，一个问题你从<b>不同角度思考</b>，难度可能完全不同。

<hr>

2064 Minimized Maximum of Products Distributed to Any Store

题意：有n个商店，m种商品。m种商品的量分别是`quantities[i]`。你需要把所有商品分配到n个商店，要求每个商店只能有<b>一种商品</b>，数量是`stores[i]`，且要求`max(stores[i])`最小。请求出这个最小值。

难度：medium

解法：还是很经典的<b>minimax问题</b>，对这个`min(max(stores[i]))`直接做<b>二分搜索</b>。判断依据是，对于某个值x，我能否完成一种<b>分配方案</b>，使得`max(stores[i])<=x`。二分到<b>恰好x-1不行，x行</b>，则x就是答案。每次二分判断，相当于<b>尝试一次分配</b>，代价是`O(n)`。因此，总代价`O(nlog(int))`。

<hr>

2068 Check Whether Two Strings are Almost Equivalent

题意：给定字符串s1、s2，如果两者所有字符的频率之差都不超过3，则称为<b>接近</b>。请判断s1、s2是否接近。

难度：easy

解法：水题，按题意进行<b>哈希计数</b>即可。

<hr>

2070 Most Beautiful Item for Each Query

题意：有n件商品，每件有`[p,b]`代表价格和颜值。你需要回答m个查询，每个查询的格式为，“<b>价格不超过</b>q的商品，<b>最大颜值</b>是多少”。

难度：medium

解法：很简单，<b>按照p值升序排列</b>，然后<b>针对b值求前缀max</b>。对于每次查询，执行`i=bisect_right(arr,q)-1`。如果`i==-1`，则返回0；如果`i>=0`，则返回`前缀max[i]`的b值。总代价`O(nlogn)`。

<hr>

2073 Time Needed to Buy Tickets

题意：有n个人排队，0是队头，n-1是队尾。`tickets[i]`表示第i人需要买的票数。但有个奇怪的规则，每人每次只能买1张。如果还没买够，则需要移动到队尾再排一次；如果买够了，则离开。已知每次买票需要花`1s`，请问第k个人买完票需要多少秒？

难度：easy

解法：我忘了这个数学模型在哪儿看过，<b>很眼熟</b>。按这题easy难度，<b>直接模拟</b>也可以的。有没有<b>更聪明</b>的解法？我们看例子`[5,1,2,8]`，比如我考虑i=2的情况。我们按照一个个离队的情况考虑`[5,1,2,8]->[4,1,7]->[3,6]->[3]->[]`。因此，其实我们可以将值进行排序。算算每个人离队时，总共花了多少秒。每次累加，就是`差值*剩余轮数`这么累加。但是最后一轮不能加满，因为第i人<b>不一定在队尾</b>，可能提前离开的。这个解法可以`O(nlogn)`解决。如果是纯模拟，总代价则是`O(n*max(tickets))。`我补了一份<b>优化解法</b>，AC验证过了。

<hr>

2074 Reverse Nodes in Even Length Groups

题意：给定链表，按照长度`1,2,3,...`进行分组。把所有<b>长度偶数</b>的组反转，返回调整后的链表。

难度：medium

解法：题意很明确，按要求处理即可。注意<b>边界case</b>。

<hr>

2078 Two Furthest Houses With Different Colors

题意：给定数组nums，请找出`(i,j)`，使得`nums[i]!=nums[j]`且`|i-j|`最大。返回这个最大差值。

难度：easy

解法：数据量很小，<b>直接枚举</b>即可。

<hr>

2079 Watering Plants

题意：有n个朵花，分别在`i=0,1,2,...,n-1`位置。-1位置有水源，你有一个容量`capacity`的水壶。每朵花需要的水量是`plants[i]`。现在从-1位置满水壶出发，<b>依次</b>给每朵花浇水。如果你的水不够了，则需要返回-1处装满水，而且不允许提前返回。如果移动1格需要1时间，请计算浇完所有花的<b>总时间</b>。

难度：medium

解法：题目<b>非常具体</b>，按题意模拟即可。整个过程是<b>100%确定的</b>，没有需要思考的事。总代价`O(n)`。

<hr>

2083 Substrings That Begin and End With the Same Letter

题意：给定字符串s，请求出开头结尾是<b>同一字符</b>的子串个数。

难度：medium

解法：付费题。单字符也算，这就有n个。然后考虑每种字符的出现次数cc。那么总共有`C(cc,2)=cc*(cc-1)/2`。因此，答案就是`n+sum(cc*(cc-1)/2)`。对于medium难度，这算是水题了。总代价`O(n)`。

<hr>

2085 Count Common Words With One Occurrence

题意：给定两个词表words1、words2，请求出在两个词表中都出现1次的单词。

难度：easy

解法：进行<b>哈希计数</b>，得到mm1、mm2，找出`mm1[w]==1,mm2[w]==1`的情况。总代价`O(n)`。

<hr>

2087 Minimum Cost Homecoming of a Robot in a Grid

题意：有一个m x n矩阵，机器人从`(sx,sy)`出发，要到达`(ex,ey)`。可以上下左右走，移动到i行代价为`rowCosts[i]`，移动到j列代价为`colCosts[j]`。请求出最小的总代价。

难度：medium

解法：这题太扯了，鉴定为<b>脑筋急转弯</b>。直接从sx到ex，从sy到ey即可。总代价`O(m+n)`。

<hr>

2088 Count Fertile Pyramids in a Land

题意：给定m x n的01矩阵，在其中统计正金字塔、倒金字塔的个数。金字塔按照`1,3,5,...`这样对称排列，<b>从上到下或者从下到上</b>。

难度：hard

解法：我们先考虑暴力枚举。如果我以每个`a[i][j]`为塔尖，向上或者向下枚举，那么一次枚举的代价就是`O(n^2)`，这太慢了。必然要减少重复计算，这就考虑到DP思想了。比如我考虑`dp[i][j]`为以`(i,j)`为塔尖的倒金字塔的最大层数。那么如果`a[i][j]==0`，则`dp[i][j]=0`；如果`a[i][j]==1`，则`dp[i][j]=min(dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1])+1`。你看，这个递推是`O(1)`的，这样总代价就降到`O(n^2)`了。正金字塔、倒金字塔的计算，都采用这个方式，不过<b>递推方向</b>是反过来的。看了下我<b>以前的代码</b>，和这个思路类似，但不完全相同。我也看不懂到底在做什么。

<hr>

2089 Find Target Indices After Sorting Array

题意：给定数组nums和目标值target。请将nums排序后，返回target值所有位置，升序排列。

难度：easy

解法：<b>先排序，然后二分查找</b>即可。顺序查找也行，反正<b>排序的代价</b>占大头。总代价`O(nlogn)`。

<hr>

2091 Removing Minimum and Maximum From Array

题意：给定数组nums，所有值都不同。请先找出min和max，然后删除它们。但要求必须从nums开头、结尾不断删除元素，不能直接删除这两个值。请求出最小的删除次数。

难度：medium

解法：找出min和max对应的位置i、j，不妨假设`i<j`。那么答案就是`min(j+1,n-i,i+1+n-j)`。要么从左，要么从右，要么两边删。总代价`O(n)`。

<hr>

2094 Finding 3-Digit Even Numbers

题意：给定数组digits，元素都是0~9的数字，可能有重复。请从中选出3个，组成<b>`>=100`的3位偶数</b>。请返回所有可能的<b>唯一值</b>，按<b>升序</b>排列。

难度：easy

解法：不要直接暴力搜索，先把digits转化为<b>哈希计数</b>，而且计数超过3就按3处理，因为你<b>只需要3位数</b>。接下来，搜索枚举即可。注意最后一位是<b>偶数</b>。结果按`sorted(set())`处理。

<hr>

2095 Delete the Middle Node of a Linked List

题意：给定n长度链表，删除中间节点。中点按照`floor(n/2)`处理。

难度：medium

解法：可以用<b>快慢指针</b>的方法定位到中点，或者说<b>中点的前一点</b>。这个更方便删除。总代价`O(n)`。

<hr>

2096 Step-By-Step Directions From a Binary Tree Node to Another

题意：给定二叉树和其中两个节点s、t。请求出从s到t的路径，用`ULR`表示<b>上左右</b>。

难度：medium

解法：首先，这个路径是<b>唯一的</b>，不存在“最短路”的说法，除非你走重复路。我们可以通过遍历，分别得到<b>从根到s、从根到t</b>的两条路径ps、pt。那么ps、pt的公共前缀部分，你可以删掉。比如例子`ps=0010,pt=011101`，公共前缀是`0`，这个删掉。剩下部分是`ps=010,pt=11101`，你需要`UUU`，然后`RRRLR`。那么答案就是`UUURRRLR`。看懂这个例子，就知道该怎么做了。总代价`O(n)`。

<hr>

2097 Valid Arrangement of Pairs

题意：给定一些数对`(x,y)`，请将其排序，使得相邻的数对都满足`y[i]==x[i+1]`，也就是<b>“首尾相接”</b>。给定数据保证<b>一定有解</b>。

难度：hard

解法：起初我以为是个<b>图论题</b>，但看了<b>数据量</b>，想了下思路，又觉得不是。后来想了下，还是图论。比如我从某点出发，走一条路径。如果能把<b>所有边都用完</b>，这就是答案。这就是<b>欧拉路径</b>，每条边恰好用一次。查了资料又想了想，最后用了一个<b>特殊判定条件</b>`outd[x]-ind[x]==1`，<b>出度-入度等于1</b>。满足这个条件的点，可以作为<b>遍历的起点</b>。但这样的点不一定存在，比如一个环路就不存在这种点，这时我们<b>随便选一个点</b>就行了。剩下就是常规的<b>有向图遍历</b>了。因为这个遍历是一定会成功的，因此<b>只搜索不回溯</b>。一边遍历，<b>一边删除图中的边</b>，并把边加入<b>结果集res</b>中。这叫<b>不走回头路</b>。遍历完成时，图<b>删光了</b>，结果也<b>填满了</b>。总代价`O(n)`。这题确实难，主要难点在于你首先要<b>建图</b>，然后得知道从<b>哪个点</b>开始遍历。

<hr>

2099 Find Subsequence of Length K With the Largest Sum

题意：给定数组nums，请找出长度为k的子序列，使得求和最大。返回<b>子序列</b>。

难度：easy

解法：先按照`(val,i)`排序，找出<b>k个最大的值</b>。把值取出来，再按照`(i,val)`排序，把顺序还原过来。这样就得到按<b>原顺序排列</b>的<b>最大的k个值</b>了。总代价`O(nlogn)`。

## 2101 - 2200

2102 Sequentially Ordinal Rank Tracker

题意：请设计一个数据结构，可以添加格式为`[名称,分数]`的数据，且第i次查询时，返回按`[-分数,+名称]`顺序的第i个值。

难度：hard

解法：需求本身很明确，那么关键就是<b>存储和排序</b>的<b>效率</b>了。分数降序、名称升序。如果我们直接以数组存储，插入有序，则插入代价是`O(n)`，查询`O(1)`。太慢，会超时。如果顺序插入，每次执行快速选择算法，则插入`O(1)`，查询`O(n)`。还是太慢。既然我们需要查询第i个，那么我们可以考虑用堆，但又<b>不能丢失数据</b>。因此，用两个堆，<b>最大堆+最小堆</b>。最大堆存前i个，最小堆存剩余的。我们总是保持最大堆的元素数量等于`i+1`，这样堆顶元素就是我们要的结果。插入过程中，左手倒右手，保持两个堆的大小顺序，以及最大堆的元素个数即可。这样插入代价是`O(logn)`，查询代价`O(1)`。讲了这么多，一看我的老代码，居然是有序插入的解法。就这居然还过了，看来<b>测试数据比较水</b>。看了下评论区，很多人都想到了<b>两个堆的解法</b>。

<hr>

2103 Rings and Rods

题意：有一些红绿蓝的环，套在10个柱子上。按照类似`R3`的格式，表示红环在3号柱子上。现在给定一个这样的字符串，请求出<b>集齐了3种颜色</b>的柱子的个数。

难度：easy

解法：水题，字符串解析即可。

<hr>

2104 Sum of Subarray Ranges

题意：给定一个数组，我们定义它的<b>范围</b>为`max(a)-min(a)`。给定数组nums，请求出它的所有子数组的<b>范围之和</b>。

难度：medium

解法：首先，`O(n^2)`的解法非常容易。我们用max、min两个值，枚举i位置，随着j向前移动，不断更新最大最小值，并累加`max-min`。每次更新的代价是O(1)，因此总代价`O(n^2)`。这也符合题目的暗示，但这题如果要动动脑子，应该能在`O(n)`时间，用类似<b>单调栈</b>的思路解决。往下读题目，果然有这句话。可以参考之前<b>“Next Greater Element”</b>的做法，细节就不说了。对于每个nums[i]，我们考虑它左边、右边第一个`>=它`的元素<b>有多远</b>，那么它就能做<b>多大范围的max</b>。对于min值，反之亦然。总代价`O(n)`。不过我写了个`O(n)`的版本，结果始终不对。可能有些细节没想明白。

<hr>

2108 Find First Palindromic String in the Array

题意：给定一些字符串words，找出第一个回文串。

难度：easy

解法：水题。

<hr>

2109 Adding Spaces to a String

题意：给定一个字符串s，和一些位置spaces。请在对应位置<b>插入空格</b>，返回修改的字符串。

难度：medium

解法：思路上没有难度，唯一的问题就是<b>字符串比较长</b>。你要考虑<b>插入移位</b>的问题。这个也好办，我们<b>从后往前</b>插入，这样每次移位的代价就是`O(1)`，而不是`O(n)`了。对于每个字符，注意计算好它的<b>偏移量</b>，比如前面有<b>k个空格</b>，那么偏移量就是<b>+k</b>。总代价`O(n)`。

<hr>

2110 Number of Smooth Descent Periods of a Stock

题意：给定数组prices，请求出`长度>=1`的<b>公差为-1</b>的<b>等差数列</b>个数。

难度：medium

解法：对于长度为n的等差数列，从中可以找出`n*(n+1)/2`个子数列。按这个方式统计求和即可。总代价`O(n)`。

<hr>

2113 Elements in Array After Removing and Replacing Elements

题意：给定一个数组nums，长度n。我们按照<b>周期2n</b>做一个循环操作。前n次，逐个从开头删除元素；后n次，逐个把刚才删除的元素依次补回来。比如`[1,2,3]`按照`[1,2,3]->[2,3]->[3]->[]->[1]->[1,2]->[1,2,3]`循环变化。0时刻数组保持完整，给定一些查询，按照`[t,i]`格式，请求出t时刻第i个元素的值。如果i越界，则返回-1。

难度：medium

解法：付费题。既然是<b>周期变化</b>，而且这个变化也不复杂，<b>找找规律</b>即可。你甚至<b>直接`O(n)`代价模拟</b>也是可以的。

<hr>

2114 Maximum Number of Words Found in Sentences

题意：给定一些英文句子，请求出单词的最大个数。

难度：easy

解法：水题，`len(split())`即可。

<hr>

2115 Find All Possible Recipes from Given Supplies

题意：做菜，有<b>菜谱和材料</b>，菜谱可能包含<b>其他菜谱</b>。现在给定一些<b>材料</b>，不限量供应。请问你能做出多少道菜？

难度：medium

解法：显然，是个<b>有向图的搜索问题</b>。那么应该<b>正搜还是反搜</b>？其实都可以，但更建议反搜。我们可以建立`材料->菜谱`反向图，然后从<b>给定的材料</b>作为搜索起点。执行BFS，总是把入度为0的节点加入队列，继续搜索。如果一个<b>菜谱的入度为0</b>，则代表<b>材料集齐了</b>。对于`A->B,B->A`这种情况，我们无所谓。因为入度始终不为0，<b>成环了</b>。总结一下，就是建立反向图，执行<b>类似拓扑排序</b>的算法。总代价`O(E)`。

<hr>

2119 A Number After a Double Reversal

题意：给定整数，将其数位反转再反转。反转时去掉前置0，请判断反转两次是否能与自身。

难度：easy

解法：水题，看<b>末尾有没有0</b>就行了。

<hr>

2120 Execution of All Suffix Instructions Staying in a Grid

题意：给定一个n x n网格，机器人从`[sx,sy]`出发。有一个长度为m的指令序列，机器人可以从第i个开始执行，<b>直到末尾</b>。但如果执行到某条会导致<b>出界</b>，则<b>停止</b>。针对每个执行i，请求出<b>从这条开始</b>，能执行的指令条数。

难度：medium

解法：题目问的是后缀，我们显然应该后后往前倒推。比如我考虑第i条指令执行的最终位置是`[xi,yi]`，第i-1条是L向左，那是不是代表第i-1条的最终位置就是`[xi,yi-1]`？并不是，你需要考虑<b>在中途</b>，是否有可能出界。因此我们要考虑的，其实是`minx、maxx、miny、maxy`。或者说，要记录机器人到达过的，最上、最下、最左、最右的<b>具体位置</b>，不仅是min、max值。然后根据第i-1条指令，比较是否越界。这样总体代价可以做到`O(m)`。不过越想越觉得<b>费劲</b>，最终还是放弃了。暴力解法，总代价`O(m^2)`直接模拟搞定。

<hr>

2124 Check if All A's Appears Before All B's

题意：给定一个ab串，请判断是否存在b在a前面的情况。

难度：easy

解法：水题，判断<b>“ba”</b>是否存在即可，总代价`O(n)`。

<hr>

2125 Number of Laser Beams in a Bank

题意：给定m x n的01矩阵bank，求出每行1的个数，去掉0值，得到数组nums。求出`sum(nums[i]*nums[i+1])`。

难度：medium

解法：题目其实非常简单，但描述<b>太啰嗦且充满迷惑性</b>。我直接把<b>关键思路</b>翻译出来，不写原题目了。总代价`O(mn)`。

<hr>

2126 Destroying Asteroids

题意：给定一些小行星。如果`星球质量>=小行星质量`，则可以<b>吃掉它</b>，否则就会被摧毁。如果可以<b>调整顺序</b>，请问星球能否吃掉所有小行星？

难度：medium

解法：排序即可。这个模型就是那个<b>Hero War游戏</b>的基本模型。`if x>=y: x+=y`，这样。

<hr>

2129 Capitalize the Title

题意：给定一些单词，`长度<3`则转小写；`长度>=3`则首字母大写。

难度：easy

解法：水题。

<hr>

2130 Maximum Twin Sum of a Linked List

题意：给定长度n的节点，n为偶数。我们定义`(1,n)(2,n-1),...`为<b>双子节点</b>，节点相加称为双子和。请求出最大双子和。

难度：medium

解法：可以在中点处分成两个链表，把<b>后半部分反转</b>。当然，也可以用一个<b>额外数组</b>保存求和，这样就不用反转链表了。总代价`O(n)`。

<hr>

2133 Check if Every Row and Column Contains All Numbers

题意：给定n x n方阵，请判断每行每列是否都包含了`1~n`。

难度：easy

解法：这个不是<b>幻方</b>，幻方还要求<b>两个对角线</b>。按要求检查即可。

<hr>

2134 Minimum Swaps to Group All 1's Together II

题意：1151的变体。给定一个01循环数组，你可以交换<b>任意元素任意次</b>。请问至少多少次，能<b>把1聚到一起</b>？

难度：medium

解法：这题我闹了个乌龙，把题读错了，以为交换必须是相邻的。循环数组，也就是说<b>类似`1100111`这种</b>也满足要求。因此，这等效于<b>把0聚到一起</b>。其实很简单，我们考虑1的个数n1、0的个数n0，`n0+n1==n`。那么我找<b>n1大小</b>的<b>1窗口</b>，我们希望窗口中<b>尽量都是1</b>。那么，其中<b>有多少个0</b>，我就要<b>交换多少次</b>。对0的情况，思路相同，反之亦然。因此，答案就是`min(min(n1窗口中0的个数),min(n0窗口中1的个数))`。总代价`O(n)`。

<hr>

2136 Earliest Possible Day of Full Bloom

题意：你有n盆花需要种。每盆分别需要`plantTime[i]`种植和`growTime[i]`自己生长。种植期间，你可以<b>分散时间</b>，但不能同一天种植多盆花。如果你可以合理安排顺序，请求出<b>所有花都开放</b>的最早时间。

难度：hard

解法：这个模型和打印机工作、任务调度的模型有点像。一般的原则是<b>小任务优先</b>。如果你先处理<b>繁重的大任务</b>，那更多的小任务就需要<b>等很久</b>。但要注意，这个<b>排序</b>是有讲究的。应该按`(-生长时间,+种植时间)`排序，我考虑了几种策略，这个策略是<b>试出来的</b>。<b>生长时间降序</b>，这样可以让生长时间更长的，先种下去。种植时间升序，这个就是<b>小任务优先</b>的原则。总代价`O(nlogn)`。这题很容易想到排序，但<b>排序策略</b>有点难想。hard就是难在这儿了。

<hr>

2138 Divide a String Into Groups of Size k

题意：给定字符串，请分成<b>长度k</b>的多个子串，如果最后一个不足k字符，则填充字符fill。

难度：easy

解法：水题。

<hr>

2139 Minimum Moves to Reach Target Score

题意：从1开始，每次你可以选择`+1`或者`*2`。`+1`次数无限，`*2`<b>至多k次</b>。请求出得到目标值target的最小次数。

难度：medium

解法：我们从target出发，<b>反着搜</b>。那么`-1`次数无限，`/2`至多k次。可以用`(当前值,剩余/2次数,已用次数)`表示搜索状态，<b>执行BFS</b>。剩下就不用说了。总代价介于`O(target)`到`O(log(target))`之间。

<hr>

2140 Solving Questions With Brainpower

题意：有n个问题，你需要<b>依次</b>回答。每个问题得分为points[i]，但如果你选择i问题，则需要跳过随后的`brainpower[i]`个问题。现在给定格式为`[points,brainpower]`的数据，请选择问题，使得<b>总分最大</b>。返回总分。

难度：medium

解法：显然题目要求你给出`O(n)`解法。那么我们考虑第i个问题，既然我需要跳过之后的b[i]个，那我肯定关心从`i+b[i]+1`到`n-1`这些问题，我能得到的最大总分，于是<b>DP思路</b>就有了。定义`dp[i]`为`p[i:n]`中，我们能得到的最大总分。那么`dp[i]=max(p[i]+dp[i+b[i]+1],dp[i+1])`，<b>从后往前</b>递推。

<hr>

2144 Minimum Cost of Buying Candies With Discount

题意：有n个糖果，如果你买2个，则可以免费拿走1个。但要求拿走糖果的价格，不能超过min(买的糖果)。请求出能<b>买走所有糖果</b>，需要准备的<b>最少金额</b>。

难度：easy

解法：排序，然后按照<b>买3、2拿1</b>的方式，三个一组这样处理。总代价`O(nlogn)`。

<hr>

2148 Count Elements With Strictly Smaller and Greater Elements 

题意：给定数组nums，请求出其中<b>非最大值、最小值</b>的元素个数。

难度：easy

解法：水题。

<hr>

2149 Rearrange Array Elements by Sign

题意：给定数组nums，长度2n，有n正n负。请进行排序，使得数组按照<b>“正负正负...”</b>交替顺序，且正数、负数内部均按照原本的<b>先后顺序</b>。

难度：medium

解法：题目还特地提示你，<b>不用in-place</b>。出题人算是<b>很厚道</b>了，不浪费大家的脑细胞。用一个<b>辅助数组</b>来存放即可。

<hr>

2150 Find All Lonely Numbers in the Array

题意：给定数组nums，请找出其中所有的孤独值x。要求是，`x`出现一次，且`x+1`、`x-1`没有出现。返回所有值。

难度：medium

解法：<b>哈希计数</b>，遍历两次即可。对于medium难度，这题有点过于简单了。

<hr>

2154 Keep Multiplying Found Values by Two

题意：给定数组nums，从original开始，不断在nums中查找这个值。如果存在，则`*2`继续找；如果不存在，则停止。请返回第一个不存在的值。

难度：easy

解法：存入<b>哈希表</b>再找就行了。

<hr>

2155 All Divisions With the Highest Score of a Binary Array

题意：给定01数组nums，允许你从`i~[0,n]`任意位置将数组分为左右两部分，两部分均<b>允许为空</b>。我们定义得分为`左边0的个数+右边1的个数`，请求出所有能得到<b>最大分数</b>的<b>i的位置</b>。

难度：medium

解法：我们先统计出<b>0的总数、1的总数</b>。然后从i=0开始，逐步右移。一边移动一边更新左0右1的统计。一边更新统计，一边比较得出max值并记录下标。单次更新的代价是`O(1)`，因此遍历的总代价是`O(n)`。

<hr>

2160 Minimum Sum of Four Digit Number After Splitting Digits

题意：给定四位数，请从中选数，组成两个整数，使得<b>和最小</b>。数位顺序可以随意调整。

难度：easy

解法：水题。

<hr>

2161 Partition Array According to Given Pivot

题意：给定数组nums和一个阈值pivot。请对nums排序，使得小于、等于、大于pivot的元素按照前中后顺序排列。要求三组中，每组的内部保持<b>原有顺序</b>。

难度：medium

解法：方法很多，比如你可以先统计三组的数量`n1、n2、n3`，算好<b>偏移量</b>。然后再遍历一次，把元素放入对应组的对应位置。你也可以<b>遍历三次</b>，每次处理一组。总之，都是需要一个<b>额外数组</b>作为<b>临时存放</b>的。总代价`O(n)`。

<hr>

2164 Sort Even and Odd Indices Independently

题意：给定数组nums，请对<b>奇数位置</b>降序排列，<b>偶数位置</b>升序排列。

难度：easy

解法：这个用python的slicing写法相当方便，属于<b>语法糖</b>的完美应用。`a[0::2]=sorted(a[0::2]) a[1::2]=sorted(a[1::2],reverse=True)`。

<hr>

2165 Smallest Value of the Rearranged Number

题意：给定整数num，请重排数位，使得值最小。不能有<b>前置0</b>。

难度：medium

解法：考虑下<b>正数、负数</b>各应该怎么处理。举例子，`10086、-9870`。

<hr>

2169 Count Operations to Obtain Zero

题意：给定整数x、y，如果`x>=y`，则`x-=y`，<b>反之亦然</b>。经过多少步，其中一个可以变为0？

难度：easy

解法：水题，直接按题意计算即可。

<hr>

2176 Count Equal and Divisible Pairs in an Array

题意：给定数组nums和整数k，请求出`nums[i]==nums[j]`且`(i*j)%k==0`的`(i,j)`对数。

难度：easy

解法：数据量很小，直接枚举也行。总代价`O(n^2)`。

<hr>

2177 Find Three Consecutive Integers That Sum to a Given Number

题意：给定整数nums，请找出<b>连续的3个数</b>，加起来等于num。如果不存在，则返回空数组。

难度：medium

解法：水题，而且<b>低质量</b>。

<hr>

2178 Maximum Split of Positive Even Integers

题意：给定一个值sm，请求出一种求和方式，使得求和等于sm，且所有数都是<b>不同的偶数</b>，而且<b>元素个数最多</b>。

难度：medium

解法：其实按照<b>贪心原则</b>考虑就行了，我按照`2,4,6,8,...`这样慢慢加`+2`，加到<b>总和超过sm</b>，就不能加了。剩下就不用说了，用一点点数学，可以`O(1)`求出这个最大值。当然，<b>最终结果的规模</b>是`O(sqrt(sm))`的。

<hr>

2180 Count Integers With Even Digit Sum

题意：给定整数n，请求出`[1,n]`内，<b>数位和是偶数</b>的个数。

难度：easy

解法：数据范围很小，<b>直接枚举</b>也行。总代价`O(nlogn)`。如果数据范围很大的话，这题还是有点难度的，会变成一个<b>数位DP题</b>。

<hr>

2181 Merge Nodes in Between Zeros

题意：给定链表，请把其中<b>连续的非零节点</b>，合并为一个节点，节点值等于<b>求和</b>。所有合并的节点<b>连起来</b>，作为一个新链表返回。

难度：medium

解法：题目很清晰，按要求实现即可。总代价`O(n)`。

<hr>

2182 Construct String With Repeat Limit

题意：给定字符串s和整数k。你可以从s中选出字符，调整顺序，得到一个串t。要求t中不能有<b>连续k个相同字符</b>，且t的<b>字典序最大</b>。返回t。

难度：medium

解法：我们先对s进行<b>字符统计</b>，然后按<b>贪心原则</b>，<b>从大到小</b>取字符即可。代码实现要<b>注意一些细节</b>，比如<b>字典序大</b>的字符，应该<b>尽快用完</b>。总代价`O(n)`。

<hr>

2185 Counting Words With a Given Prefix

题意：给定词表words和前缀pref，请求出匹配前缀pref的单词个数。

难度：easy

解法：水题。

<hr>

2186 Minimum Number of Steps to Make Two Strings Anagram II

题意：1347的变体。给定字符串s和t，每次你可以给s或t添加一个字符。请问多少次操作可以使s和t互为anagram？

难度：medium

解法：这次是添加字符，那么我们对s和t做<b>哈希计数</b>，得到ms、mt。对于每个字符c，我们都取`mx=max(ms[c],mt[c])`，给两边<b>补足</b>到这个max值。补的个数`2*mx-ms[c]-mt[c]`，就是要<b>添加的次数</b>，<b>求和</b>就是最终答案。总代价`O(n)`。

<hr>

2190 Most Frequent Number Following Key In an Array

题意：给定数组nums和值key。请求出在key值<b>下一个位置</b>出现的值里，<b>频率最高</b>的值。

难度：easy

解法：水题，但是题目<b>不知所云</b>，加大了理解成本。

<hr>

2191 Sort the Jumbled Numbers

题意：给定一种`0~9`的<b>映射方式</b>，请将数组nums中元素的值映射，并按照<b>映射后的值</b>，进行排序。返回新顺序下<b>nums排序结果</b>。

难度：medium

解法：x变为`tp=(mapped(x),x)`，<b>排序</b>后取出`tp[1]`。总代价`O(nlogn)`。

<hr>

2192 All Ancestors of a Node in a Directed Acyclic Graph

题意：给定<b>有向无环图</b>，节点编号为`0~n-1`。给定其中的边`[x,y]`，请求出每个点i的<b>所有祖先节点</b>。如果从j<b>存在路径</b>到达i，则j为i的<b>祖先</b>。

难度：medium

解法：因为是DAG，就不存在环了。那么我们应该怎么搜，才不会做<b>重复计算</b>（至少不能<b>低效重复</b>）？答案是用<b>拓扑排序</b>的思路。我们从<b>入度为0</b>的点开始，执行BFS。这次要额外加上一个<b>祖先点集ancestor</b>。用`(x点,x的祖先点集)`作为搜索方式。那么对于`x->y`，我<b>删除这条边</b>，给`ind[y]-=1`，同时`ancestor[y]|=ancestor[x]`。但是注意，只有在`ind[y]==0`的情况下，我才<b>把y加入队列</b>。这样，随着拓扑往下走，<b>祖先点集</b>也通过<b>求并集，越变越大</b>。总代价`O(V^2+E)`。这个`O(V^2)`是免不了的，因为<b>结果集</b>就有这么大。

<hr>

2194 Cells in a Range on an Excel Sheet

题意：按照<b>Office Excel</b>的行列命名方式，给定左上、右下坐标，请按照<b>列优先</b>的顺序，返回所有格子坐标。

难度：easy

解法：<b>格式转换</b>，然后循环遍历即可。

<hr>

2196 Create Binary Tree From Descriptions

题意：给定一些格式为`[父节点值,节点值,是否左指针]`，请重建整个二叉树。已知二叉树的所有节点值都唯一。

难度：medium

解法：对`值->节点`做好映射，然后按照父子关系、左右指针，一个个拼起来。没有父节点的，就是<b>根</b>。总代价`O(n)`。

<hr>

2200 Find All K-Distant Indices in an Array

题意：给定数组nums，整数值key和k。请找出所有下标i，使得在`[i-k,i+k]`范围内，存在`nums[j]==key`。返回所有i值，升序排列。

难度：easy

解法：先找出所有<b>key值的出现位置</b>，得到数组ai。然后i=[0,n-1],j=[0,len(ai)-1]。<b>双指针向前</b>，比较`i`值和`ai[j]`值是否在`[-k,+k]`范围内。总代价`O(n)`。

## 2201 - 2300

2201 Count Artifacts That Can Be Extracted

题意：给定n x n地图，其中一些<b>矩形区域</b>里有宝贝。给定这些矩形区域的左上、右下坐标`artifacts`和你要挖开的一些坐标`dig`。矩形区域<b>互不重叠</b>。如果矩形区域<b>所有格子</b>都被挖开，则可以得到宝贝。请求出你能得到的宝贝数量。

难度：medium

解法：方法很多，主要思路就是做一个`格子->宝贝`的映射，这样当你挖开`(x,y)`位置，可以把对应宝贝的`格子计数-1`。如果减到0，就代表这个宝贝<b>挖到了</b>。总代价`O(n^2+na+nd)`。

<hr>

2206 Divide Array Into Equal Pairs

题意：给定数组nums，长度2n。请判断能否分为n对，使得每对的元素相等，类似`(x,x),(y,y)...`这样。

难度：easy

解法：水题。<b>哈希计数</b>，如果<b>计数都是偶数</b>，就可以。

<hr>

2210 Count Hills and Valleys in an Array

题意：给定nums，如果i位置的左右第一个不等于`nums[i]`的值，都小于`nums[i]`，则称为<b>山顶</b>。同理，如果都大于`nums[i]`，则称为<b>山谷</b>。请统计山顶、山谷的总数。

难度：easy

解法：数据量很小，直接`O(n^2)`枚举也行。

<hr>

2215 Find the Difference of Two Arrays

题意：给定数组nums1、nums2，请求出nums1中出现，但nums2中未出现的值；以及nums2中出现，但nums1中未出现的值。均返回<b>唯一值</b>。

难度：easy

解法：其实就是<b>集合的减法</b>。类似`list(set(a)-set(b))`这样。

<hr>

2220 Minimum Bit Flips to Convert Number

题意：给定整数x和y，请求出反转二进制位，从x变成y的反转次数。

难度：easy

解法：`countOne(x^y)`。

<hr>

2221 Find Triangular Sum of an Array

题意：给定数组nums，不断执行相邻元素求和`(nums[i]+nums[i+1])%10`，每次求和元素个数-1，直到最后<b>只剩一个值</b>。返回最终结果。

难度：medium

解法：稍微做一下推算，不难求出<b>每个元素</b>总共被<b>加了多少次</b>。其实就是<b>杨辉三角，二项式定理</b>。这题求的是`C(n,k)%10`，因为10是合数，<b>乘法逆元</b>不一定存在的。所以还是用笨办法，直接<b>累加求和</b>好了。总代价`O(n^2)`。

<hr>

2222 Number of Ways to Select Buildings

题意：给定长度为n的01串s，你需要选出长度3的子序列，使得子序列等于010或101。请问有多少种选法？

难度：medium

解法：有好几种思路，比如我统计出<b>所有`0`的位置p0</b>。然后再遍历一次，如果我遇到`1`，则`1`的左边x个`0`，右边y个`0`，就就有`x*y`种组合。随着向右移动，这个更新的代价是`O(1)`，总代价`O(n)`可以求出`010`的个数。对于`101`的情况，思路完全相同，只不过01反过来。还有一种“考虑<b>i位置之前有多少个0/1</b>”的计数方式，这种思路更类似<b>DP</b>，但总体上差不多，代价也是`O(n)`。

<hr>

2224 Minimum Number of Operations to Convert Time

题意：给定格式为`HH:MM`的两个时间t1、t2。你需要把t1变为t2，每次你可以增加1、5、15、60分钟。请问<b>至少几次</b>能变过来？

难度：easy

解法：注意考虑越过`00:00`的情况，比如从23点到2点。这个<b>不需要做搜索</b>，按贪心原则，+1h、+15m、+5m、+1m这样处理就行了。

<hr>

2225 Find Players With Zero or One Losses

题意：给定一些比赛结果`matches`，以`[x,y]`表示<b>x赢y</b>一次。请统计<b>0次失败、1次失败</b>的队伍列表，按升序排列。

难度：medium

解法：题意很明确，按要求统计，然后对结果排序即可。其实<b>顺序枚举</b>就行，结果本来就是有序的。总代价`O(n+nm)`。

<hr>

2231 Largest Number After Digit Swaps by Parity

题意：给定整数num，你可以把<b>同偶</b>或者<b>同奇</b>的数位交换。请求出能得到的最大数。

难度：easy

解法：那就分别对值为<b>偶数、奇数</b>的数位按<b>降序排列</b>。

<hr>

2232 Minimize Result by Adding Parentheses to Expression

题意：给定一个格式为`x+y`的算式，其中x、y都是整数，你可以在其中添加一个括号，使得<b>结果最小</b>。比如`12+34`，结果为46，但如果变为`1(2+3)4`，则表示`1*(2+3)*4`，结果为20。请返回变换后的<b>算式</b>。

难度：medium

解法：虽然这种奇怪的写法，并不符合实际的<b>算式规则</b>，但我们姑且按题目说的做吧。以这个数据量，直接<b>暴力搜索</b>，找到最小的结果就行了。或者说，枚举<b>两个括号</b>的位置，然后计算结果。总代价`O(n^2*n)=O(n^3)`。

<hr>

2235 Add Two Integers

题意：给定x、y，请求出`x+y`。

难度：easy

解法：水题，<b>令人震惊</b>的水题。

<hr>

2236 Root Equals Sum of Children

题意：给定三节点的二叉树，请判断`root.val`是否等于`left.val+right.val`。

难度：easy

解法：水题，可能和2235是同一个作者。

<hr>

2239 Find Closest Number to Zero

题意：给定数组nums，请找出<b>和0最接近的值</b>。如果有多个，则返回较大值。

难度：easy

解法：数组是无序的，那就按照`abs(x)`比较即可。总代价`O(n)`。

<hr>

2240 Number of Ways to Buy Pens and Pencils

题意：你有total的钱，钢笔cost1一个，铅笔cost2一个。请计算你可以买钢笔、铅笔的个数`(n1,n2)`的种类数。你不用花光所有钱。

难度：medium

解法：`n1*cost1+n2*cost2<=total`的整数解个数，这算是个最基础的<b>线性规划</b>问题了。当然，没必要想复杂。直接<b>一层循环，枚举求和</b>就行了。总代价`O(total/max(cost1,cost2))`，线性的。

<hr>

2243 Calculate Digit Sum of a String

题意：给定<b>数字串s</b>，按照每k个一组，计算<b>数位和</b>。结果连起来，重复这个过程，直到长度不超过k。返回最终结果。

难度：easy

解法：题意很明确，按描述实现即可。

<hr>

2244 Minimum Rounds to Complete All Tasks

题意：给定n个任务，每个的难度为`tasks[i]`。每次你可以选<b>2个或3个</b>同难度的任务完成。请问至少多少次，能完成所有任务？如果不可能完成，则返回-1。

难度：medium

解法：对难度值进行<b>哈希计数</b>，如果<b>计数为1</b>，则不可能完成。其他情况，按`(cc+2)/3`整除处理，结果累加。总代价`O(n)`。

<hr>

2248 Intersection of Multiple Arrays

题意：给定一些无序数组，请返回所有数组的<b>公共值</b>，按<b>升序</b>排列。

难度：easy

解法：转为<b>集合set()</b>，然后求<b>交集&</b>即可。

<hr>

2249 Count Lattice Points Inside a Circle

题意：给定一些圆的圆心和半径`[x,y,r]`，请判断其中包含的<b>整点</b>个数，在边缘上也算。对于被多个圆包含的点，只算一次。

难度：medium

解法：既然是<b>求并集</b>，那我们就不好用<b>纯数学</b>的解法了。还是要<b>枚举具体的点</b>，用集合做一下<b>判重</b>。在给定数据量下，一个`O(nr^2)`的<b>暴力解法</b>勉强可以接受。对于每个圆，我们直接把包含在内的点存入<b>集合</b>，最后统计`len(st)`就是答案。判定依据就是`dx^2+dy^2<=r^2`。总代价`O(nr^2)`。

<hr>

2255 Count Prefixes of a Given String

题意：给定词表words和字符串s。请判断words中，是<b>s前缀</b>的词的个数。

难度：easy

解法：水题。

<hr>

2257 Count Unguarded Cells in the Grid

题意：有一个m x n地图，其中部分格子有<b>守卫或者墙</b>，其余是空地。守卫位置是`guards[i]`，墙的位置是`walls[i]`。已知守卫可以监视上下左右四个方向，但如果<b>被墙挡住</b>，则视野受阻。请求出<b>没有守卫看到</b>的空地格子的数量。

难度：medium

解法：以<b>所有守卫</b>的位置为<b>起点</b>，按<b>上下左右</b>四个方向，<b>执行BFS</b>。如果搜到了墙，则停止<b>这个方向</b>的搜素。这就好比在某位置发出<b>四条激光</b>，看激光能往前走多远。这个激光是<b>不能转向、反弹的</b>。搜索结束后，<b>没有被搜到</b>的空地，就是守卫看不到的。总代价`O(mn)`。

<hr>

2259 Remove Digit From Number to Maximize Result

题意：给定数字串num和一个数位d。请从num中删除一个d，使得结果最大。

难度：easy

解法：数据很小，随便怎么处理都行。比如<b>枚举所有删法</b>，求出最大的一个。

<hr>

2260 Minimum Consecutive Cards to Pick Up

题意：给定数组nums，请找出两个下标(i,j)，使得`nums[i]==nums[j]`，且`|i-j|`最小。返回`|i-j|+1`。如果不存在，则返回-1。

难度：medium

解法：题目的意思<b>翻译过来</b>，就是如上所述。可以用<b>哈希表</b>，记录每个值最后出现的位置，也就是`mm[nums[i]]=i`。那么对于<b>重复出现</b>的值，则可以查出<b>上次出现</b>的位置j，找出`min(i-j+1)`即可。总代价`O(n)`。

<hr>

2261 K Divisible Elements Subarrays

题意：给定数组nums，请求出<b>至多包含k个p的倍数</b>的子数组的个数。

难度：medium

解法：至多，k个，p的倍数。三个要求，求子数组的个数。看起来还是<b>滑动窗口</b>的思路。那就滑动窗口吧。对了，<b>数据规模很小</b>，因此无需滑动窗口，直接`O(n^2)`枚举，用<b>前缀和</b>思路，可以做到`O(1)`代价判断一个子数组。这样的总代价是`O(n^2)`。如果用滑动窗口解法，则复杂度是`O(n)`。

<hr>

2264 Largest 3-Same-Digit Number in String

题意：给定一个数字串num，请找出其中最大的<b>三连数字</b>。比如`777、999`这样。

难度：easy

解法：水题。

<hr>

2265 Count Nodes Equal to Average of Subtree

题意：给定二叉树，请统计`节点值=mean(对应子树所有节点值)`的节点的个数。计算均值时，除法以<b>整除</b>为准。

难度：medium

解法：通过<b>后序遍历</b>，对子树<b>求和</b>，除以<b>节点个数</b>就得到了均值。判断均值和节点值是否相等。总代价`O(n)`。

<hr>

2269 Find the K-Beauty of a Number

题意：给定整数num和k。如果把num视为字符串，找出其中的<b>k长度子串</b>，且得到的值恰好也是<b>num的约数</b>的个数。

难度：easy

解法：不用做字符串操作，用`/10%10`的做法就可以。

<hr>

2273 Find Resultant Array After Removing Anagrams

题意：给定一个词表words，不断从中找出`(w[i-1],w[i])`，如果两者互为anagram，则删除`w[i]`。返回删除完成后的结果。

难度：easy

解法：判断anagram的方法，就是`sorted(s)==sorted(t)`。找出<b>连续的互为anagram</b>的一组词，只保留<b>每组的第一个</b>。总代价`O(n)`。

<hr>

2274 Maximum Consecutive Floors Without Special Floors

题意：给定一个房子，`[bottom,top]`楼层中，有一些`special[i]`层作为休闲用途。请求出<b>连续的不含休闲楼层的</b>最大层数。

难度：medium

解法：要么就是`special[i]-special[i-1]`，要么就是`bottom、top`和`special`两端的距离。总代价`O(n)`。

<hr>

2275 Largest Combination With Bitwise AND Greater Than Zero

题意：给定数组nums，请从其中选出元素，做<b>按位与</b>。要求结果大于0，请求出能选出的最大元素个数。

难度：medium

解法：需要一个`O(n)`的解法，当然不能暴力搜。乍一想，没什么好思路。那么我们<b>按位考虑</b>，比如某位`1<<i`，有nums中，有`cc[i]`个元素的<b>第i位是1</b>，那么答案其实就是`max(cc[i])`，就这么简单。当然，<b>想明白这个逻辑</b>，就没那么简单。为什么是<b>取max</b>，而不能是<b>加法</b>？我们考虑，比如随便<b>选k个元素</b>，按位与之后，结果的第i位是1。那么必有`k<=cc[i]`。因为你至多只能找到`cc[i]`个元素，使得这位等于1。既然<b>最大</b>只能到`cc[i]`，那<b>最大的最大</b>，也就是`max(cc[i])`了。挺难想的。总代价`O(nlog(int))`。

<hr>

2278 Percentage of Letter in String

题意：给定字符串s和字符c，请统计c在s中的百分比。精确到1%。

难度：easy

解法：水题。

<hr>

2279 Maximum Bags With Full Capacity of Rocks

题意：给定n个包，每个的容量是`capacity[i]`，已经装了`rocks[i]`个石头。如果你还有额外k个石头，可以装进包里。请问<b>至多</b>可以把几个包<b>装满</b>？

难度：medium

解法：按照`capacity[i]-rocks[i]`<b>升序排列</b>，那么靠前的就是剩余空间最小的。优先把<b>剩余空间少的</b>装满即可。总代价`O(nlogn)`。

<hr>

2283 Check if Number Has Equal Digit Count and Digit Value

题意：给定数字串num，请判断每个位置i是否恰好<b>出现`num[i]`次</b>。

难度：easy

解法：倒是挺奇怪的要求，按题目要求判断吧。

<hr>

2284 Sender With Largest Word Count

题意：有n条消息，消息内容为`messages[i]`，发送者为`senders[i]`。请统计<b>消息单词总数</b>最多的发送者。

难度：medium

解法：思路很直白。`split()`然后<b>统计个数</b>。用<b>哈希表</b>，按`senders[i]`名称累加，找出最大值即可。总代价`O(n)`。

<hr>

2285 Maximum Total Importance of Roads

题意：给定n个点组成的无向图，你需要给`0~n-1`这些点分配权值`vals=1~n`。对于一条边`[x,y]`，我们定义边的权值为`vals[x]+vals[y]`。请求出所有边的<b>权值之和</b>的最大值。

难度：medium

解法：按照<b>贪心原则</b>，一个点的<b>度数越大</b>，我们就应该给它<b>越高的权值</b>。因此，统计所有点的度数，<b>按度数</b>升序排列。然后<b>依次分配</b>`1~n`的权值。按分配的值，计算所有边的权值之和。总代价`O(VlogV+E)`。

<hr>

2287 Rearrange Characters to Make Target String

题意：给定字符串s和target。你可以从s中<b>选取字符并排序</b>，请问能拼出多少个target？

难度：easy

解法：<b>哈希计数</b>得到ms和mt，对于每个字符c，取`min(ms[c]//mt[c])`就是结果，<b>`//`表示整除</b>。总代价`O(ns+nt)`。

<hr>

2290 Minimum Obstacle Removal to Reach Corner

题意：给定一个m x n地图，你从`(0,0)`出发，要到达`(m-1,n-1)`。中间可能存在一些墙。你可以<b>挖穿</b>墙格子，来通过障碍。请问至少挖多少个墙，才能到达终点？

难度：hard

解法：很容易想到<b>BFS</b>的思路，那么对于空地，我们无障碍通过；对于墙格子，我们要<b>挖一下</b>才能过。因此，可以用`(当前位置,挖掘次数)`作为搜索状态，执行BFS。当到达<b>墙</b>的时候，<b>次数+1</b>；到达<b>空地</b>的时候，<b>次数保持不变</b>。对于hard难度，这题的<b>思维难度</b>其实还好。如果希望效率更高，可以选择<b>双向BFS</b>，实现更麻烦点就是了。

<hr>

2293 Min Max Game

题意：给定数组nums，对于奇数位置，取`max(nums[2i],nums[2i+1])`；对于偶数位置，取`min(nums[2i],nums[2i+1])`。不断执行这个变换，直到剩1个元素。返回<b>最终剩下的元素</b>。

难度：easy

解法：题意很明确，<b>直接模拟</b>即可。总代价`O(nlogn)`。

<hr>

2294 Partition Array Such That Maximum Difference Is K

题意：给定数组nums，将其<b>划分</b>为几个子序列，使得对于每个子序列ss，`max(ss)-min(ss)<=k`。请求出子序列的<b>最小个数</b>。

难度：medium

解法：既然是`max-min`，而且是子序列。那我们就<b>无所谓顺序</b>了。我们不妨把nums排序，得到`sorted_nums`。每次取<b>尽可能长的一段</b>，使的`sorted_nums[j]-sorted_nums[i]`<b>恰好不超过k</b>，这个边界可以通过<b>二分搜索</b>快速找到，当然<b>顺序枚举</b>也行。ij走到最后，划分也就完成了。总代价`O(nlogn+n)=O(nlogn)`。<b>代码非常简短</b>，比思路讲解简单多了。

<hr>

2295 Replace Elements in an Array

题意：给定数组nums，你需要执行m次形如`[x,y]`的操作，表示把x值都替换为y值。返回最终的数组。已知每个x都存在于nums中，且<b>每个y都不存在</b>于nums中。

难度：medium

解法：显然，如果你每次都以O(n)代价替换，那就太慢了。有没有更高效的做法？有，而且关键就在于y值都不存在于nums中。这点很重要。比如`[3,2,5,7]`，把7替换为3。这就导致<b>3出现了重复值</b>。这样就没法高效实现了。如果全程都能<b>保证唯一值</b>，那么我们每次变换都可以做到严格`O(1)`。只要我做好`i<->nums[i]`的<b>双向映射</b>，就可以了。总代价`O(n+m)`。

<hr>

2299 Strong Password Checker II

题意：420的变体。一个密码如果包含大写、小写、数字、特殊符号，则称为<b>强密码</b>。给定密码`password`，请判断是否够强。

难度：easy

解法：420挺麻烦，是个<b>最短编辑距离</b>的hard问题。这题是水题。按照题意，检查各种字符是否出现即可。不要用<b>正则魔法</b>，正则<b>非常不适合</b>这个场景。不但很难写，而且效率低下。
