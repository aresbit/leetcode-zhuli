# LeetCode 一句话题解 - 2001-2500

[返回目录](./README.md)

- [LeetCode 一句话题解 - 2001-2500](#leetcode-一句话题解---2001-2500)
  - [2001 - 2100](#2001---2100)

代码库地址：  
[https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/2001-2500](https://github.com/zhuli19901106/leetcode-zhuli/tree/master/algorithms/2001-2500)

## 2001 - 2100

2001 Number of Pairs of Interchangeable Rectangles

题意：给定n个矩形的长和宽，如果长宽比相同，则视为<b>等比例</b>。请求出等比例的<b>矩形对数</b>。

难度：medium

解法：我在这题尝试打开了<b>Copilot</b>，然后<b>tab一下</b>就全文背诵了。不得不说<b>做题家就是这样被消灭的</b>。你做的事情如果<b>机械重复</b>，不管曾经这件事情多么<b>“脑力密集”</b>，现在都变成<b>体力活儿</b>了。回到这题，本身确实不难。针对`w/h`进行哈希计数，但注意用<b>最简分数</b>，而不要用<b>浮点值</b>，避免出现精度问题。写一个<b>gcd函数</b>，用于约分。统计对数，用`C(n,2)=n*(n-1)/2`计算。总代价`O(n)`。

<hr>

2002 Maximum Product of the Length of Two Palindromic Subsequences

题意：给定字符串s，请从中选出两个不相交（没有共用字符）的<b>回文子序列</b>，使得它们的长度`n1*n2`最大。

难度：medium

解法：在没看数据量时，就判断这题<b>比较难</b>，除了暴力搜好像没什么思路。一看数据量，<b>果然非常小，暴力搜吧。</b>在给定数据量下，用位操作<b>稍微提提速</b>也可以，但差别不大。总代价`O(2^n)`。

<hr>

2006 Count Number of Pairs With Absolute Difference K

题意：给定数组nums，请求出`|nums[i]-nums[j]|==k`的对数。

难度：easy

解法：水题，<b>哈希计数</b>即可。对于当前元素`nums[i]`，查询`mm[nums[i]-k]+mm[nums[i]+k]`，总代价`O(n)`。

<hr>

2011 Final Value of Variable After Performing Operations

题意：给定变量X，初始值为0。现在执行一些`++、--`操作，请求出最终值。

难度：easy

解法：水题。

<hr>

2013 Detect Squares

题意：请设计一个数据结构，可以向其中添加点`(x,y)`。给定一个查询点`(qx,qy)`，可以在其中查找三个点使得这四点组成一个xy轴对齐的<b>正方形</b>，并返回满足要求的<b>不同正方形的个数</b>。重复点视为不同点。

难度：medium

解法：对于给定点`(qx,qy)`作为一个角，我们可以尝试枚举<b>对角</b>`(x,y)`。那么剩余两个角就是确定的，`(qx,y)`和`(x,qy)`，而且`abs(qx-x)==abs(qy-y)`。枚举对角的代价是`O(n)`，剩余两个角都可以`O(1)`代价查出。对于点的存储，我们可以用<b>双层哈希表</b>，`mx[x][y]=cc`表示`(x,y)`的个数；`my[y][x]=cc`表示`(x,y)`的个数。这样我就能从x、y坐标快速找出<b>某个点的个数</b>。以本题的数据量，n个点进行m次`count()`查询，总代价是`O(mn)`，可以接受。对于某些编程语言，可以直接用`mm[(x,y)]`的形式进行哈希，这样就更方便了。

<hr>

2016 Maximum Difference Between Increasing Elements

题意：给定数组nums，如果`i<j,nums[i]<nums[j]`，请求出`max(nums[j]-nums[i])`。

难度：easy

解法：题意很明确，数据量也很小，<b>直接枚举</b>即可。总代价`O(n^2)`。当然，你如果想找个<b>优化解法</b>，也不难。我们找出<b>后缀max</b>，那么答案就是`max(后缀max-nums[i])`，总代价`O(n)`。反过来，用<b>前缀min</b>道理也是一样的。

<hr>

2022 Convert 1D Array Into 2D Array

题意：给定一维数组，请按照<b>行优先</b>顺序，转为m x n二维数组。

难度：easy

解法：这就是<b>reshape、resize</b>功能，<b>numpy</b>里的最常用功能。n维数组在计算机里存储，其实就是按`n-1、n-2、...、0`维这么存的。我们说<b>“行优先（row-major）”</b>其实指的是我`a[i][j]`<b>第一个下标</b>取的是<b>i行</b>。

<hr>

2023 Number of Pairs of Strings With Concatenation Equal to Target

题意：给定一组数字串nums，给定一个目标串target。请求出`nums[i]+nums[j]==target`的对数。

难度：medium

解法：其实是不是<b>数字串</b>完全<b>无所谓</b>。我们只关心<b>前缀匹配、后缀匹配</b>。我针对每个串，和target比较，判断是否为前缀、长度多少；是否为后缀、长度多少。那么对于<b>长度t的target</b>，我需要找出`pref+suf==target,len(pref)+len(suf)==t`这样的情况。针对前缀lp、后缀ls进行计数，然后求出`sum(mp[lp]*ms[t-lp])`，但是要减去<b>一种特殊情况</b>。就是一个串<b>同时是前缀、后缀</b>的情况，比如`'77'+'77'='7777'`。总代价`O(n)`。

<hr>

2024 Maximize the Confusion of an Exam

题意：给定一个长度为n的TF串。你可以选择至多k个值进行修改。请求出能得到的最长的<b>单值子串长度</b>。

难度：medium

解法：现在看来，一眼<b>滑动窗口</b>。但我当年好像想了很久才想明白。我们可以考虑把T改为F，找最长的F串；或者把F改为T，找最长的T串。总之，都是找<b>y个数不超过k个</b>的最长子串，把y改为x，就变成全x串。写一个`slide()`函数，然后执行两次`return max(slide(s,'T','F'),slide(s,'F','T'))`即可。总代价`O(n)`。

<hr>

2027 Minimum Moves to Convert String

题意：给定XO串s，每次你可以选<b>连续3个字符</b>转为O。请问至少多少次，能把s变成<b>全O</b>？

难度：easy

解法：水题。

<hr>

2028 Find Missing Observations

题意：你观察了`n+m`次<b>6面色子</b>的结果，但<b>n次记录丢失了</b>，只剩m次。你还记录了`n+m`次的<b>均值</b>。现在给定m次记录、平均值mean、n，请给出一种<b>可能的n次记录</b>。如果无解，则返回空数组。

难度：medium

解法：`mean*(n+m)-sum(rolls)`，这就是n次的总和。按这个总和，<b>平均分配一下</b>就行了。如果平均下来发现`<1`或者`>6`，则无解。总代价`O(n)`。其实基本算`O(1)`，只是最后<b>生成结果</b>需要`O(n)`代价。

<hr>

2032 Two Out of Three

题意：给定数组nums1、nums2、nums3，请求出至少在<b>其中两个数组</b>出现的值。

难度：easy

解法：先转为<b>集合</b>s1、s2、s3，然后`list((s1&s2)|(s2&s3)|(s3&s1))`。

<hr>

2033 Minimum Operations to Make a Uni-Value Grid

题意：给定m x n矩阵，每次你可以选任意元素，+x或-x。请问至少多少次操作，能把矩阵变为<b>单值</b>。返回最小次数，如果做不到则返回-1。

难度：medium

解法：比如我们选一个val，把所有元素都变为val。那么总代价就是`sum(|a[i][j]-val|)/x`，也就是<b>差值的绝对值求和</b>。如果你之前见过，可能知道这个的<b>最优解就是中位数</b>。不知道的话，就要<b>走点弯路</b>了。对于中位数，可以通过排序（或者quickSelect算法）求出。得到中位数以后，按照上面提到的公式，求出结果即可。总代价`O(mnlog(mn))`。此处还要注意，如果存在`(a[i][j]-min_val)%x!=0`，那就<b>无解</b>。因为你每次<b>只能`+-x`</b>。<b>一切变化</b>，都必须是x的倍数。

<hr>

2037 Minimum Number of Moves to Seat Everyone

题意：有n个同学和n个板凳。同学位置是`students[i]`，板凳位置是`seats[i]`。现在板凳位置固定，每次允许你选一个同学，移动`+-1`格。请问至少多少次，才能让每个同学各坐到一个板凳？

难度：easy

解法：把板凳按位置<b>排序</b>，把同学按位置<b>排序</b>，然后<b>按顺序分配</b>，计算距离即可。为什么<b>按顺序</b>就可以？因为你<b>交换</b>两个同学的位置，这个<b>“交叉分配”</b>只可能导致总距离<b>变大或者保持相同</b>，而<b>不可能变小</b>。总代价`O(nlogn)`。不用想复杂，easy难度这就够了。人生没有<b>难度标注</b>，但题目有，这本身就是重要提示。

<hr>

2038 Remove Colored Pieces if Both Neighbors are the Same Color

题意：有个长度为n的AB串，表示AB两种颜色的棋子。Alice和Bob轮流拿走棋子。如果存在AAA，则Alice拿走中间的A；如果存在BBB，则Bob拿走中间的B。如果某人<b>无法继续</b>，则另一方赢得比赛。请判断Alice是否必胜？

难度：medium

解法：这不太像个博弈论问题，因为A和B各自是<b>完全不相干</b>的。比如AAAAA、BBBB，那么A一定可以拿3次，B一定可以拿2次。各自做什么，都不会影响对方的决策。所以我在注释里写了句`# what's there to be optimal?`，这就没什么可“最优”的，对吧？统计双方能拿的个数，如果`ca>cb`，就是A赢，否则B赢。鉴定为专门<b>嘲讽智力题</b>的<b>智力题的智力题</b>，有一种<b>幽默的幽默感</b>。

<hr>

2039 The Time When the Network Becomes Idle

题意：有n个服务器组成的<b>全连通无向图</b>，编号`0~n-1`。已知<b>直连的两个服务器</b>uv之间，可以通过<b>1s</b>传递一次消息。0号是<b>主服务器</b>，其他都是<b>数据服务器</b>。在0时刻，所有数据服务器都向0号机发送请求，请求按照<b>各自的最短路径</b>前进，到达0号后，瞬间处理完。反馈消息按照<b>原路返回</b>，直到到达各自机器。已知每个数据服务器有等待时间`paitence[i]`，<b>每经过</b>`patience[i]`时间如果没有收到反馈，则重发一条，直到收到反馈为止。请求出所有消息都发完，所有服务器<b>变为空闲</b>的时刻。

难度：medium

解法：这题挺难，首先<b>读懂题目</b>就很费劲。当然这题本身也很有意义，这是在给你讲一个<b>广播网络、失败重传机制</b>的问题。这是计算机网络<b>实际处理的问题</b>。我忘了为什么给这题<b>点了个踩</b>，可能是嫌题目<b>太啰嗦了</b>，啰嗦得出奇。问题的大致模型，我想你已经看懂了。无向图，最短路径。<b>我发，你回。你还没回，我就一直发。</b>直到所有人都<b>发完了，回完了</b>。那么我们先通过BFS，把<b>单源最短路径</b>求出来。比如最短路径是5，耐心值是3。那么来回需要的时间是10，在10的过程中，我在[3,6,9]时刻进行了重发。按这个时间，分情况计算重传次数，以及最后一条消息的到达时间。就这都要分3种情况讨论，我懒得细说了，看代码吧。这个破题，明明是medium难度，复杂程度令人无语。<b>难怪我会点踩。</b>总代价`O(V+E)`。当然，还是要说一句，能把<b>计算机网络</b>学明白的人，都是<b>大佬</b>。实际的网络协议比这个还复杂一万倍，处理的各种<b>拥塞、限流、乱序、重传</b>等问题，难。

<hr>

2042 Check if Numbers Are Ascending in a Sentence

题意：给定一个英文句子，提取其中的整数，判断是否严格递增。

难度：easy

解法：<b>字符串处理</b>，找出其中的数。这个可以用<b>正则匹配</b>一次找出来。`re.findall(r'\d+',s)`，转为整数数组，判断递增即可。总代价`O(n)`。

<hr>

2043 Simple Bank System

题意：设计一个简易的<b>银行系统</b>，支持存款、取款、转账。有n个账户，用`balance[i]`表示。现在给定一些交易，如果交易不会导致透支，则执行并返回true；如果会透支，则忽略并返回false。

难度：medium

解法：<b>题意很明确</b>，按题意指定的方式，模拟整个过程即可。每种操作的代价都是`O(1)`。注意检查转出、取款时的<b>余额是否足够</b>，不够则返回false。


<hr>

2044 Count Number of Maximum Bitwise-OR Subsets

题意：给定数组nums，请求出其中子集的<b>最大按位或</b>的值max_or。并求出等于这个max_or的不同子集的个数。

难度：medium

解法：一眼暴力枚举，看了下数据量，果然猜对了。<b>暴力枚举</b>即可。总代价`O(2^n)`。

<hr>

2045 Second Minimum Time to Reach Destination

题意：有一个无向图，你需要从1点到达n点。给定一些边`[u,v]`，每条边的权重都是time，代表<b>time分钟</b>。但事情没这么简单，有红绿灯。你只能在绿灯时<b>开始移动</b>。且红绿灯<b>每change分钟</b>变一次，<b>0时刻</b>是绿灯。如果允许你在多次访问任意点、任意边，但不能违反<b>红绿灯规则</b>。请求出从1到达n的<b>第二短时间</b>。

难度：hard

解法：这题也相当复杂，已经加了个<b>红绿灯</b>，还让你求<b>第二短</b>。因为我可以反复访问任何点、任何边，我考虑用DFS去处理。但发现容易陷入死循环。既然DFS不好做，而且涉及最短路，那我就用<b>最小堆+BFS</b>好了。对于第二短，我们可以通过<b>修改终止条件</b>来满足。本来是<b>搜到就终止</b>，现在改成<b>搜到第二个就终止</b>。至于红绿灯等待问题，则可以通过判断当前时刻cur是不是红灯，如果是<b>红灯</b>，则要等待到<b>下一个绿灯</b>才能<b>出发</b>。因为我可以重复访问<b>任意点任意边</b>，这里就不需要<b>`visited`判断</b>了。总代价应该还是`O(V+E)`。因为我找的是<b>第二短路径</b>，至多比最短路径重复一遍，`*2`也还是<b>同复杂度</b>。这个hard是<b>真hard</b>，又难又麻烦。

<hr>

2046 Sort Linked List Already Sorted Using Absolute Values

题意：给定链表，这个链表按照<b>绝对值</b>升序排列。请将其按实际值升序排列。

难度：medium

解法：付费题。分离出<b>负数和非负数</b>两个链表l1、l2。那么结果就是`reverse(l1)+l2`。负数是<b>倒序</b>的，非负数是<b>顺序</b>的。那么我只需要O(n)操作，不用再进行排序。总代价`O(n)`。

<hr>

2047 Number of Valid Words in a Sentence

题意：给定一个英文句子，请判断其中合法单词的个数。合法单词可以是纯`a~z`，也可以<b>中间</b>带有`-`连字符，不能包含数字。注意句子末尾<b>可能有标点</b>，也可能没有。

难度：easy

解法：很无聊的一题。可以直接<b>正则匹配</b>，也可以split之后，手工检查。

<hr>

2049 Count Nodes With the Highest Score

题意：有一个二叉树，节点编号`0~n-1`。用`parents[i]`<b>父节点数组</b>的形式表示。其中0点是根，`parents[0]=-1`。现在我们考虑节点i，如果把i连接的边删除，则会分成几个不同的子树，我们把分成所有子树的节点个数乘起来，作为`scores[i]`。请求出`scores[i]==max(scores)`的个数。

难度：medium

解法：在给定的数据量下，我们需要一个`O(n)`的解法。其实很容易想，我先parents数组，把这个二叉树<b>重建起来</b>。然后用<b>二叉树</b>的形式，做<b>后序遍历</b>。统计出cc_left、cc_right，如果等于0表示<b>空子树</b>，忽略0值。那么<b>头顶</b>那棵<b>剩余的子树</b>，大小就是`n-cc_left-cc_right`。把其中的非零值乘起来，就是`scores[i]`。这个统计过程对于每个节点都是O(1)代价得到的，因此总代价`O(n)`。得到scores数组后，求`max_val`然后统计`==max_val`的个数即可。总代价`O(n)`。其实你也不需要构建二叉树，用<b>无向图</b>的形式，直接从0开始搜索，结果是一样的。

<hr>

2050 Parallel Courses III

题意：1136的变体。给定n门课，完成每个课的时间是`time[i]`。存在一些前置顺序`[x,y]`，表示必须<b>先完成x才能学y</b>。请求出至少多长时间，才能完成所有课。对于没有前置关系的课，你可以<b>同时学习多门</b>。

难度：hard

解法：这题的前两题我都没做，这是第三题了。就当一道<b>新题</b>吧。这题当然是个<b>有向图</b>的图论问题。有前置顺序，那很容易想到<b>拓扑排序</b>，先后关系嘛。我们给拓扑排序加一个time计算的逻辑。以<b>入度为0</b>的点作为<b>起始点</b>，起始`t=0`。随着往后走，累加`time[i]`<b>越变越大</b>。对于某个点`i`，可能存在<b>多个前置</b>，也就是通过<b>不同路径</b>到达`i`。那么不同路径的<b>路径和</b>当然<b>有大有小</b>，我们需要取这些路径的`max()`，也就是<b>最晚时间</b>。总结一下思路，就是<b>拓扑排序BFS+路径和取max</b>。总代价`O(V+E)`。

<hr>

2053 Kth Distinct String in an Array

题意：给定字符串数组arr，请按出现顺序，找出其中<b>第k个唯一值</b>。如果不足k个，则返回空串。

难度：easy

解法：先<b>哈希计数</b>，找出唯一值。然后再遍历一次，找出第k个唯一值。

<hr>

2054 Two Best Non-Overlapping Events

题意：给定一些事件，格式为`[s,e,v]`表示s开始、e结束、价值为v。请选出<b>至多两个</b>不重叠的事件，使得价值之和最大。

难度：medium

解法：先按照`[s,e]`二维进行<b>排序</b>，对于每个`[s[i],e[i]]`，我都按照`bisect_right(arr,e[i])`查找查找<b>最小的`s[j]`</b>。那么<b>从j以后的所有事件</b>，都不会产生冲突。可以用一个后缀max数组，记录v[j:n]的最大值。以`O(n)`代价进行预计算，之后可以`O(1)`查询。那么对于i位置，可得到的最大值就是`v[i]+max(v[j:n])`。排序和<b>n次二分查找</b>的代价都是O(nlogn)，因此总代价`O(nlogn)`。注意，题目说至多两个，还要考虑<b>一个事件</b>的情况。

<hr>

2057 Smallest Index With Equal Value

题意：给定数组nums，请找出最小的下标i，使得`i%10==nums[i]`。如果不存在则返回-1。

难度：easy

解法：水题。

<hr>

2058 Find the Minimum and Maximum Number of Nodes Between Critical Points

题意：给定链表，如果一个点<b>小于前后点</b>或者<b>大于前后点</b>，则称为<b>关键点</b>。请求出两个关键点的最大、最小距离。

难度：medium

解法：先找出关键点的位置`crits`。那么`min=min(crits[i]-crits[i-1])`，`max=crits[n-1]-crits[0]`。总代价`O(n)`。

<hr>

2062 Count Vowel Substrings of a String

题意：给定字符串s，请求出只包含`aeiou`且五个字符都有的子串的个数。

难度：easy

解法：以这个数据量，<b>直接枚举</b>也可以。如果要高效一点，那就滑动窗口+哈希计数吧。我选择直接枚举了，可以用位操作标记一下`aeiou`是否出现。总代价`O(n^2)`。

<hr>

2063 Vowels of All Substrings

题意：给定字符串s，请求出<b>所有子串</b>中，`aeiou`个数的总和。

难度：medium

解法：把问题<b>反过来看</b>，我们考虑每个`s[i]`在<b>多少个子串</b>中出现。比如`s[i]`，那么左边有`i`个，右边有`n-1-i`个，那么两边相乘，总共有`(i+1)*(n-i)`个子串。把所有元音的位置，按这个计算方式，累加起来，就是答案。总代价`O(n)`。这题的<b>思维</b>很好，一个问题你从<b>不同角度思考</b>，难度可能完全不同。

<hr>

2064 Minimized Maximum of Products Distributed to Any Store

题意：有n个商店，m种商品。m种商品的量分别是`quantities[i]`。你需要把所有商品分配到n个商店，要求每个商店只能有<b>一种商品</b>，数量是`stores[i]`，且要求`max(stores[i])`最小。请求出这个最小值。

难度：medium

解法：还是很经典的<b>minimax问题</b>，对这个`min(max(stores[i]))`直接做<b>二分搜索</b>。判断依据是，对于某个值x，我能否完成一种<b>分配方案</b>，使得`max(stores[i])<=x`。二分到<b>恰好x-1不行，x行</b>，则x就是答案。每次二分判断，相当于<b>尝试一次分配</b>，代价是`O(n)`。因此，总代价`O(nlog(int))`。

<hr>

2068 Check Whether Two Strings are Almost Equivalent

题意：给定字符串s1、s2，如果两者所有字符的频率之差都不超过3，则称为<b>接近</b>。请判断s1、s2是否接近。

难度：easy

解法：水题，按题意进行<b>哈希计数</b>即可。

<hr>

2070 Most Beautiful Item for Each Query

题意：有n件商品，每件有`[p,b]`代表价格和颜值。你需要回答m个查询，每个查询的格式为，“<b>价格不超过</b>q的商品，<b>最大颜值</b>是多少”。

难度：medium

解法：很简单，<b>按照p值升序排列</b>，然后<b>针对b值求前缀max</b>。对于每次查询，执行`i=bisect_right(arr,q)-1`。如果`i==-1`，则返回0；如果`i>=0`，则返回`前缀max[i]`的b值。总代价`O(nlogn)`。

<hr>

2073 Time Needed to Buy Tickets

题意：有n个人排队，0是队头，n-1是队尾。`tickets[i]`表示第i人需要买的票数。但有个奇怪的规则，每人每次只能买1张。如果还没买够，则需要移动到队尾再排一次；如果买够了，则离开。已知每次买票需要花`1s`，请问第k个人买完票需要多少秒？

难度：easy

解法：我忘了这个数学模型在哪儿看过，<b>很眼熟</b>。按这题easy难度，<b>直接模拟</b>也可以的。有没有<b>更聪明</b>的解法？我们看例子`[5,1,2,8]`，比如我考虑i=2的情况。我们按照一个个离队的情况考虑`[5,1,2,8]->[4,1,7]->[3,6]->[3]->[]`。因此，其实我们可以将值进行排序。算算每个人离队时，总共花了多少秒。每次累加，就是`差值*剩余轮数`这么累加。但是最后一轮不能加满，因为第i人<b>不一定在队尾</b>，可能提前离开的。这个解法可以`O(nlogn)`解决。如果是纯模拟，总代价则是`O(n*max(tickets))。`我补了一份<b>优化解法</b>，AC验证过了。

<hr>

2074 Reverse Nodes in Even Length Groups

题意：给定链表，按照长度`1,2,3,...`进行分组。把所有<b>长度偶数</b>的组反转，返回调整后的链表。

难度：medium

解法：题意很明确，按要求处理即可。注意<b>边界case</b>。

<hr>

2078 Two Furthest Houses With Different Colors

题意：给定数组nums，请找出`(i,j)`，使得`nums[i]!=nums[j]`且`|i-j|`最大。返回这个最大差值。

难度：easy

解法：数据量很小，<b>直接枚举</b>即可。

<hr>

2079 Watering Plants

题意：有n个朵花，分别在`i=0,1,2,...,n-1`位置。-1位置有水源，你有一个容量`capacity`的水壶。每朵花需要的水量是`plants[i]`。现在从-1位置满水壶出发，<b>依次</b>给每朵花浇水。如果你的水不够了，则需要返回-1处装满水，而且不允许提前返回。如果移动1格需要1时间，请计算浇完所有花的<b>总时间</b>。

难度：medium

解法：题目<b>非常具体</b>，按题意模拟即可。整个过程是<b>100%确定的</b>，没有需要思考的事。总代价`O(n)`。

<hr>

2083 Substrings That Begin and End With the Same Letter

题意：给定字符串s，请求出开头结尾是<b>同一字符</b>的子串个数。

难度：medium

解法：付费题。单字符也算，这就有n个。然后考虑每种字符的出现次数cc。那么总共有`C(cc,2)=cc*(cc-1)/2`。因此，答案就是`n+sum(cc*(cc-1)/2)`。对于medium难度，这算是水题了。总代价`O(n)`。

<hr>

2085 Count Common Words With One Occurrence

题意：给定两个词表words1、words2，请求出在两个词表中都出现1次的单词。

难度：easy

解法：进行<b>哈希计数</b>，得到mm1、mm2，找出`mm1[w]==1,mm2[w]==1`的情况。总代价`O(n)`。

<hr>

2087 Minimum Cost Homecoming of a Robot in a Grid

题意：有一个m x n矩阵，机器人从`(sx,sy)`出发，要到达`(ex,ey)`。可以上下左右走，移动到i行代价为`rowCosts[i]`，移动到j列代价为`colCosts[j]`。请求出最小的总代价。

难度：medium

解法：这题太扯了，鉴定为<b>脑筋急转弯</b>。直接从sx到ex，从sy到ey即可。总代价`O(m+n)`。

<hr>

2088 Count Fertile Pyramids in a Land

题意：给定m x n的01矩阵，在其中统计正金字塔、倒金字塔的个数。金字塔按照`1,3,5,...`这样对称排列，<b>从上到下或者从下到上</b>。

难度：hard

解法：我们先考虑暴力枚举。如果我以每个`a[i][j]`为塔尖，向上或者向下枚举，那么一次枚举的代价就是`O(n^2)`，这太慢了。必然要减少重复计算，这就考虑到DP思想了。比如我考虑`dp[i][j]`为以`(i,j)`为塔尖的倒金字塔的最大层数。那么如果`a[i][j]==0`，则`dp[i][j]=0`；如果`a[i][j]==1`，则`dp[i][j]=min(dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1])+1`。你看，这个递推是`O(1)`的，这样总代价就降到`O(n^2)`了。正金字塔、倒金字塔的计算，都采用这个方式，不过<b>递推方向</b>是反过来的。看了下我<b>以前的代码</b>，和这个思路类似，但不完全相同。我也看不懂到底在做什么。

<hr>

2089 Find Target Indices After Sorting Array

题意：给定数组nums和目标值target。请将nums排序后，返回target值所有位置，升序排列。

难度：easy

解法：<b>先排序，然后二分查找</b>即可。顺序查找也行，反正<b>排序的代价</b>占大头。总代价`O(nlogn)`。

<hr>

2091 Removing Minimum and Maximum From Array

题意：给定数组nums，所有值都不同。请先找出min和max，然后删除它们。但要求必须从nums开头、结尾不断删除元素，不能直接删除这两个值。请求出最小的删除次数。

难度：medium

解法：找出min和max对应的位置i、j，不妨假设`i<j`。那么答案就是`min(j+1,n-i,i+1+n-j)`。要么从左，要么从右，要么两边删。总代价`O(n)`。

<hr>

2094 Finding 3-Digit Even Numbers

题意：给定数组digits，元素都是0~9的数字，可能有重复。请从中选出3个，组成<b>`>=100`的3位偶数</b>。请返回所有可能的<b>唯一值</b>，按<b>升序</b>排列。

难度：easy

解法：不要直接暴力搜索，先把digits转化为<b>哈希计数</b>，而且计数超过3就按3处理，因为你<b>只需要3位数</b>。接下来，搜索枚举即可。注意最后一位是<b>偶数</b>。结果按`sorted(set())`处理。

<hr>

2095 Delete the Middle Node of a Linked List

题意：给定n长度链表，删除中间节点。中点按照`floor(n/2)`处理。

难度：medium

解法：可以用<b>快慢指针</b>的方法定位到中点，或者说<b>中点的前一点</b>。这个更方便删除。总代价`O(n)`。

<hr>

2096 Step-By-Step Directions From a Binary Tree Node to Another

题意：给定二叉树和其中两个节点s、t。请求出从s到t的路径，用`ULR`表示<b>上左右</b>。

难度：medium

解法：首先，这个路径是<b>唯一的</b>，不存在“最短路”的说法，除非你走重复路。我们可以通过遍历，分别得到<b>从根到s、从根到t</b>的两条路径ps、pt。那么ps、pt的公共前缀部分，你可以删掉。比如例子`ps=0010,pt=011101`，公共前缀是`0`，这个删掉。剩下部分是`ps=010,pt=11101`，你需要`UUU`，然后`RRRLR`。那么答案就是`UUURRRLR`。看懂这个例子，就知道该怎么做了。总代价`O(n)`。

<hr>

2097 Valid Arrangement of Pairs

题意：给定一些数对`(x,y)`，请将其排序，使得相邻的数对都满足`y[i]==x[i+1]`，也就是<b>“首尾相接”</b>。给定数据保证<b>一定有解</b>。

难度：hard

解法：起初我以为是个<b>图论题</b>，但看了<b>数据量</b>，想了下思路，又觉得不是。后来想了下，还是图论。比如我从某点出发，走一条路径。如果能把<b>所有边都用完</b>，这就是答案。这就是<b>欧拉路径</b>，每条边恰好用一次。查了资料又想了想，最后用了一个<b>特殊判定条件</b>`outd[x]-ind[x]==1`，<b>出度-入度等于1</b>。满足这个条件的点，可以作为<b>遍历的起点</b>。但这样的点不一定存在，比如一个环路就不存在这种点，这时我们<b>随便选一个点</b>就行了。剩下就是常规的<b>有向图遍历</b>了。因为这个遍历是一定会成功的，因此<b>只搜索不回溯</b>。一边遍历，<b>一边删除图中的边</b>，并把边加入<b>结果集res</b>中。这叫<b>不走回头路</b>。遍历完成时，图<b>删光了</b>，结果也<b>填满了</b>。总代价`O(n)`。这题确实难，主要难点在于你首先要<b>建图</b>，然后得知道从<b>哪个点</b>开始遍历。

<hr>

2099 Find Subsequence of Length K With the Largest Sum

题意：给定数组nums，请找出长度为k的子序列，使得求和最大。返回<b>子序列</b>。

难度：easy

解法：先按照`(val,i)`排序，找出<b>k个最大的值</b>。把值取出来，再按照`(i,val)`排序，把顺序还原过来。这样就得到按<b>原顺序排列</b>的<b>最大的k个值</b>了。总代价`O(nlogn)`。
